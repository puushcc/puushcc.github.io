<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Java基础 | Puushcc</title>
  <meta name="keywords" content=" 后端 , java基础 , javaSE ">
  <meta name="description" content="Java基础 | Puushcc">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="关于我">
<meta property="og:type" content="website">
<meta property="og:title" content="about">
<meta property="og:url" content="http://example.com/about/index.html">
<meta property="og:site_name" content="Puushcc">
<meta property="og:description" content="关于我">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-07-10T14:44:00.000Z">
<meta property="article:modified_time" content="2021-07-10T14:54:50.894Z">
<meta property="article:author" content="Puushcc">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.4.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>Puushcc</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://puushcc.github.io/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(2)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="后端">
                        <i class="fold iconfont icon-right"></i>
                        
                        后端
                        <small>(1)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="后端<--->java">
                                        
                                        java
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="运维">
                        <i class="fold iconfont icon-right"></i>
                        
                        运维
                        <small>(1)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="运维<--->Linux">
                                        
                                        Linux
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="2">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="https://puushcc.github.io/">puushcc</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>后端</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>java基础</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>javaSE</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Linux命令</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a  class="全部文章 后端 java "
           href="/2021/07/10/Java%E5%9F%BA%E7%A1%80/"
           data-tag="后端,java基础,javaSE"
           data-author="" >
            <span class="post-title" title="Java基础">Java基础</span>
            <span class="post-date" title="2021-07-10 20:13:47">2021/07/10</span>
        </a>
        
        <a  class="全部文章 运维 Linux "
           href="/2021/07/10/Linux%E5%91%BD%E4%BB%A4/"
           data-tag="Linux,Linux命令"
           data-author="" >
            <span class="post-title" title="Linux命令">Linux命令</span>
            <span class="post-date" title="2021-07-10 15:13:47">2021/07/10</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-Java基础" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Java基础</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="后端">后端</a> > 
            
            <a  data-rel="后端&lt;---&gt;java">java</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color3">后端</a>
            
            <a class="color2">java基础</a>
            
            <a class="color2">javaSE</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2021-07-11 01:43:16'>2021-07-10 20:13</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-JDK%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="toc-text">Java JDK安装和配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%8B%E8%BD%BDJDK"><span class="toc-text">1.下载JDK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Window%E5%AE%89%E8%A3%85jdk%E7%8E%AF%E5%A2%83"><span class="toc-text">2.Window安装jdk环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Linux%E5%AE%89%E8%A3%85jdk%E7%8E%AF%E5%A2%83"><span class="toc-text">3.Linux安装jdk环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%9F%A5%E7%9C%8BJava%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="toc-text">4.查看Java版本信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">Java基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F"><span class="toc-text">1. 第一个Java程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">2. 基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Java%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">3. Java标识符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Java%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">4. Java修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Java%E5%8F%98%E9%87%8F"><span class="toc-text">5. Java变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Java%E6%95%B0%E7%BB%84"><span class="toc-text">6. Java数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Java%E6%9E%9A%E4%B8%BE"><span class="toc-text">7. Java枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Java%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">8. Java关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E6%B3%A8%E9%87%8A"><span class="toc-text">9. 注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E7%BB%A7%E6%89%BF"><span class="toc-text">10. 继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E6%8E%A5%E5%8F%A3"><span class="toc-text">11. 接口</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB"><span class="toc-text">Java对象和类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java%E5%AF%B9%E8%B1%A1"><span class="toc-text">1. Java对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Java%E7%B1%BB"><span class="toc-text">2. Java类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-text">访问实例变量和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E6%96%87%E4%BB%B6%E5%A3%B0%E6%98%8E%E8%A7%84%E5%88%99"><span class="toc-text">源文件声明规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%8C%85"><span class="toc-text">Java包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#import%E8%AF%AD%E5%8F%A5"><span class="toc-text">import语句</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0%E6%A1%88%E4%BE%8B"><span class="toc-text">3. 一个简单学习案例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">Java基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1. 原始数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">2. 引用数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Java%E6%96%87%E5%AD%97"><span class="toc-text">3. Java文字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">Java变量类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">1. 局部变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="toc-text">2. 实例变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B1%BB-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-text">3. 类&#x2F;静态变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-text">Java修饰符类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">1. 访问控制修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%9D%9E%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">2. 非访问修饰符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E9%9D%9E%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">Java非访问修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-static%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">1. static修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-final%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">2. final修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-abstract%E9%A5%B0%E7%AC%A6"><span class="toc-text">3. abstract饰符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-synchronized%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">4. synchronized修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-transient%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">5. transient修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-volatile%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">6. volatile修饰符</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">Java基本运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">1. 算术运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">2. 关系运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">3. 按位运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">4. 逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">5. 赋值运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%85%B6%E5%AE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">6. 其它运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-text">Java循环控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">1. 循环控制语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A2%9E%E5%BC%BAJava%E5%BE%AA%E7%8E%AF"><span class="toc-text">2. 增强Java循环</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-if-else%E8%AF%AD%E5%8F%A5"><span class="toc-text">Java if&#x2F;else语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-if%E8%AF%AD%E5%8F%A5"><span class="toc-text">Java if语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A4%BA%E4%BE%8B"><span class="toc-text">1. 示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-if-else%E8%AF%AD%E5%8F%A5-1"><span class="toc-text">Java if-else语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-if-else-if%E8%AF%AD%E5%8F%A5"><span class="toc-text">Java if-else-if语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-switch%E8%AF%AD%E5%8F%A5"><span class="toc-text">Java switch语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-switch%E8%AF%AD%E5%8F%A5%E8%90%BD%E7%A9%BA%E9%80%9A%E8%BF%87%E6%89%80%E6%9C%89case%E8%AF%AD%E5%8F%A5"><span class="toc-text">Java switch语句落空通过所有case语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-for%E5%BE%AA%E7%8E%AF"><span class="toc-text">Java for循环</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java%E7%AE%80%E5%8D%95For%E5%BE%AA%E7%8E%AF"><span class="toc-text">1. Java简单For循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Java-for-each%E5%BE%AA%E7%8E%AF"><span class="toc-text">2. Java for-each循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Java%E6%A0%87%E8%AE%B0For%E5%BE%AA%E7%8E%AF"><span class="toc-text">3. Java标记For循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Java%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF"><span class="toc-text">4. Java无限循环</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-while%E5%BE%AA%E7%8E%AF"><span class="toc-text">Java while循环</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%97%A0%E9%99%90while%E5%BE%AA%E7%8E%AF"><span class="toc-text">Java无限while循环</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-do-while%E5%BE%AA%E7%8E%AF"><span class="toc-text">Java do-while循环</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%97%A0%E9%99%90do-while%E5%BE%AA%E7%8E%AF"><span class="toc-text">Java无限do-while循环</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-break%E8%AF%AD%E5%8F%A5"><span class="toc-text">Java break语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Break%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF"><span class="toc-text">Java Break语句和循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%86%85%E9%83%A8%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-text">Java内部循环语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-continue%E8%AF%AD%E5%8F%A5"><span class="toc-text">Java continue语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-continue%E8%AF%AD%E5%8F%A5%E7%A4%BA%E4%BE%8B"><span class="toc-text">Java continue语句示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-continue%E8%AF%AD%E5%8F%A5%E4%B8%8E%E5%86%85%E5%BE%AA%E7%8E%AF"><span class="toc-text">Java continue语句与内循环</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%B3%A8%E9%87%8A"><span class="toc-text">Java注释</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%B3%A8%E9%87%8A%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">Java注释的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A"><span class="toc-text">1)Java单行注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Java%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A"><span class="toc-text">2)Java多行注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Java%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="toc-text">3)Java文档注释</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80%E5%AE%9E%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="toc-text">Java基础实例程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%90%E6%B3%A2%E7%BA%B3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-text">1. 斐波纳契数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B4%A0%E6%95%B0%E5%AE%9E%E4%BE%8B"><span class="toc-text">2. 素数实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9B%9E%E6%96%87%E6%95%B0"><span class="toc-text">3. 回文数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%98%B6%E4%B9%98"><span class="toc-text">4. 阶乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%98%BF%E5%A7%86%E6%96%AF%E5%A3%AE%E6%95%B0"><span class="toc-text">5. 阿姆斯壮数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">6. 气泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">7. 选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">8. 插入排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88OOP%EF%BC%89%E6%A6%82%E5%BF%B5"><span class="toc-text">Java面向对象（OOP）概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-text">1. 面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%AF%B9%E8%B1%A1"><span class="toc-text">1.1. 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E7%B1%BB"><span class="toc-text">1.2. 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E7%BB%A7%E6%89%BF"><span class="toc-text">1.3. 继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-text">1.4. 多态性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E6%8A%BD%E8%B1%A1"><span class="toc-text">1.5. 抽象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-%E5%B0%81%E8%A3%85"><span class="toc-text">1.6. 封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-%E7%BB%84%E5%90%88"><span class="toc-text">1.7. 组合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">2. 面向对象编程的优点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A"><span class="toc-text">Java命名约定</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">java命名约定的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E7%9A%84%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-text">java的驼峰命名规则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB-1"><span class="toc-text">Java对象和类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">1. Java中的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Java%E4%B8%AD%E7%9A%84%E7%B1%BB"><span class="toc-text">2. Java中的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Java%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="toc-text">2.1. Java中的实例变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Java%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">2.2. Java中的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Java%E4%B8%AD%E7%9A%84new%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">2.3. Java中的new关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%E7%A4%BA%E4%BE%8B%EF%BC%9A-main%E6%96%B9%E6%B3%95%E5%92%8C%E7%B1%BB"><span class="toc-text">2.4. 对象和类示例： main方法和类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%E7%A4%BA%E4%BE%8B%EF%BC%9Amain%E6%96%B9%E6%B3%95%E5%9C%A8%E7%B1%BB%E5%A4%96%E9%83%A8"><span class="toc-text">2.5. 对象和类示例：main方法在类外部</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-text">3. 初始化对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%80%9A%E8%BF%87%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.1. 通过引用变量初始化对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E9%80%9A%E8%BF%87%E6%96%B9%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.2. 通过方法初始化对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.3. 通过构造函数初始化对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%E7%A4%BA%E4%BE%8B%EF%BC%9AEmployee"><span class="toc-text">3.3.1. 对象和类示例：Employee</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%E7%A4%BA%E4%BE%8B%EF%BC%9ARectangle"><span class="toc-text">3.3.2. 对象和类示例：Rectangle</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8Java%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">在Java中创建对象的不同方法有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="toc-text">匿名对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%85%E5%88%9B%E5%BB%BA%E5%90%8C%E4%B8%AA%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-text">仅创建同个类型的多个对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%9F%E5%AE%9E%E7%9A%84%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B-Account"><span class="toc-text">真实的应用示例: Account</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%88%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-text">Java构造器（构造方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAjava%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text">创建java构造函数的规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">Java构造函数的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E6%97%A0%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">1. Java默认构造函数(无参数构造函数)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Java%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">2. Java参数化构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-text">Java构造函数重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">java的构造函数和方法之间的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">Java拷贝构造函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">Java static关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-text">1. Java静态变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Java%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">2. Java静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Java%E9%9D%99%E6%80%81%E5%9D%97"><span class="toc-text">3. Java静态块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">Java this关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-this%EF%BC%9A%E5%BC%95%E7%94%A8%E5%BD%93%E5%89%8D%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="toc-text">1. this：引用当前类的实例变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-this%EF%BC%9A%E8%B0%83%E7%94%A8%E5%BD%93%E5%89%8D%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">2. this：调用当前类方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-this-%EF%BC%9A%E8%B0%83%E7%94%A8%E5%BD%93%E5%89%8D%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">3. this()：调用当前类的构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8this-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-text">使用this()构造函数调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-this%EF%BC%9A%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%99%E6%96%B9%E6%B3%95"><span class="toc-text">4. this：作为参数传递给方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%EF%BC%9A%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%B8%AD%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">this：在构造函数调用中作为参数传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-this%E5%85%B3%E9%94%AE%E5%AD%97%E7%94%A8%E6%9D%A5%E8%BF%94%E5%9B%9E%E5%BD%93%E5%89%8D%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-text">6. this关键字用来返回当前类的实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E7%BB%A7%E6%89%BF"><span class="toc-text">Java继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8java%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-text">为什么在java中使用继承？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E7%BB%A7%E6%89%BF%E7%B1%BB%E5%9E%8B"><span class="toc-text">java继承类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8D%95%E4%B8%80%E7%BB%A7%E6%89%BF%E7%A4%BA%E4%BE%8B"><span class="toc-text">(1). 单一继承示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%9A%E7%BA%A7%E7%BB%A7%E6%89%BF%E7%A4%BA%E4%BE%8B"><span class="toc-text">(2). 多级继承示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%9A%E7%BA%A7%E7%BB%A7%E6%89%BF%E7%A4%BA%E4%BE%8B"><span class="toc-text">(3). 多级继承示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E8%81%9A%E5%90%88"><span class="toc-text">Java聚合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%81%9A%E5%90%88%EF%BC%9F"><span class="toc-text">为什么要使用聚合？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E7%9A%84%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">聚合的简单示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E8%81%9A%E5%90%88%EF%BC%9F"><span class="toc-text">何时使用聚合？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E8%81%9A%E5%90%88%E7%9A%84%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B"><span class="toc-text">理解聚合的一个示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-text">Java方法重载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%EF%BC%9A-%E4%BF%AE%E6%94%B9%E5%8F%82%E6%95%B0%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-text">1. 方法重载： 修改参数的数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%EF%BC%9A%E6%9B%B4%E6%94%B9%E5%8F%82%E6%95%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">2. 方法重载：更改参数的数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8D%87"><span class="toc-text">方法重载和类型提升</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-text">Java方法重写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-text">方法覆盖的示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-text">Java方法重写的实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">Java super关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-super%E7%94%A8%E4%BA%8E%E5%BC%95%E7%94%A8%E7%9B%B4%E6%8E%A5%E7%88%B6%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="toc-text">1. super用于引用直接父类实例变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87-super-%E6%9D%A5%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">2. 通过 super 来调用父类方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-super-%E6%9D%A5%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">3. 使用 super 来调用父类构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">super实际使用示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A8%8B%E5%BA%8F%E5%9D%97"><span class="toc-text">Java实例初始化程序块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97%EF%BC%9F"><span class="toc-text">为什么要使用实例初始化块？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">Java final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java-final%E5%8F%98%E9%87%8F"><span class="toc-text">1. Java final变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Java-final%E6%96%B9%E6%B3%95"><span class="toc-text">2. Java final方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Java-final%E7%B1%BB"><span class="toc-text">3. Java final类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%A9%BA%E7%99%BDfinal%E5%8F%98%E9%87%8F"><span class="toc-text">静态空白final变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%A4%9A%E6%80%81"><span class="toc-text">Java多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-text">1. Java运行时多态性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81%E6%80%A7%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-text">Java运行时多态性与数据成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81%E6%80%A7%E4%B8%8E%E5%A4%9A%E7%BA%A7%E7%BB%A7%E6%89%BF"><span class="toc-text">Java运行时多态性与多级继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-text">Java静态绑定和动态绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E7%B1%BB%E5%9E%8B"><span class="toc-text">了解类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%98%E9%87%8F%E6%9C%89%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B"><span class="toc-text">1. 变量有一个类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E6%9C%89%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B"><span class="toc-text">2. 引用有一个类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E6%9C%89%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B"><span class="toc-text">2. 对象有一个类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-text">静态绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-text">动态绑定</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-instanceof%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">Java instanceof运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%9C%A8java%E4%B8%AD%E4%BD%BF%E7%94%A8instanceof%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-text">理解在java中使用instanceof的实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">Java抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1"><span class="toc-text">Java中的抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8A%BD%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">实现抽象的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">1. Java中的抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E7%9C%9F%E5%AE%9E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">理解抽象类的真实应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%9C%9F%E5%AE%9E%E5%9C%BA%E6%99%AF"><span class="toc-text">抽象类的另一个真实场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%8E%A5%E5%8F%A3"><span class="toc-text">Java接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Java%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="toc-text">为什么要使用Java接口？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-8%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-text">Java 8接口的改进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">了解类和接口之间的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%A4%9A%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3"><span class="toc-text">Java多继承接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="toc-text">接口继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-8%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-text">Java 8接口中的默认方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-8%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">Java 8接口中的静态方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Java抽象类和接口的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-text">使用抽象类和接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-text">Java抽象类和接口的示例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%8C%85-1"><span class="toc-text">Java包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8-packagename"><span class="toc-text">1. 使用 packagename.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8packagename-classname"><span class="toc-text">2. 使用packagename.classname</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E5%90%8D"><span class="toc-text">3. 使用完全限定名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8java%E4%B8%AD%E7%9A%84%E5%AD%90%E5%8C%85"><span class="toc-text">在java中的子包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">Java访问修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#private%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">private访问修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-private%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">1. private访问修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-default%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">2. default访问修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-protected%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">3. protected访问修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-public%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">4. public访问修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E6%89%80%E6%9C%89java%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">理解所有java访问修饰符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%B0%81%E8%A3%85"><span class="toc-text">Java封装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8java%E4%B8%AD%E5%B0%81%E8%A3%85%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">在java中封装的优势</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-Object%E7%B1%BB"><span class="toc-text">Java Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Object%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">Object类的方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86"><span class="toc-text">Java对象克隆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8clone-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">为什么要使用clone()方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clone-%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B-%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86"><span class="toc-text">clone()方法示例(对象克隆)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%95%B0%E7%BB%84"><span class="toc-text">Java数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">Java包装类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%8C%89%E5%80%BC%E8%B0%83%E7%94%A8%E5%92%8C%E5%BC%95%E7%94%A8%E8%B0%83%E7%94%A8"><span class="toc-text">Java按值调用和引用调用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-strictfp%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">Java strictfp关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-text">Java命令行参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%86%B3%E7%AD%96%E5%88%B6%E5%AE%9A"><span class="toc-text">Java决策制定</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">? : 运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-Number%E7%B1%BB"><span class="toc-text">Java Number类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Number%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">Number类的方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-Character%E7%B1%BB"><span class="toc-text">Java Character类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97"><span class="toc-text">1. 转义序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Character%E6%96%B9%E6%B3%95"><span class="toc-text">Character方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-String%E7%B1%BB"><span class="toc-text">Java String类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">1. 创建字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="toc-text">2. 字符串长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BF%9E%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">3. 连接字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">3. 创建格式化字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-String%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">4. String类方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%95%B0%E7%BB%84-1"><span class="toc-text">Java数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84%E5%8F%98%E9%87%8F"><span class="toc-text">1. 声明数组变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-text">2. 创建数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84"><span class="toc-text">3. 处理数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-foreach%E5%BE%AA%E7%8E%AF"><span class="toc-text">3.1. foreach循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%B0%86%E6%95%B0%E7%BB%84%E4%BC%A0%E9%80%92%E7%BB%99%E6%96%B9%E6%B3%95"><span class="toc-text">3.2. 将数组传递给方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E4%BB%8E%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84"><span class="toc-text">3.3. 从方法返回数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-Arrays%E7%B1%BB"><span class="toc-text">3.4. Arrays类</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-text">Java日期时间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4"><span class="toc-text">1. 获取当前日期和时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8SimpleDateFormat%E8%AE%BE%E7%BD%AE%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F"><span class="toc-text">2. 使用SimpleDateFormat设置日期格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8printf%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F"><span class="toc-text">3. 使用printf格式化日期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6"><span class="toc-text">4. 日期和时间转换字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90%E4%B8%BA%E6%97%A5%E6%9C%9F"><span class="toc-text">5. 将字符串解析为日期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E7%9D%A1%E7%9C%A0%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4"><span class="toc-text">6. 睡眠一段时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%B5%8B%E9%87%8F%E7%BB%8F%E8%BF%87%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-text">7. 测量经过的时间</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">Java正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8D%95%E8%8E%B7%E7%BB%84"><span class="toc-text">1. 捕获组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="toc-text">2. 正则表达式语法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%96%B9%E6%B3%95"><span class="toc-text">Java方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="toc-text">1. 创建方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-text">2. 方法调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-void%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">3. void关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-text">4. 按值传递参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-text">5. 方法重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-text">6. 使用命令行参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-this-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">7. this 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%8F%98%E9%87%8F%E5%8F%82%E6%95%B0-var-args"><span class="toc-text">8. 变量参数(var-args)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-finalize-%E6%96%B9%E6%B3%95"><span class="toc-text">9. finalize()方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%96%87%E4%BB%B6%E5%92%8C%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%EF%BC%88I-O%EF%BC%89"><span class="toc-text">Java文件和输入和输出（I&#x2F;O）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B5%81-Streams"><span class="toc-text">1. 流(Streams)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A0%87%E5%87%86%E6%B5%81"><span class="toc-text">2. 标准流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-text">3. 读写文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%96%87%E4%BB%B6%E5%AF%BC%E8%88%AA%E5%92%8CI-O"><span class="toc-text">4. 文件导航和I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C"><span class="toc-text">4.1. 目录操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">Java异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BC%82%E5%B8%B8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">1. 异常层次结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%BC%82%E5%B8%B8%E6%96%B9%E6%B3%95"><span class="toc-text">2. 异常方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8D%95%E6%8D%89%E5%BC%82%E5%B8%B8"><span class="toc-text">3. 捕捉异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%A4%9A%E4%B8%AAtry%E5%9D%97"><span class="toc-text">4. 多个try块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-throws-throw%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">5. throws&#x2F;throw关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-finally%E5%9D%97"><span class="toc-text">6. finally块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-try-with-resources"><span class="toc-text">7.  try-with-resources</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-text">8. 用户定义的异常</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>//原文出自【易百教程】</p>
<h1 id="Java-JDK安装和配置"><a href="#Java-JDK安装和配置" class="headerlink" title="Java JDK安装和配置"></a>Java JDK安装和配置</h1><p>JAVA开发环境安装是基于： </p>
<ul>
<li>Java8(JDK8) </li>
</ul>
<h2 id="1-下载JDK"><a href="#1-下载JDK" class="headerlink" title="1.下载JDK"></a><strong>1.下载JDK</strong></h2><p><a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p>
<p>应该检查你的操作系统是32位或64位的，并下载相应的JDK版本</p>
<h2 id="2-Window安装jdk环境"><a href="#2-Window安装jdk环境" class="headerlink" title="2.Window安装jdk环境"></a><strong>2.Window安装jdk</strong>环境</h2><p>配置Java环境变量</p>
<hr>
<p>“新建” 创建一个名为 JAVA_HOME 新的环境变量。 </p>
<p>​        输入路径JDK目录。 </p>
<ul>
<li>变量名称: JAVA_HOME         </li>
<li>变量值: D:\Program Files\Java\jdk1.8.0_65</li>
</ul>
<p>下一步修改环境变量路径(Path)。 </p>
<p>​        添加到路径(Path)的前面(或后面或中间都可以)： </p>
<ul>
<li>%JAVA_HOME%\bin;</li>
</ul>
<h2 id="3-Linux安装jdk环境"><a href="#3-Linux安装jdk环境" class="headerlink" title="3.Linux安装jdk环境"></a><strong>3.Linux安装jdk</strong>环境</h2><p>到Oracle官方下载JDK，下载后解压并配置系统环境变量。</p>
<pre><code class="shell">tar -zxvf jdk1.8.0_212.tar.gz
mv jdk1.8.0_212 /usr/local
</code></pre>
<p>接下来，配置系统环境变量。</p>
<pre><code>vim /etc/profile
</code></pre>
<p>配置项内容如下所示。</p>
<pre><code class="shell">JAVA_HOME=/usr/local/jdk1.8.0_212
CLASS_PATH=.:$JAVA_HOME/lib
PATH=$JAVA_HOME/bin:$PATH
export JAVA_HOME CLASS_PATH PATH
</code></pre>
<p>接下来执行如下命令使系统环境变量生效。</p>
<pre><code class="shell">source /etc/profile
</code></pre>
<h2 id="4-查看Java版本信息"><a href="#4-查看Java版本信息" class="headerlink" title="4.查看Java版本信息"></a>4.查看Java版本信息</h2><p>java -version</p>
<h1 id="Java基本语法"><a href="#Java基本语法" class="headerlink" title="Java基本语法"></a>Java基本语法</h1><p>当我们研究Java程序时，它一种定义为通过调用彼此的方法进行通信的对象集合。 下面简要地看一下：类，对象，方法和实例变量的含义。</p>
<ul>
<li><strong>类</strong> - 类是用于描述其类型对象支持的行为/状态的模板/蓝图。</li>
<li><strong>对象</strong> - 对象具有状态和行为。 示例：狗有状态 - 颜色，名称，品种以及例如：摇尾巴，吠叫，吃东西等行为。对象是类的实例。</li>
<li><strong>方法</strong> - 方法是一种行为，一个类可以包含许多方法。它用于写入逻辑，操纵数据并执行所有操作。</li>
<li><strong>实例变量</strong> - 每个对象都有其唯一的实例变量集。 对象的状态由分配给这些实例变量的值来创建。</li>
</ul>
<h4 id="1-第一个Java程序"><a href="#1-第一个Java程序" class="headerlink" title="1. 第一个Java程序"></a>1. 第一个Java程序</h4><p>下面来看一个简单打印字符串：<code>Hello World</code>的Java代码。</p>
<pre><code class="java">public class HelloWorld &#123;

   /* 这是第一个Java程序
    * 此程序执行后将打印输出：&#39;Hello World&#39; 
    */

   public static void main(String []args) &#123;
      System.out.println(&quot;Hello World - from yiibai.com&quot;); // 打印输出 Hello World
   &#125;
&#125;
Java
</code></pre>
<p>下面来看看如何保存文件，编译和运行程序。请按照后续步骤 - </p>
<ul>
<li>打开记事本并添加上面的代码。</li>
<li>将文件另存为：<em>HelloWorld.java</em> ，假设存到目录：<em>D:/worksp/java</em>。<br><img src="https://www.yiibai.com/uploads/article/2019/03/05/104217_47755.png" alt="保存Java文件"></li>
<li>打开命令提示符窗口并转到保存该类文件(<em>HelloWorld.java</em>)的目录。</li>
<li>输入<code>javac HelloWorld.java</code>并按<em>Enter</em>键编译代码。如果代码中没有错误，命令提示符将进入到下一行。</li>
<li>接下来，输入<code>java HelloWorld</code>来运行上面程序。</li>
<li>最后应该能在窗口上看到输出：<code>Hello World - from yiibai.com</code>。</li>
</ul>
<p>执行过程如下图所示：<br><img src="https://www.yiibai.com/uploads/article/2019/03/05/104542_93532.png" alt="编译Java程序"></p>
<h4 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h4><p>关于Java程序，请务必牢记以下几点。</p>
<ul>
<li><strong>区分大小写</strong> -  Java区分大小写，因此标识符<code>Hello</code>和<code>hello</code>在Java中具有不同的含义。</li>
<li><strong>类名</strong> - 对于所有类名，第一个字母应为大写。 如果使用多个单词来形成类的名称，则每个内部单词的第一个字母应为大写。<br>示例：<code>class MyFirstJavaClass</code></li>
<li><strong>方法名称</strong> - 所有方法名称都应以小写字母开头。如果使用多个单词来形成方法的名称，那么每个内部单词的第一个字母应该是大写字母。<br>示例：<code>public void myMethodName()</code></li>
<li><strong>程序文件名</strong> - 程序文件的名称应与类名完全匹配。保存文件时，应使用类名保存它(记住Java区分大小写)并在名称的末尾使用扩展名称：<code>.java</code>(如果文件名和类名不匹配，则程序将无法编译))。但请注意，如果代码文件中没有<code>public class</code>，则文件名可能与类名不同。在代码文件中也没有强制要求必须有<code>public class</code>。<br>示例：假设<code>MyFirstJavaProgram</code>是类名，那么该文件应保存为：<em>MyFirstJavaProgram.java</em>。</li>
<li><code>public static void main(String args[])</code> − Java程序处理从<code>main()</code>方法开始，该方法是每个Java程序的必需部分。</li>
</ul>
<h4 id="3-Java标识符"><a href="#3-Java标识符" class="headerlink" title="3. Java标识符"></a>3. Java标识符</h4><p>所有Java组件都需要名称。 用于类，变量和方法的名称称为<strong>标识符</strong>。<br>在Java中，标识符的命名有几点要记住。 它们如下 - </p>
<ul>
<li>所有标识符都应以字母(<code>A</code>到<code>Z</code>或<code>a</code>到<code>z</code>)，货币字符(<code>$</code>)或下划线(<code>_</code>)开头。</li>
<li>在第一个字符之后，标识符可以是任何字符组合。</li>
<li>关键字不能用作标识符。</li>
<li>标识符区分大小写。</li>
<li>合法标识符的示例：<code>age</code>，<code>$salary</code>，<code>_value</code>，<code>__1_value</code>。</li>
<li>非法标识符的示例：<code>123abc</code>，<code>-salary</code>。</li>
</ul>
<h4 id="4-Java修饰符"><a href="#4-Java修饰符" class="headerlink" title="4. Java修饰符"></a>4. Java修饰符</h4><p>与其他语言一样，可以通过使用修饰符来修改类，方法等。 修饰符分为两类 - </p>
<ul>
<li>访问修饰符 - <code>default</code>, <code>public</code> , <code>protected</code>, <code>private</code>；</li>
<li>非访问修饰符 -  <code>final</code>，<code>abstract</code>，<code>strictfp</code>；</li>
</ul>
<p>在下一节中学习有关修饰符的更多细节。</p>
<h4 id="5-Java变量"><a href="#5-Java变量" class="headerlink" title="5. Java变量"></a>5. Java变量</h4><p>以下是Java中的变量类型 - </p>
<ul>
<li>局部变量</li>
<li>类变量(静态变量)</li>
<li>实例变量(非静态变量)</li>
</ul>
<h4 id="6-Java数组"><a href="#6-Java数组" class="headerlink" title="6. Java数组"></a>6. Java数组</h4><p>数组是存储多个相同类型变量的对象。 但是，数组本身是堆上的对象。在接下来的章节中将学习如何声明，构造和初始化数组。</p>
<h4 id="7-Java枚举"><a href="#7-Java枚举" class="headerlink" title="7. Java枚举"></a>7. Java枚举</h4><p>枚举是在Java 5.0中引入的。 枚举将变量限制为仅具有少数预定义值之一。此枚举列表中的值称为枚举。<br>通过使用枚举，可以减少代码中的错误数量。</p>
<p>例如，在新鲜果汁店中，可将玻璃杯大小限制为：<em>小杯</em>，<em>中杯</em>和<em>大杯</em>。 这将确保它不允许购买除了小杯，中杯或大杯之外的玻璃杯。</p>
<p>示例代码：</p>
<pre><code class="java">class FreshJuice &#123;
    // 定义枚举
    enum FreshJuiceSize&#123; SMALL, MEDIUM, LARGE &#125;
    FreshJuiceSize size;
&#125;

public class FreshJuiceTest &#123;

   public static void main(String args[]) &#123;
      FreshJuice juice = new FreshJuice();
      juice.size = FreshJuice.FreshJuiceSize.MEDIUM ;
      System.out.println(&quot;玻璃杯大小: &quot; + juice.size);
   &#125;
&#125;
Java
</code></pre>
<p>编译并执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">玻璃杯大小: MEDIUM
Shell
</code></pre>
<blockquote>
<p>注 - 枚举可以单独声明或在类中声明。 方法，变量，构造函数也可以在枚举内定义。</p>
</blockquote>
<h4 id="8-Java关键字"><a href="#8-Java关键字" class="headerlink" title="8. Java关键字"></a>8. Java关键字</h4><p>以下列表中列出了Java中的保留字(关键字)。这些保留字不能用作常量或变量或任何其他标识符名称。</p>
<table>
<thead>
<tr>
<th>abstract</th>
<th>assert</th>
<th>boolean</th>
<th>break</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>case</td>
<td>catch</td>
<td>char</td>
</tr>
<tr>
<td>class</td>
<td>const</td>
<td>continue</td>
<td>default</td>
</tr>
<tr>
<td>do</td>
<td>double</td>
<td>else</td>
<td>enum</td>
</tr>
<tr>
<td>extends</td>
<td>final</td>
<td>finally</td>
<td>float</td>
</tr>
<tr>
<td>for</td>
<td>goto</td>
<td>if</td>
<td>implements</td>
</tr>
<tr>
<td>import</td>
<td>instanceof</td>
<td>int</td>
<td>interface</td>
</tr>
<tr>
<td>long</td>
<td>native</td>
<td>new</td>
<td>package</td>
</tr>
<tr>
<td>private</td>
<td>protected</td>
<td>public</td>
<td>return</td>
</tr>
<tr>
<td>short</td>
<td>static</td>
<td>strictfp</td>
<td>super</td>
</tr>
<tr>
<td>switch</td>
<td>synchronized</td>
<td>this</td>
<td>throw</td>
</tr>
<tr>
<td>throws</td>
<td>transient</td>
<td>try</td>
<td>void</td>
</tr>
<tr>
<td>volatile</td>
<td>while</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="9-注释"><a href="#9-注释" class="headerlink" title="9. 注释"></a>9. 注释</h4><p>Java支持与C和C++非常相似的单行和多行注释。Java编译器会忽略任何注释中可用的所有字符。</p>
<p>示例代码：</p>
<pre><code class="java">public class MyFirstJavaProgram &#123;

   /* This is my first java program.
    * This will print &#39;Hello World&#39; as the output
    * This is an example of multi-line comments.
    */

   public static void main(String []args) &#123;
      // 这是单行注释
      /* 这也是一个单行注释 */
      /* 这是一个
       多行的
       注释 
       */
      System.out.println(&quot;Hello World&quot;);
   &#125;
&#125;
Java
</code></pre>
<h4 id="10-继承"><a href="#10-继承" class="headerlink" title="10. 继承"></a>10. 继承</h4><p>在Java中，类可以从类派生(继承)。 如果需要创建一个新类，并且已经有一个包含需要的代码的类，那么可以直接从这个现有代码派生一个新类。</p>
<p>此概念可重用现有类的字段和方法，而无需在新类中重写代码。 在这种情况下，现有类称为超类，派生类称为子类。</p>
<h4 id="11-接口"><a href="#11-接口" class="headerlink" title="11. 接口"></a>11. 接口</h4><p>在Java语言中，接口可以定义为对象之间如何相互通信的契约。 在涉及继承的概念时，接口起着至关重要的作用。</p>
<p>接口定义一些方法，在派生类(子类)应该使用这些方法。 但是这些方法的实现完全取决于子类。</p>
<h1 id="Java对象和类"><a href="#Java对象和类" class="headerlink" title="Java对象和类"></a>Java对象和类</h1><p>Java是面向对象的语言。 作为具有面向对象功能的语言，Java支持以下基本概念 - </p>
<ul>
<li>多态性</li>
<li>继承</li>
<li>封装</li>
<li>抽象化</li>
<li>类</li>
<li>对象</li>
<li>实例</li>
<li>方法</li>
<li>消息传递</li>
</ul>
<p>在本节中，我们将学习两个概念 - 类和对象。</p>
<ul>
<li><strong>对象</strong> - 对象具有状态和行为。 例如：一只狗的状态有：颜色，名称，品种，它的行为有：摇尾巴，吠叫，吃东西。 对象是类的实例。</li>
<li><strong>类</strong> - 可以将类定义为描述其类型对象支持的行为/状态的模板/蓝图。</li>
</ul>
<h2 id="1-Java对象"><a href="#1-Java对象" class="headerlink" title="1. Java对象"></a>1. Java对象</h2><p>下面将深入了解什么是对象。 如果考虑现实世界，可以在我们周围找到许多对象，如：汽车，狗，人等等。所有这些对象都有状态和行为。</p>
<p>如果考虑一只狗，那么它的状态是 - 名称，品种，颜色，并且它的行为是 - 吠叫，摇尾巴，跑步。</p>
<p>如果将软件对象与实际对象进行比较，则它们具有非常相似的特征。<br>软件对象也具有状态和行为。 软件对象的状态存储在字段中，行为通过方法显示。<br>因此，在软件开发中，方法对对象的内部状态进行操作，并且对象到对象的通信是通过方法完成的。</p>
<h2 id="2-Java类"><a href="#2-Java类" class="headerlink" title="2. Java类"></a>2. Java类</h2><p>类是创建单个对象的蓝图(模板)。以下是一个类的示例代码。</p>
<pre><code class="java">public class Dog &#123;
   String breed;
   int age;
   String color;

   void barking() &#123;
   &#125;

   void hungry() &#123;
   &#125;

   void sleeping() &#123;
   &#125;
&#125;
Java
</code></pre>
<p>类可以包含以下任何变量类型。</p>
<ul>
<li><strong>局部变量</strong> - 在方法，构造函数或块中定义的变量称为局部变量。 变量将在方法中声明和初始化，并且在方法完成时将销毁变量。</li>
<li><strong>实例变量</strong> - 实例变量是类中的变量，但在方法之外。 在实例化类时初始化这些变量。 可以从类的任何方法，构造函数或块内部访问实例变量。</li>
<li><strong>类变量</strong> - 类变量是使用<code>static</code>关键字修饰，它是在类中的方法之外声明的变量。</li>
</ul>
<p>一个类可以有任意数量的方法。 在上面的例子中，<code>barking()</code>，<code>hungry()</code>和<code>sleeping()</code>都是类的方法。</p>
<p>以下是在学习Java语言类和对象时，需要了解的一些重要主题内容。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>在讨论类时，最重要的子主题之一是构造函数。 每个类都有一个构造函数。 如果没有为类显式编写构造函数，Java编译器会自动为该类构建一个默认构造函数。</p>
<p>每次创建新对象时，都将至少调用一个构造函数。构造函数的主要规则是它与类具有相同的名称。 一个类可以有多个构造函数。</p>
<p>以下是构造函数的示例 - </p>
<pre><code class="java">public class Dog &#123;
   // 无参数构造函数
   public Dog() &#123;
   &#125;
   // 有参数构造函数
   public Dog(String name) &#123;
      // 此构造函数有一个参数：name。
   &#125;
&#125;
Java
</code></pre>
<p>Java还支持<a target="_blank" rel="noopener" href="http://www.yiibai.com/design_pattern/singleton_pattern.html">单实例类</a>，它是一种创建一个类只有一个实例设计模式。</p>
<blockquote>
<p>注意 - 有两种不同类型的构造函数。 我们将在后续章节中详细讨论构造函数。</p>
</blockquote>
<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>如前所述，类提供了对象的蓝图。一个对象是从一个类创建的。 在Java中，<code>new</code>关键字用于创建新对象。</p>
<p>从类创建对象时有三个步骤 - </p>
<ul>
<li>声明 - 具有变量名称和对象类型的变量声明。</li>
<li>实例化 - <code>new</code>关键字用于创建对象。</li>
<li>初始化 - <code>new</code>关键字后跟对构造函数的调用，此调用初始化新对象。</li>
</ul>
<p>以下是创建对象的示例代码 - </p>
<pre><code class="java">public class Dog &#123;
   public Dog(String name) &#123;
      // 这个构造函数有一个参数：anem
      System.out.println(&quot;传入的参数值是: &quot; + name );
   &#125;

   public static void main(String []args) &#123;
      // 以下语句将创建一个对象: myDog
      Dog myDog = new Dog( &quot;小屁狗&quot; );
   &#125;
&#125;
Java
</code></pre>
<p>编译并执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">传入的参数值是: 小屁狗
Shell
</code></pre>
<h4 id="访问实例变量和方法"><a href="#访问实例变量和方法" class="headerlink" title="访问实例变量和方法"></a>访问实例变量和方法</h4><p>通过创建的对象访问实例变量和方法。 要访问实例变量，以下是完全限定的路径 - </p>
<pre><code class="java">/* 首先创建一个对象 */
ObjectReference = new Constructor();

/* 调用变量如下 */
ObjectReference.variableName;

/* 现在，可以按如下方式调用类方法 */
ObjectReference.MethodName();
Java
</code></pre>
<p>下面示例说明如何访问类的实例变量和方法。</p>
<pre><code class="java">public class Dog &#123;
    int dogAge;

    public Dog(String name) &#123;
        // 此构造函数有一个参数：name
        System.out.println(&quot;设置的小狗名字是: &quot; + name);
    &#125;

    public void setAge(int age) &#123;
        dogAge = age;
    &#125;

    public int getAge() &#123;
        System.out.println(&quot;小狗的年龄是: &quot; + dogAge);
        return dogAge;
    &#125;

    public static void main(String[] args) &#123;
        /* 创建对象 */
        Dog myDog = new Dog(&quot;小屁狗&quot;);

        /* 调用方法来设置狗的年龄 */
        myDog.setAge(2);

        /* 调用另一个方法来获取狗的年龄 */
        myDog.getAge();

        /* 也可以按如下方式访问实例变量：dogAge */
        System.out.println(&quot;变量的值是:&quot; + myDog.dogAge);
    &#125;
&#125;
Java
</code></pre>
<p>编译并执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">设置的小狗名字是: 小屁狗
小狗的年龄是: 2
变量的值是:2
Shell
</code></pre>
<h4 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h4><p>在源文件中声明类，<code>import</code>语句和<code>package</code>语句时，这些规则是必不可少的。</p>
<ul>
<li>每个源文件只能有一个<code>public</code>类。</li>
<li>源文件可以有多个非<code>public</code>类。</li>
<li><code>public</code>类名称也应该是源文件的名称，最后以<code>.java</code>作为扩展名。 例如：类名是<code>public class Employee&#123;&#125;</code>，那么源文件应该是：<code>Employee.java</code>。</li>
<li>如果在包内定义了类，则<code>package</code>语句应该是源文件中的第一个语句。</li>
<li>如果存在<code>import</code>语句，则必须在<code>package</code>语句和类声明之间写入它们。如果没有<code>package</code>语句，则<code>import</code>语句应该是源文件中的第一行。</li>
</ul>
<p>类具有多个访问级别，并且有不同类型的类; 抽象类，<code>final</code>类等。我们将在访问修饰符章节中解释所有这些。</p>
<p>除了上面提到的类类型之外，Java还有一些特殊类：内部类和匿名类。</p>
<h4 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h4><p>简而言之，它是一种对类和接口进行分类的方法。 在Java中开发应用程序时，将编写数百个类和接口，因此必须对这些类进行分类，以使生活变得更加容易。Java包也是用于解决命名冲突的问题。</p>
<h4 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h4><p>在Java中，如果给出了包含包和类名的完全限定名称，则编译器可以快速地找到源代码或类。 <code>import</code>语句是一种为编译器提供正确位置以查找特定类的方法。</p>
<p>例如，以下行将要求编译器加载目录<code>java_installation/java /io</code>中可用的所有类 - </p>
<pre><code class="java">import java.io.*;
Java
</code></pre>
<h2 id="3-一个简单学习案例"><a href="#3-一个简单学习案例" class="headerlink" title="3. 一个简单学习案例"></a>3. 一个简单学习案例</h2><p>在这个学习案例中，将创建两个类。 它们是：<code>Employee</code>和<code>EmployeeTest</code>。</p>
<p>首先打开记事本并添加以下代码。<code>Employee</code>类是公共(<code>public</code>)类。因此使用文件名称为：<em>Employee.java</em> 保存此源文件。</p>
<p><code>Employee</code>类有四个实例变量 - <code>name</code>, <code>age</code>, <code>designation</code> 和 <code>salary</code>。 该类有一个显式定义的构造函数，它接受一个参数。</p>
<pre><code class="java">import java.io.*;

public class Employee &#123;

    String name;
    int age;
    String jobPosition;
    double salary;

    // 这是Employee类的构造函数
    public Employee(String name) &#123;
        this.name = name;
    &#125;

    // 设置员工的年龄，将empAge的分配给变量：age。
    public void empAge(int empAge) &#123;
        age = empAge;
    &#125;

    /* 设置员工的工作岗位. */
    public void setJobPosition(String jobPosit) &#123;
        jobPosition = jobPosit;
    &#125;

    /* 设置员工的薪水，将empSalary的分配给变量：salary。 */
    public void empSalary(double empSalary) &#123;
        salary = empSalary;
    &#125;

    /* 打印员工详细信息 */
    public void printEmployee() &#123;
        System.out.println(&quot;------------------------------------&quot;);
        System.out.println(&quot;姓名:&quot; + name);
        System.out.println(&quot;年龄:&quot; + age);
        System.out.println(&quot;工作岗位:&quot; + jobPosition);
        System.out.println(&quot;薪水:&quot; + salary);
    &#125;
&#125;
Java
</code></pre>
<p>如本教程前面所述，程序从<code>main</code>方法开始执行。 因此，要运行这个<code>Employee</code>类，应该有一个<code>main</code>方法，并且应该创建对象。接下来将为这些任务创建一个单独的类：<code>EmployeeTest</code>。</p>
<p>在<code>EmployeeTes</code>t类中，它创建<code>Employee</code>类的两个实例，并为每个对象调用方法以为每个变量赋值。将以下代码保存在<em>EmployeeTest.java</em> 文件中。</p>
<pre><code class="java">import java.io.*;
public class EmployeeTest &#123;

   public static void main(String args[]) &#123;
      /* 使用构造函数创建两个对象 */
      Employee empOne = new Employee(&quot;Maxsu&quot;);
      Employee empTwo = new Employee(&quot;张小龙&quot;);

      // 为每个创建的对象调用方法
      empOne.empAge(26);
      empOne.setJobPosition(&quot;高级软件工程师&quot;);
      empOne.empSalary(15999);
      empOne.printEmployee();

      empTwo.empAge(42);
      empTwo.setJobPosition(&quot;产品经理&quot;);
      empTwo.empSalary(999999);
      empTwo.printEmployee();
   &#125;
&#125;
Java
</code></pre>
<p>现在，编译这两个类，然后运行得到结果如下 - </p>
<pre><code class="shell">D:/worksp/java&gt; javac Employee.java
D:/worksp/java&gt; javac EmployeeTest.java
D:/worksp/java&gt; java EmployeeTest
------------------------------------
姓名:Maxsu
年龄:26
工作岗位:高级软件工程师
薪水:15999.0
------------------------------------
姓名:张小龙
年龄:42
工作岗位:产品经理
薪水:999999.0
</code></pre>
<h1 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h1><p>变量是用于存储值的保留内存位置。当创建变量时，它会在内存中保留一些空间。</p>
<p>根据变量的数据类型，操作系统分配内存并决定可以存储在保留内存中的内容。 因此，通过为变量分配不同的数据类型，可以在这些变量中存储整数，小数或字符。</p>
<p>Java中有两种数据类型 - </p>
<ul>
<li>原始数据类型</li>
<li>引用/对象数据类型</li>
</ul>
<h2 id="1-原始数据类型"><a href="#1-原始数据类型" class="headerlink" title="1. 原始数据类型"></a>1. 原始数据类型</h2><p>Java支持八种原始数据类型。 原始数据类型由语言预定义，并由关键字命名。下面来详细了解和学习这八种原始数据类型。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>值范围</th>
<th>默认值</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>表示<code>8</code>位有符号二进制补码整数</td>
<td><code>-128 (-2^7)</code> - <code>127 (2^7 -1)</code></td>
<td><code>0</code></td>
<td><code>byte a = 100, byte b = -50</code></td>
</tr>
<tr>
<td>short</td>
<td>表示<code>16</code>位有符号二进制补码整数</td>
<td><code>-2^15</code>-<code>2^15 -1</code></td>
<td><code>0</code></td>
<td><code>short s = 10000, short r = -20000</code></td>
</tr>
<tr>
<td>int</td>
<td>表示<code>32</code>位有符号二进制补码整数</td>
<td><code>-2^31</code>-<code>2^31 -1</code></td>
<td><code>0</code></td>
<td><code>int a = 100000, int b = -200000</code></td>
</tr>
<tr>
<td>long</td>
<td>表示<code>64</code>位带符号的二进制补码整数</td>
<td><code>-2^63</code>-<code>2^63 -1</code></td>
<td><code>0L</code></td>
<td><code>long a = 100000L, long b = -200000L</code></td>
</tr>
<tr>
<td>float</td>
<td>表示单精度<code>32</code>位IEEE 754浮点数</td>
<td>-</td>
<td><code>0.0f</code></td>
<td><code>float f1 = 234.5f</code></td>
</tr>
<tr>
<td>double</td>
<td>表示双精度<code>64</code>位IEEE 754浮点数</td>
<td>-</td>
<td><code>0.0d</code></td>
<td><code>double d1 = 123.4</code></td>
</tr>
<tr>
<td>boolean</td>
<td>表示一个比特位的信息</td>
<td><code>true</code>/<code>false</code></td>
<td><code>false</code></td>
<td><code>boolean one = true</code></td>
</tr>
<tr>
<td>char</td>
<td>表示单个16位Unicode字符</td>
<td><code>\u0000</code>-<code>\uffff</code></td>
<td>-</td>
<td><code>char letterA = &#39;A&#39;</code></td>
</tr>
</tbody></table>
<h2 id="2-引用数据类型"><a href="#2-引用数据类型" class="headerlink" title="2. 引用数据类型"></a>2. 引用数据类型</h2><ul>
<li>使用类中已定义构造函数创建引用变量。 它们用于访问对象。 声明这些变量属于无法更改的特定类型。 例如，<code>Employee</code>，<code>Dog</code>类等。</li>
<li>类对象和各种类型的数组变量属于引用数据类型。</li>
<li>任何引用变量的默认值为<code>null</code>。</li>
<li>引用变量可用于引用声明类型的任何对象或任何兼容类型。</li>
<li>示例：<code>Dog dog = new Dog(&quot;小屁狗&quot;);</code></li>
</ul>
<h2 id="3-Java文字"><a href="#3-Java文字" class="headerlink" title="3. Java文字"></a>3. Java文字</h2><p>文字是固定值的源代码表示。它们直接在代码中表示，无需任何计算。可以将文字分配给任何基本类型变量。 例如 - </p>
<pre><code class="java">byte a = 68;
char a = &#39;A&#39;;
Java
</code></pre>
<p><code>byte</code>，<code>int</code>，<code>long</code>和<code>short</code>也可以用十进制(基数为<code>10</code>)，十六进制(基数<code>16</code>)或八进制(基数<code>8</code>)数字表示。</p>
<p>前缀<code>0</code>用于表示八进制，前缀<code>0x</code>表示使用这些数字系统进行文字时的十六进制。 例如 - </p>
<pre><code class="java">int decimal = 100;
int octal = 0144;
int hexa =  0x64;
Java
</code></pre>
<p>Java中的字符串文字通过在一对双引号之间包含一系列字符来指定，就像它们在大多数其他编程语言中一样。 字符串文字的例子是 - </p>
<pre><code class="java">&quot;Hello World&quot;
&quot;two\nlines&quot;
&quot;&quot;This is in quotes&quot;&quot;
Java
</code></pre>
<p>字符串和字符类型的文字可以包含任何Unicode字符。 例如 - </p>
<pre><code class="java">char a = &#39;\u0001&#39;;
String a = &quot;\u0001&quot;;
Java
</code></pre>
<p>Java语言也支持<code>String</code>和<code>char</code>文字的几个特殊转义序列。它们是 -</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>代表的字符</th>
</tr>
</thead>
<tbody><tr>
<td><code>\n</code></td>
<td>换行符(0x0a)</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车(0x0d)</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>换页(0x0c)</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>退格(0x08)</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>空格(0x20)</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>制表符</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>双引号</td>
</tr>
<tr>
<td><code>\&#39;</code></td>
<td>单引号</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>反斜线</td>
</tr>
<tr>
<td><code>\ddd</code></td>
<td>八进制字符(ddd)</td>
</tr>
<tr>
<td><code>\uxxxx</code></td>
<td>十六进制UNICODE字符(xxxx)</td>
</tr>
</tbody></table>
<h1 id="Java变量类型"><a href="#Java变量类型" class="headerlink" title="Java变量类型"></a>Java变量类型</h1><p>变量提供了程序可以操作的命名存储。 Java中的每个变量都有一个类型，它决定了变量内存的大小和布局; 可以存储在该存储器中的值的范围; 以及可以应用于变量的操作集。</p>
<p>变量需要先声明才能使用，以下是变量声明的基本形式 - </p>
<pre><code class="java">data type variable [ = value][, variable [ = value] ...] ;
Java
</code></pre>
<p>这里<code>data type</code>是Java的数据类型之一，<code>variable</code>是变量的名称。要声明具有相同类型的多个变量，可以使用逗号分隔列表。</p>
<p>以下是Java中变量声明和初始化的示例 - </p>
<pre><code class="java">int a, b, c;         // 声明三个int类型变量：a, b 和 c
int a = 10, b = 10;  // 初始化它们的值
byte B = 22;         // 声明并初始化一个 byte 类型的变量：B
double pi = 3.14159; // 声明并赋值一个 double 类型的变量：PI
char a = &#39;a&#39;;        // 声明char类型变量 a，并初始化值为：&#39;a&#39;
Java
</code></pre>
<p>本章将解释Java语言中的各种变量类型。Java中有三种变量 - </p>
<ul>
<li>局部变量</li>
<li>实例变量</li>
<li>类/静态变量</li>
</ul>
<h2 id="1-局部变量"><a href="#1-局部变量" class="headerlink" title="1. 局部变量"></a>1. 局部变量</h2><ul>
<li>局部变量一般在方法，构造函数或块中声明。</li>
<li>程序进入方法，构造函数或块时会创建局部变量，并且一旦退出方法，构造函数或块，变量就会销毁。</li>
<li>访问修饰符不能用于局部变量。</li>
<li>局部变量仅在声明的方法，构造函数或块中可见。</li>
<li>局部变量在内部实现堆栈级别。</li>
<li>局部变量没有默认值，因此应声明局部变量后，在第一次使用之前为它分配初始值。</li>
</ul>
<p><strong>示例</strong></p>
<p>在这里，<code>age</code>是一个局部变量。 这是在<code>dogAge()</code>方法中定义的，它的范围仅限于此方法。</p>
<pre><code class="java">public class Test &#123;
   public void dogAge() &#123;
      int age = 0;
      age = age + 5;
      System.out.println(&quot;Dog age is : &quot; + age);
   &#125;

   public static void main(String args[]) &#123;
      Test test = new Test();
      test.dogAge();
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">Dog age is : 5
Shell
</code></pre>
<p><strong>示例</strong></p>
<p>下面示例中使用变量 <code>age</code> ，但不初始化它，因此在编译时会出错。</p>
<pre><code class="java">public class Test &#123;
   public void dogAge() &#123;
      int age;
      age = age + 5;
      System.out.println(&quot;Dog age is : &quot; + age);
   &#125;

   public static void main(String args[]) &#123;
      Test test = new Test();
      test.dogAge();
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果(出错)：</p>
<pre><code class="shell">Test.java:4:variable number might not have been initialized
age = age + 5;
         ^
1 error
Shell
</code></pre>
<h2 id="2-实例变量"><a href="#2-实例变量" class="headerlink" title="2. 实例变量"></a>2. 实例变量</h2><ul>
<li>实例变量在类中声明，但在方法，构造函数或块之外。</li>
<li>为堆中的对象分配空间时，将为每个实例变量值创建一个槽。</li>
<li>使用关键字<code>new</code>创建对象时会创建实例变量，并在销毁对象时销毁实例变量。</li>
<li>实例变量包含由多个方法，构造函数或块引用的值，或者在整个类中存在的对象状态的基本部分。</li>
<li>实例变量可以在使用之前或之后在类级别中声明。</li>
<li>可以为实例变量给出访问修饰符。</li>
<li>实例变量对于类中的所有方法，构造函数和块都是可见的。 通常，建议将这些变量设为私有(访问级别)。 但是，可以使用访问修饰符为这些变量提供子类的可见性。</li>
<li>实例变量具有默认值。 对于数字，默认值为<code>0</code>，对于布尔值，它为<code>false</code>，对于对象引用，它为<code>null</code>。 可以在声明期间或构造函数中指定值。</li>
<li>可以通过调用类中的变量名来直接访问实例变量。 但是，在静态方法中(当实例变量具有可访问性时)，应使用完全限定名称调用它们，如：<code>ObjectReference.VariableName</code>。</li>
</ul>
<p><strong>示例代码</strong></p>
<pre><code class="java">import java.io.*;
public class Employee &#123;

   // 此实例变量对于子类都是可见的。
   public String name;

   // salary 变量仅在Employee类中可见。
   private double salary;

   // name变量在构造函数中指定。
   public Employee (String empName) &#123;
      name = empName;
   &#125;

   // 为 salary 变量赋值
   public void setSalary(double empSal) &#123;
      salary = empSal;
   &#125;

   // 此方法打印员工详细信息。
   public void printEmp() &#123;
      System.out.println(&quot;name  : &quot; + name );
      System.out.println(&quot;salary :&quot; + salary);
   &#125;

   public static void main(String args[]) &#123;
      Employee empOne = new Employee(&quot;Maxsu&quot;);
      empOne.setSalary(15999);
      empOne.printEmp();
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">name  : Maxsu
salary :15999.0
Shell
</code></pre>
<h2 id="3-类-静态变量"><a href="#3-类-静态变量" class="headerlink" title="3. 类/静态变量"></a>3. 类/静态变量</h2><ul>
<li>类变量(也称为静态变量)在类中使用<code>static</code>关键字声明，但在方法，构造函数或块之外。</li>
<li>每个类只有一个每个类变量的副本，无论从中创建多少个对象。</li>
<li>除了声明为常量之外，很少使用静态变量。常量是声明为<code>public/private</code>，<code>final</code>和<code>static</code>的变量。常量的初始值不能更改。</li>
<li>静态变量存储在静态存储器中。 除了声明的<code>final</code>之外，很少使用静态变量，并将其用作公共或私有常量。</li>
<li>程序启动时会创建静态变量，程序停止时会销毁静态变量。</li>
<li>可见性类似于实例变量。 但是，大多数静态变量都是公共的，因为它们必须可供该类用户使用。</li>
<li>默认值与实例变量相同。 对于数字，默认值为<code>0</code>; 对于布尔类型来说，默认值为<code>false</code>; 对于对象引用，默认值为<code>null</code>。 可以在声明期间或构造函数中指定值。 此外，可以在特殊的静态初始化程序块中分配值。</li>
<li>可以通过使用类名<code>ClassName.VariableName</code>调用来访问静态变量。</li>
<li>将类变量声明为<code>public static final</code>时，变量名(常量)都是大写的。 如果静态变量不是<code>public</code>和<code>final</code>，则命名语法与实例和局部变量命名规则相同。</li>
</ul>
<p><strong>示例</strong></p>
<pre><code class="java">import java.io.*;
public class Employee &#123;

   // salary变量是一个私有静态变量
   private static double salary;

   // DEPARTMENT是一个常量
   public static final String DEPARTMENT = &quot;研发部&quot;;

   public static void main(String args[]) &#123;
      salary = 19999;
      System.out.println(DEPARTMENT + &quot;平均薪水:&quot; + salary);
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果 - </p>
<pre><code class="shell">研发部平均薪水:19999
Shell
</code></pre>
<blockquote>
<p>注 - 如果从外部类访问变量，则应作为：<code>Employee.DEPARTMENT</code>。</p>
</blockquote>
<h1 id="Java修饰符类型"><a href="#Java修饰符类型" class="headerlink" title="Java修饰符类型"></a>Java修饰符类型</h1><p>修饰符是一种添加到定义以更改其含义的关键字。Java语言有各种各样的修饰符，包括以下两种 - </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_access_modifiers.html">Java访问修饰符</a> - 例如：<code>private</code>,<code>protected</code>,<code>public</code>等。</li>
<li><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_nonaccess_modifiers.html">Java非访问修饰符</a> - 例如：<code>static</code>,<code>final</code>等。</li>
</ul>
<p>要使用修饰符，请在类，方法或变量的定义中包含修饰符关键字。 修饰符位于语句之前，如下例所示 -</p>
<pre><code class="java">public class className &#123;
   // ...
&#125;

private boolean myFlag;
static final double weeks = 9.5;
protected static final int BOXWIDTH = 42;

public static void main(String[] arguments) &#123;
   // body of method
&#125;
Java
</code></pre>
<h2 id="1-访问控制修饰符"><a href="#1-访问控制修饰符" class="headerlink" title="1. 访问控制修饰符"></a>1. 访问控制修饰符</h2><p>Java提供了许多访问修饰符来设置类，变量，方法和构造函数的访问级别。 四个访问级别是 - </p>
<ul>
<li>对包可见(<code>default</code>)，不需要修饰符。</li>
<li>仅对类可见(<code>prive</code>)。</li>
<li>对所有可见(<code>public</code>)。</li>
<li>对包和所有子类可见(<code>protected</code>)。</li>
</ul>
<h2 id="2-非访问修饰符"><a href="#2-非访问修饰符" class="headerlink" title="2. 非访问修饰符"></a>2. 非访问修饰符</h2><p>Java提供了许多非访问修饰符来实现许多其他功能。</p>
<ul>
<li>用于创建类方法和变量的<code>static</code>修饰符。</li>
<li>用于完成类，方法和变量的实现的<code>final</code>修饰符。</li>
<li>用于创建抽象类和方法的<code>abstract</code>修饰符。</li>
<li><code>synchronized</code>和<code>volatile</code>修饰符，用于线程。</li>
</ul>
<h1 id="Java非访问修饰符"><a href="#Java非访问修饰符" class="headerlink" title="Java非访问修饰符"></a>Java非访问修饰符</h1><p>Java提供了许多非访问修饰符来实现许多其他功能。</p>
<ul>
<li><code>static</code>修饰符用于创建类方法和变量。</li>
<li><code>final</code>修饰符用于完成类，方法和变量的实现。</li>
<li><code>abstract</code>修饰符用于创建抽象类和方法。</li>
<li><code>synchronized</code>和<code>volatile</code>修饰符，用于线程。</li>
</ul>
<p>下面来逐个了解和学习这些非访问修饰符。</p>
<h4 id="1-static修饰符"><a href="#1-static修饰符" class="headerlink" title="1. static修饰符"></a>1. static修饰符</h4><p><strong>1.1. 静态变量</strong></p>
<p><code>static</code>关键字用于创建独立于类实例的变量。无论类的实例数有多少个，都只存在一个静态变量副本。静态变量也称为类变量。局部变量不能声明为<code>static</code>。</p>
<p><strong>1.2. 静态方法</strong></p>
<p><code>static</code>关键字用于创建独立于类实例的方法。<br>静态方法不能使用作为类的对象的实例变量，静态方法也叫作类方法。静态方法从参数中获取所有数据并从这些参数计算某些内容，而不引用变量。可以使用类名后跟一个点(<code>.</code>)以及变量或方法的名称来访问类变量或方法。</p>
<p><strong>示例</strong></p>
<ul>
<li><code>static</code>修饰符用于创建类方法和变量，如下例所示 - </li>
</ul>
<pre><code class="java">public class InstanceCounter &#123;

   private static int numInstances = 0;

   protected static int getCount() &#123;
      return numInstances;
   &#125;

   private static void addInstance() &#123;
      numInstances++;
   &#125;

   InstanceCounter() &#123;
      InstanceCounter.addInstance();
   &#125;

   public static void main(String[] arguments) &#123;
      System.out.println(&quot;Starting with &quot; + InstanceCounter.getCount() + &quot; instances&quot;);

      for (int i = 0; i &lt; 500; ++i) &#123;
         new InstanceCounter();
      &#125;
      System.out.println(&quot;Created &quot; + InstanceCounter.getCount() + &quot; instances&quot;);
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">Started with 0 instances
Created 500 instances
Shell
</code></pre>
<h4 id="2-final修饰符"><a href="#2-final修饰符" class="headerlink" title="2. final修饰符"></a>2. final修饰符</h4><p><strong>2.1. final变量</strong></p>
<p>final变量只能显式地初始化一次，声明为<code>final</code>的引用变量永远不能重新分配以引用不同的对象。但是，可以更改对象内的数据。 因此，可以更改对象的状态，但不能更改引用。<br>对于变量，<code>final</code>修饰符通常与<code>static</code>一起使用，以使常量成为类变量。</p>
<p><strong>示例</strong></p>
<pre><code class="java">public class Test &#123;
   final int value = 10;

   // 以下是声明常量的示例：
   public static final int BOXWIDTH = 6;
   static final String TITLE = &quot;Manager&quot;;

   public void changeValue() &#123;
      value = 12;   // 会出错，不能重新赋值
   &#125;
&#125;
Java
</code></pre>
<p><strong>2.2. final方法</strong></p>
<p>任何子类都不能覆盖<code>final</code>方法。 如前所述，<code>final</code>修饰符可防止在子类中修改方法。</p>
<p>声明<code>final</code>方法的主要目的是不让其它人改变方法的内容。</p>
<p><strong>示例</strong><br>可以在类声明中使用<code>final</code>修饰符声明方法，如下例所示 - </p>
<pre><code class="java">public class Test &#123;
   public final void changeName() &#123;
      // 方法主体
   &#125;
&#125;
Java
</code></pre>
<p><strong>2.3. final类</strong></p>
<p>使用声明为<code>final</code>的类的主要目的是防止类被子类化。 如果一个类被标记为<code>final</code>，那么这个类不能被其它类继承。</p>
<p><strong>示例</strong></p>
<pre><code class="java">public final class Test &#123;
   // body of class
&#125;
Java
</code></pre>
<h4 id="3-abstract饰符"><a href="#3-abstract饰符" class="headerlink" title="3. abstract饰符"></a>3. abstract饰符</h4><p><strong>3.1. 抽象类</strong></p>
<p>抽象(<code>abstract</code>)类不能实例化。如果一个类声明为抽象(<code>abstract</code>)，那么唯一的目的是扩展该类。</p>
<p>一个类不能是同时是<code>abstract</code>和<code>final</code>(因为<code>final</code>类不能被扩展)。 如果一个类包含抽象方法，那么该类应该被声明为<code>abstract</code>。 否则，将抛出编译错误。</p>
<p>抽象类可以包含抽象方法以及普通方法。</p>
<p><strong>示例</strong></p>
<pre><code class="java">abstract class Caravan &#123;
   private double price;
   private String model;
   private String year;
   public void getYear(String y)&#123;&#125;；// 这是一个普通方法
   public abstract void goFast();   // 这是一个抽象方法
   public abstract void changeColor();// 这是一个抽象方法
&#125;
Java
</code></pre>
<p><strong>3.2. 抽象方法</strong><br>抽象方法是在没有任何实现的情况下声明的方法。 方法体(实现)由子类提供。 抽象方法永远不会是最终的或严格的。</p>
<p>扩展抽象类的任何类都必须实现超类的所有抽象方法，除非子类也是抽象类。</p>
<p>如果一个类包含一个或多个抽象方法，那么该类必须声明为abstract。 抽象类不需要包含抽象方法。</p>
<p>抽象方法以分号结尾。 示例：public abstract sample();</p>
<p><strong>示例</strong></p>
<pre><code class="java">public abstract class SuperClass &#123;
   abstract void m();   // 抽象方法
&#125;

class SubClass extends SuperClass &#123;
   // 实现抽象方法
   void m() &#123;
      // 实现代码.........
   &#125;
&#125;
Java
</code></pre>
<h3 id="4-synchronized修饰符"><a href="#4-synchronized修饰符" class="headerlink" title="4. synchronized修饰符"></a>4. synchronized修饰符</h3><p><code>synchronized</code>关键字用于指示一次只能访问一个方法的方法。<code>synchronized</code>修饰符可以应用于四个访问级别修饰符中的任何一个。</p>
<p><strong>示例</strong></p>
<pre><code class="java">public synchronized void showDetails() &#123;
   .......
&#125;
Java
</code></pre>
<h4 id="5-transient修饰符"><a href="#5-transient修饰符" class="headerlink" title="5. transient修饰符"></a>5. transient修饰符</h4><p>实例变量标记为<code>transient</code>，表示JVM在序列化包含它的对象时跳过特定变量。</p>
<p>此修饰符包含在创建变量的语句中，位于变量的类或数据类型之前。</p>
<p><strong>示例</strong></p>
<pre><code class="java">public transient int limit = 55;   // will not persist
public int b;   // will persist
Java
</code></pre>
<h4 id="6-volatile修饰符"><a href="#6-volatile修饰符" class="headerlink" title="6. volatile修饰符"></a>6. volatile修饰符</h4><p><code>volatile</code>修饰符用于让JVM知道访问变量的线程必须始终将其自己的变量私有副本与内存中的主副本合并。</p>
<p>访问<code>volatile</code>变量会同步主内存中变量的所有缓存复制。 <code>volatile</code>只能应用于实例变量，类型为<code>private</code>。 <code>volatile</code>对象引用可以为<code>null</code>。</p>
<p><strong>示例</strong></p>
<pre><code class="java">public class MyRunnable implements Runnable &#123;
   private volatile boolean active;

   public void run() &#123;
      active = true;
      while (active) &#123;   // line 1
         // some code here
      &#125;
   &#125;

   public void stop() &#123;
      active = false;   // line 2
   &#125;
&#125;
Java
</code></pre>
<p>通常，在一个线程(使用<code>Runnable</code>开始的线程)中调用<code>run()</code>，并从另一个线程调用<code>stop()</code>。 如果在第<code>1</code>行中使用了<code>active</code>的缓存值，那么当在第<code>2</code>行中将<code>active</code>设置为<code>false</code>时，循环可能不会停止。</p>
<h1 id="Java基本运算符"><a href="#Java基本运算符" class="headerlink" title="Java基本运算符"></a>Java基本运算符</h1><p>Java提供了一组丰富的操作符来操作变量。 我们可以将所有Java运算符划分为以下几个分类 - </p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>按位运算符</li>
<li>逻辑运算符</li>
<li>赋值运算符</li>
<li>其他运算符</li>
</ul>
<h2 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h2><p>算术运算符在数学表达式中的使用方式与在代数中使用的方式相同。下表列出了算术运算符的使用示例 - </p>
<p>假设整数类型变量<code>A</code>的值为：<code>10</code>，变量<code>B</code>的值为：<code>20</code>，则 - </p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加法运算符,第一个操作数加上第二个数操作数</td>
<td><code>A + B</code>结果为：<code>30</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>减法运算符,从第一个操作数减去第二个操作数</td>
<td><code>A - B</code>结果为：<code>-10</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>两个操作数相乘</td>
<td><code>A * B</code>结果为：<code>200</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td>左操作数除以右操作数返回模值</td>
<td><code>B / A</code>结果为：<code>2</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td>左操作数除以右操作数返回余数</td>
<td><code>B / A</code>结果为：<code>0</code></td>
</tr>
<tr>
<td><code>++</code></td>
<td>将操作数的值增加<code>1</code></td>
<td><code>A++</code>，则<code>A</code>的值为：<code>11</code></td>
</tr>
<tr>
<td><code>--</code></td>
<td>将操作数的值减<code>1</code></td>
<td><code>A--</code>，则<code>A</code>的值为：<code>9</code></td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_arithmatic_operators_examples.html">算术运算符示例代码</a></p>
<h2 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2. 关系运算符"></a>2. 关系运算符</h2><p>Java语言支持以下关系运算符。假设变量<code>A</code>的值是<code>10</code>，变量<code>B</code>的值是<code>20</code>，则 - </p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>==</code></td>
<td>等于运算符，检查两个操作数的值是否相等，如果相等，则条件变为真。</td>
<td><code>A==B</code>结果为假。</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于运算符，检查两个操作数的值是否不相等，如果不相等，则条件变为真。</td>
<td><code>A!=B</code>结果为真。</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于运算符，检查左操作数的值是否大于右操作数的值，如果大于，则条件变为真。</td>
<td><code>A&gt;B</code>结果为假。</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于运算符，检查左操作数的值是否小于右操作数的值，如果小于，则条件变为真。</td>
<td><code>A&lt;B</code>结果为真。</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于或等于运算符，检查左操作数的值是否大于等于右操作数的值，如果大于或等于，则条件变为真。</td>
<td><code>A&gt;=B</code>结果为假。</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于或等于运算符，检查左操作数的值是否小于或等于右操作数的值，如果小于或等于，则条件变为真。</td>
<td><code>A&lt;=B</code>结果为真。</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_relational_operators_examples.html">关系运算符示例代码</a></p>
<h2 id="3-按位运算符"><a href="#3-按位运算符" class="headerlink" title="3. 按位运算符"></a>3. 按位运算符</h2><p>Java定义了几个按位运算符，可以应用于整数类型， 如：<code>long</code>，<code>int</code>，<code>short</code>，<code>char</code>和<code>byte</code>。按位运算符处理位并执行逐位运算。 假设<code>a = 60</code>且<code>b = 13</code>; 采用二进制格式，它们将如下 - </p>
<pre><code>a = 0011 1100

b = 0000 1101

-----------------

a&amp;b = 0000 1100

a|b = 0011 1101

a^b = 0011 0001

~a  = 1100 0011
</code></pre>
<p>下面的表中列出了按位运算符，假设整数变量<code>A=60</code>，变量<code>B=13</code>，那么 - </p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td>二进制AND运算符，如果存在于两个操作数中，则它会将结果复制到结果中。</td>
<td><code>A &amp; B</code>的结果为：<code>12</code>，也就是：<code>0000 1100</code></td>
</tr>
<tr>
<td>Ι</td>
<td>二进制OR运算符，如果存在于任一操作数中，则复制一位。</td>
<td>A Ι B 的结果为：<code>61</code>，也就是：<code>0011 1101</code></td>
</tr>
<tr>
<td><code>^</code></td>
<td>二进制异或运算符，如果在一个操作数中设置但不在两个操作数中设置，则复制该位。</td>
<td><code>A ^ B</code>的结果为：<code>49</code>，也就是：<code>0011 0001</code></td>
</tr>
<tr>
<td><code>~</code></td>
<td>二元一元补充运算符是一元的，具有“翻转”位的效果。</td>
<td><code>~A</code>的结果为：<code>-61</code>，也就是：<code>1100 0011</code></td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>二进制左移运算符，左操作数值向左移动右操作数指定的位数。</td>
<td><code>A &lt;&lt; 2</code>的结果为：<code>240</code>，也就是：<code>1111 0000</code></td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>二进制右移运算符，左操作数值向右移动右操作数指定的位数。</td>
<td><code>A &gt;&gt; 2</code>的结果为：<code>15</code>，也就是：<code>1111</code></td>
</tr>
<tr>
<td><code>&gt;&gt;&gt;</code></td>
<td>右移零填充运算符。 左操作数值向右移动右操作数指定的位数，移位值用零填充。</td>
<td><code>A &gt;&gt;&gt;2</code>的结果为：<code>15</code>，也就是：<code>0000 1111</code></td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_bitwise_operators_examples.html">按位运算符示例代码</a></p>
<h2 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4. 逻辑运算符"></a>4. 逻辑运算符</h2><p>下表列出了逻辑运算符 - </p>
<p>假设布尔变量<code>A</code>的值为：<code>true</code>，变量<code>B</code> 的值为：<code>false</code>，则 - </p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑AND运算符。 如果两个操作数都不为零，则条件成立。</td>
<td><code>(A &amp;&amp; B)</code>结果为：<code>false</code></td>
</tr>
<tr>
<td>ΙΙ</td>
<td>逻辑OR运算符。 如果两个操作数中的任何一个非零，则条件变为真。</td>
<td>(A ΙΙ B)结果为：<code>true</code></td>
</tr>
<tr>
<td><code>!</code></td>
<td>逻辑非运算符。用于反转其操作数的逻辑状态。 如果条件为真，则口逻辑NOT运算符将为<code>false</code>。</td>
<td><code>!(A &amp;&amp; B)</code>结果为：<code>true</code></td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_logical_operators_examples.html">逻辑运算符示例代码</a></p>
<h2 id="5-赋值运算符"><a href="#5-赋值运算符" class="headerlink" title="5. 赋值运算符"></a>5. 赋值运算符</h2><p>以下是Java语言支持的赋值运算符 - </p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>简单赋值运算符。 将右侧操作数的值分配给左侧操作数。</td>
<td><code>C = A + B</code>将<code>A + B</code>的值分配给<code>C</code>。</td>
</tr>
<tr>
<td><code>+=</code></td>
<td>相加与赋值运算符。 它将右操作数相加到左操作数并将结果分配给左操作数。</td>
<td><code>C += A</code>等于<code>C = C + A</code>。</td>
</tr>
<tr>
<td><code>-=</code></td>
<td>减去与赋值运算符。 它从左操作数中减去右操作数，并将结果赋给左操作数。</td>
<td><code>C -= A</code>等于<code>C = C - A</code>。</td>
</tr>
<tr>
<td><code>*=</code></td>
<td>乘以与赋值运算符。 它将右操作数与左操作数相乘，并将结果赋给左操作数。</td>
<td><code>C *= A</code>等于<code>C = C * A</code>。</td>
</tr>
<tr>
<td><code>/=</code></td>
<td>除以与赋值运算符。 它将左操作数除以右操作数，并将结果赋给左操作数。</td>
<td><code>C /= A</code>等于<code>C = C / A</code>。</td>
</tr>
<tr>
<td><code>%=</code></td>
<td>模数与赋值运算符。 它使用两个操作数来计算获取模数，并将结果赋给左操作数。</td>
<td><code>C %= A</code>等于<code>C = C % A</code>。</td>
</tr>
<tr>
<td><code>&lt;&lt;=</code></td>
<td>左移与赋值运算符。</td>
<td><code>C &lt;&lt;= 2</code>与<code>C = C &lt;&lt; 2</code>相同</td>
</tr>
<tr>
<td><code>&gt;&gt;=</code></td>
<td>右移与赋值运算符。</td>
<td><code>C &gt;&gt;= 2</code>与<code>C = C &gt;&gt; 2</code>相同</td>
</tr>
<tr>
<td><code>&amp;=</code></td>
<td>按位与赋值运算符。</td>
<td><code>C &amp;= 2</code>与<code>C = C &amp; 2</code>相同</td>
</tr>
<tr>
<td><code>^=</code></td>
<td>按位异或和赋值运算符。</td>
<td><code>C ^= 2</code>与<code>C = C ^ 2</code>相同</td>
</tr>
<tr>
<td>Ι=</td>
<td>按位包含或与赋值运算符。</td>
<td>C Ι= 2与C = C Ι=2相同</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_assignment_operators_examples.html">赋值运算符示例代码</a></p>
<h2 id="6-其它运算符"><a href="#6-其它运算符" class="headerlink" title="6. 其它运算符"></a>6. 其它运算符</h2><p>Java语言支持的其他运算符很少。</p>
<p><strong>6.1. 条件运算符(?:)</strong></p>
<p>条件运算符也称为三元运算符。 此运算符由三个操作数组成，用于计算布尔表达式。 运算符的目标是确定应将哪个值赋给变量。 运算符写成 - </p>
<pre><code class="java">variable x = (expression) ? value if true : value if false
Java
</code></pre>
<p>下面是一段示例代码：</p>
<pre><code class="java">public class Test &#123;

   public static void main(String args[]) &#123;
      int a, b;
      a = 10;
      b = (a == 1) ? 20: 30;
      System.out.println( &quot;Value of b is : &quot; +  b );

      b = (a == 10) ? 20: 30;
      System.out.println( &quot;Value of b is : &quot; + b );
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果 -</p>
<pre><code class="shell">Value of b is : 30
Value of b is : 20
Shell
</code></pre>
<p><strong>6.2. instanceof运算符</strong><br>此运算符仅用于对象引用变量。 运算符检查对象是否属于特定类型(类类型或接口类型)。 <code>instanceof</code>运算符写成 - </p>
<pre><code class="java">( Object reference variable ) instanceof  (class/interface type)
Java
</code></pre>
<p>如果操作符左侧的变量引用的对象是右侧的类/接口类型，则结果为真。 以下是一个例子 - </p>
<pre><code class="java">public class Test &#123;

   public static void main(String args[]) &#123;

      String name = &quot;Kobe&quot;;

      // 当 name 的类型是 String 时，则返回为：true
      boolean result = name instanceof String;
      System.out.println( result );
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">true
Shell
</code></pre>
<p>如果要比较的对象与右侧类型兼容，则此运算符仍将返回<code>true</code>。 以下是另一个例子 - </p>
<pre><code class="java">class Vehicle &#123;&#125;

public class Car extends Vehicle &#123;

   public static void main(String args[]) &#123;

      Vehicle a = new Car();
      boolean result =  a instanceof Car;
      System.out.println( result );
   &#125;
&#125;
Java
</code></pre>
<p>执行上在示例代码，得到以下结果：</p>
<pre><code class="shell">true
</code></pre>
<h1 id="Java循环控制"><a href="#Java循环控制" class="headerlink" title="Java循环控制"></a>Java循环控制</h1><p>在程序执行过程中，存在需要多次执行代码块的情况。 通常，语句按顺序执行：首先执行函数中的第一个语句，然后执行第二个语句，依此类推。</p>
<p>编程语言提供各种控制结构，允许更复杂的执行路径。</p>
<p>循环语句用于多次执行一个语句或一组语句，以下是大多数编程语言中循环语句的一般形式 - </p>
<p><img src="https://www.yiibai.com/uploads/article/2019/03/11/220112_19179.jpg" alt="循环流程图"></p>
<p>Java编程语言提供以下类型的循环来处理循环要求，可通过单击以下每个链接来学习。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>循环</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_while_loop.html">while循环</a></td>
<td>在给定条件为真时重复语句或语句组，它在执行循环体之前测试条件。</td>
</tr>
<tr>
<td>2</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_for_loop.html">for循环</a></td>
<td>多次执行一系列语句，并缩写管理循环变量的代码。</td>
</tr>
<tr>
<td>3</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_do_while_loop.html">do…while循环</a></td>
<td>像<code>while</code>语句一样，但是它在末端测试循环体的条件。</td>
</tr>
</tbody></table>
<h2 id="1-循环控制语句"><a href="#1-循环控制语句" class="headerlink" title="1. 循环控制语句"></a>1. 循环控制语句</h2><p>循环控制语句将执行从正常执行顺序更变。 当执行离开作用域时，将销毁在该作用域中创建的所有自动对象。</p>
<p>Java支持以下控制语句，可通过单击以下每个链接来了解和学习。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>控制语句</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_break_statement.html">break语句</a></td>
<td>终止循环或<code>switch</code>语句，并立即将执行转移到在循环或<code>switch</code>之后的语句。</td>
</tr>
<tr>
<td>2</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_continue_statement.html">continue语句</a></td>
<td>使循环跳过其主体的其余部分，并在重复之前立即重新测试其状态。</td>
</tr>
</tbody></table>
<h2 id="2-增强Java循环"><a href="#2-增强Java循环" class="headerlink" title="2. 增强Java循环"></a>2. 增强Java循环</h2><p>从Java 5开始，引入了增强的<code>for</code>循环。 这主要用于遍历元素的集合，包括数组。</p>
<p><strong>语法</strong><br>以下是增强<code>for</code>循环的语法 - </p>
<pre><code class="java">for(declaration : expression) &#123;
   // Statements
&#125;
Java
</code></pre>
<p>在上面语法中，</p>
<ul>
<li><code>declaration</code> - 新声明的块变量，是与要访问的数组元素兼容的类型。变量将在<code>for</code>块中可用，其值将与当前数组元素相同。</li>
<li><code>expression</code> - 这是要循环的数组。表达式(<code>expression</code>)可以是返回的数组变量或方法调用。</li>
</ul>
<p><strong>示例</strong></p>
<pre><code class="java">public class Test &#123;

   public static void main(String args[]) &#123;
      int [] numbers = &#123;10, 20, 30, 40, 50&#125;;

      for(int x : numbers ) &#123;
         System.out.print( x );
         System.out.print(&quot;,&quot;);
      &#125;
      System.out.print(&quot;\n&quot;);
      String [] names = &#123;&quot;James&quot;, &quot;Curry&quot;, &quot;Kobe&quot;, &quot;Jordan&quot;&#125;;

      for( String name : names ) &#123;
         System.out.print( name );
         System.out.print(&quot;,&quot;);
      &#125;
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码得到以下结果 - </p>
<pre><code class="shell">10, 20, 30, 40, 50,
James, Curry, Kobe, Jordan,
</code></pre>
<h1 id="Java-if-else语句"><a href="#Java-if-else语句" class="headerlink" title="Java if/else语句"></a>Java if/else语句</h1><p>Java <strong>if语句</strong>用于测试条件。它检查布尔条件为：<code>true</code>或<code>false</code>。 java中有各种类型的<strong>if语句</strong>，它们分别如下：</p>
<ul>
<li>if语句</li>
<li>if-else语句</li>
<li>嵌套if语句</li>
<li>if-else-if语句</li>
</ul>
<h2 id="Java-if语句"><a href="#Java-if语句" class="headerlink" title="Java if语句"></a>Java if语句</h2><p>Java语言中的<code>if</code>语句用于测试条件。如果条件为<code>true</code>，则执行<code>if</code>语句块。</p>
<p><strong>语法：</strong></p>
<pre><code class="java">if(condition)&#123;  
   // if 语句块 =&gt; code to be executed.
&#125;
Java
</code></pre>
<p>执行流程如下图所示 - </p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0203/348100309_40587.png" alt="img"></p>
<h3 id="1-示例"><a href="#1-示例" class="headerlink" title="1. 示例"></a>1. 示例</h3><pre><code class="java">public class IfExample &#123;
    public static void main(String[] args) &#123;
        int age = 20;
        if (age &gt; 18) &#123;
            System.out.print(&quot;Age is greater than 18&quot;);
        &#125;
    &#125;
&#125;
Java
</code></pre>
<p>输出结果如下 - </p>
<pre><code class="java">Age is greater than 18
Java
</code></pre>
<h2 id="Java-if-else语句-1"><a href="#Java-if-else语句-1" class="headerlink" title="Java if-else语句"></a>Java if-else语句</h2><p>Java <code>if-else</code>语句也用于测试条件。如果<code>if</code>条件为真(<code>true</code>)它执行<code>if</code>块中的代码，否则执行<code>else</code>块中的代码。</p>
<p><strong>语法：</strong></p>
<pre><code class="java">if(condition)&#123;  
    //code if condition is true  
&#125;else&#123;  
    //code if condition is false  
&#125;
Java
</code></pre>
<p>执行流程如下图所示 - </p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0203/943100317_20518.png" alt="img"></p>
<p><strong>示例代码：</strong></p>
<pre><code class="java">public class IfElseExample &#123;
    public static void main(String[] args) &#123;
        int number = 13;
        if (number % 2 == 0) &#123;
            System.out.println(&quot;这是一个偶数&quot;);
        &#125; else &#123;
            System.out.println(&quot;这是一个奇数&quot;);
        &#125;
    &#125;
&#125;
Java
</code></pre>
<p>输出结果如下 - </p>
<pre><code class="java">这是一个奇数
Java
</code></pre>
<h2 id="Java-if-else-if语句"><a href="#Java-if-else-if语句" class="headerlink" title="Java if-else-if语句"></a>Java if-else-if语句</h2><p>Java编程中的<code>if-else-if</code>语句是从多个语句中执行一个条件。</p>
<p><strong>语法：</strong></p>
<pre><code class="java">if(condition1)&#123;  
    //code to be executed if condition1 is true  
&#125;else if(condition2)&#123;  
    //code to be executed if condition2 is true  
&#125;else if(condition3)&#123;  
    //code to be executed if condition3 is true  
&#125;  
...  
else&#123;  
    //code to be executed if all the conditions are false  
&#125;
Java
</code></pre>
<p>执行流程如下图所示 - </p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0203/890100324_52213.png" alt="img"></p>
<p><strong>示例：</strong></p>
<pre><code class="java">public class IfElseIfExample &#123;
    public static void main(String[] args) &#123;
        int marks = 65;

        if (marks &lt; 50) &#123;
            System.out.println(&quot;fail&quot;);
        &#125; else if (marks &gt;= 50 &amp;&amp; marks &lt; 60) &#123;
            System.out.println(&quot;D grade&quot;);
        &#125; else if (marks &gt;= 60 &amp;&amp; marks &lt; 70) &#123;
            System.out.println(&quot;C grade&quot;);
        &#125; else if (marks &gt;= 70 &amp;&amp; marks &lt; 80) &#123;
            System.out.println(&quot;B grade&quot;);
        &#125; else if (marks &gt;= 80 &amp;&amp; marks &lt; 90) &#123;
            System.out.println(&quot;A grade&quot;);
        &#125; else if (marks &gt;= 90 &amp;&amp; marks &lt; 100) &#123;
            System.out.println(&quot;A+ grade&quot;);
        &#125; else &#123;
            System.out.println(&quot;Invalid!&quot;);
        &#125;
    &#125;
&#125;
Java
</code></pre>
<p>输出结果如下 - </p>
<pre><code class="java">C grade
</code></pre>
<h1 id="Java-switch语句"><a href="#Java-switch语句" class="headerlink" title="Java switch语句"></a>Java switch语句</h1><p>Java <strong>switch语句</strong>用于从多个条件执行一个语句。它就像<code>if-else-if</code>语句一样。</p>
<p><strong>语法：</strong></p>
<pre><code class="java">switch(expression)&#123;    
    case value1:    
       //code to be executed;    
       break;  //optional  
    case value2:    
       //code to be executed;    
       break;  //optional  
    ......    

    default:     
       // code to be executed if all cases are not matched;    
&#125;
Java
</code></pre>
<p><strong>switch语句</strong>执行流程图如下所示 - </p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0203/839100335_12014.png" alt="img"></p>
<p><strong>示例：</strong></p>
<pre><code class="java">public class SwitchExample &#123;
    public static void main(String[] args) &#123;
        int number = 20;
        switch (number) &#123;
        case 10:
            System.out.println(&quot;10&quot;);
            break;
        case 20:
            System.out.println(&quot;20&quot;);
            break;
        case 30:
            System.out.println(&quot;30&quot;);
            break;
        default:
            System.out.println(&quot;Not in 10, 20 or 30&quot;);
        &#125;
    &#125;
&#125;
Java
</code></pre>
<p>执行输出结果如下：</p>
<pre><code class="java">20
Java
</code></pre>
<h2 id="Java-switch语句落空通过所有case语句"><a href="#Java-switch语句落空通过所有case语句" class="headerlink" title="Java switch语句落空通过所有case语句"></a>Java switch语句落空通过所有case语句</h2><p>下面我们来看看java <code>switch</code>语句落空通过所有条件，即 <code>case</code> 子句中的所有条件都未能匹配。也就是如果不在 <code>switch case</code> 下使用<code>break</code>语句，则它在第一个匹配之后也会执行接下来的所有 <code>case</code> 中的语句。</p>
<p><strong>示例：</strong></p>
<pre><code class="java">public class SwitchExample2 &#123;
    public static void main(String[] args) &#123;
        int number = 20;
        switch (number) &#123;
        case 10:
            System.out.println(&quot;10&quot;);
        case 20:
            System.out.println(&quot;20&quot;);
        case 30:
            System.out.println(&quot;30&quot;);
        default:
            System.out.println(&quot;Not in 10, 20 or 30&quot;);
        &#125;
    &#125;
&#125;
Java
</code></pre>
<p>执行输出结果如下：</p>
<pre><code class="java">20
30
Not in 10, 20 or 30
</code></pre>
<h1 id="Java-for循环"><a href="#Java-for循环" class="headerlink" title="Java for循环"></a>Java for循环</h1><p>Java <strong>for循环</strong>用于多次迭代程序的一部分，或者多次执行同一个代码块。如果迭代次数是固定的，建议使用<code>for</code>循环。</p>
<p>java中有三种类型的<code>for</code>循环。如下所示 - </p>
<ul>
<li>简单<code>for</code>循环</li>
<li><code>for-each</code>或增强型<code>for</code>循环</li>
<li>标记<code>for</code>循环</li>
</ul>
<h2 id="1-Java简单For循环"><a href="#1-Java简单For循环" class="headerlink" title="1. Java简单For循环"></a>1. Java简单For循环</h2><p>简单的<code>for</code>循环与<code>C/C++</code>相同。我们可以初始化变量，检查条件和增加/减少变量的值。</p>
<p><strong>语法：</strong></p>
<pre><code class="java">for(initialization;condition;incr/decr)&#123;  
    //code to be executed  
&#125;
Java
</code></pre>
<p>执行流程图如下所示 - </p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0203/154170317_68642.png" alt="img"></p>
<p><strong>示例：</strong></p>
<pre><code class="java">public class ForExample &#123;  
    public static void main(String[] args) &#123;  
        for(int i=1;i&lt;=10;i++)&#123;  
            System.out.println(i);  
        &#125;  
    &#125;  
&#125;
Java
</code></pre>
<p>执行上面的代码，输出如下 - </p>
<pre><code class="java">1
2
3
4
5
6
7
8
9
10
Java
</code></pre>
<h2 id="2-Java-for-each循环"><a href="#2-Java-for-each循环" class="headerlink" title="2. Java for-each循环"></a>2. Java for-each循环</h2><p><code>for-each</code>循环用于在java中遍历数组或集合。它比简单的<code>for</code>循环更容易使用，因为不需要递增值和使用下标符号。</p>
<p><strong>语法：</strong></p>
<pre><code class="java">for(Type var:array)&#123;  
   //code to be executed  
&#125;
Java
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="java">public class ForEachExample  &#123;
    public static void main(String[] args) &#123;
        int arr[] = &#123; 12, 23, 44, 56, 78 &#125;;
        for (int i : arr) &#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;
Java
</code></pre>
<p>执行上面的代码，得到如下结果 - </p>
<pre><code class="java">12
23
44
56
78
Java
</code></pre>
<h2 id="3-Java标记For循环"><a href="#3-Java标记For循环" class="headerlink" title="3. Java标记For循环"></a>3. Java标记For循环</h2><p>我们可以让每个<code>for</code>循环的名称。 为此，在<code>for</code>循环之前使用标签。它是有用的，如果在嵌套<code>for</code>循环中，可以使用<code>break/continue</code>指定循环。</p>
<p>通常，<code>break</code>和<code>continue</code>关键字断开/继续最内循环。</p>
<p><strong>语法：</strong></p>
<pre><code class="java">labelname:  
for(initialization;condition;incr/decr)&#123;  
    //code to be executed  
&#125;
Java
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="java">public class LabeledForExample  &#123;
    public static void main(String[] args) &#123;
        aa: for (int i = 1; i &lt;= 3; i++) &#123;
            bb: for (int j = 1; j &lt;= 3; j++) &#123;
                if (i == 2 &amp;&amp; j == 2) &#123;
                    break aa;
                &#125;
                System.out.println(i + &quot; &quot; + j);
            &#125;
        &#125;
    &#125;
&#125;
Java
</code></pre>
<p>执行上面的代码，得到如下结果 - </p>
<pre><code class="shell">1 1
1 2
1 3
2 1
Shell
</code></pre>
<p>如果使用<code>break bb</code>;它将打断内循环，这是任何循环的默认行为。</p>
<pre><code class="java">public class LabeledForExample &#123;
    public static void main(String[] args) &#123;
        aa: for (int i = 1; i &lt;= 3; i++) &#123;
            bb: for (int j = 1; j &lt;= 3; j++) &#123;
                if (i == 2 &amp;&amp; j == 2) &#123;
                    break bb;
                &#125;
                System.out.println(i + &quot; &quot; + j);
            &#125;
        &#125;
    &#125;
&#125;
Java
</code></pre>
<p>执行上面的代码，得到如下结果 - </p>
<pre><code class="shell">1 1
1 2
1 3
2 1
3 1
3 2
3 3
Shell
</code></pre>
<h2 id="4-Java无限循环"><a href="#4-Java无限循环" class="headerlink" title="4. Java无限循环"></a>4. Java无限循环</h2><p>在<code>for</code>循环中，如果使用两个分号<code>;</code>，则它对于循环将是不定式的。</p>
<p><strong>语法：</strong></p>
<pre><code class="java">for(;;)&#123;  
    //code to be executed  
&#125;
Java
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="java">public class ForExample &#123;
    public static void main(String[] args) &#123;
        for (;;) &#123;
            System.out.println(&quot;infinitive loop&quot;);
        &#125;
    &#125;
&#125;
Java
</code></pre>
<p>执行上面的代码，得到如下结果 - </p>
<pre><code class="java">infinitive loop
infinitive loop
infinitive loop
infinitive loop
infinitive loop
ctrl+c
Java
</code></pre>
<blockquote>
<p>提示： 在执行上面的程序时，您需要按<code>ctrl + c</code>退出程序。</p>
</blockquote>
<h1 id="Java-while循环"><a href="#Java-while循环" class="headerlink" title="Java while循环"></a>Java while循环</h1><p>Java <strong>while循环</strong>用于重复程序的一部分几次或重复执行一个代码块。 如果迭代次数不固定，建议使用<code>while</code>循环。</p>
<p><strong>语法：</strong></p>
<pre><code class="java">while(condition)&#123;  
    //code to be executed  
&#125;
Java
</code></pre>
<p>下面是 <code>while</code> 循环的执行流程 -</p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0203/879220350_51834.png" alt="img"></p>
<p><strong>示例：</strong></p>
<pre><code class="java">public class WhileExample &#123;
    public static void main(String[] args) &#123;
        int i = 1;
        while (i &lt;= 10) &#123;
            System.out.println(i);
            i++;
        &#125;
    &#125;
&#125;
Java
</code></pre>
<p>执行上面的代码，得到下面的结果 -</p>
<pre><code class="java">1
2
3
4
5
6
7
8
9
10
Java
</code></pre>
<h2 id="Java无限while循环"><a href="#Java无限while循环" class="headerlink" title="Java无限while循环"></a>Java无限while循环</h2><p>如果在<code>while</code>循环中传递<code>true</code>作为参数，它将是一个无限<code>while</code>循环。</p>
<p><strong>语法：</strong></p>
<pre><code class="java">while(true)&#123;  
    //code to be executed  
&#125;
Java
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="java">public class WhileExample2 &#123;
    public static void main(String[] args) &#123;
        while (true) &#123;
            System.out.println(&quot;infinitive while loop&quot;);
        &#125;
    &#125;
&#125;
Java
</code></pre>
<p>执行上面的代码，得到下面的结果 -</p>
<pre><code class="java">infinitive while loop
infinitive while loop
infinitive while loop
infinitive while loop
infinitive while loop
ctrl+c
Java
</code></pre>
<blockquote>
<p>注意：由于无限循环程序无法退出，所以您需要按<code>ctrl + c</code>退出程序。</p>
</blockquote>
<h1 id="Java-do-while循环"><a href="#Java-do-while循环" class="headerlink" title="Java do-while循环"></a>Java do-while循环</h1><p>Java <code>do-while</code>循环用于多次迭代程序的一部分或重复多次执行一个代码块。 如果迭代次数不固定，必须至少执行一次循环，建议使用<code>do-while</code>循环。</p>
<p>Java <code>do-while</code>循环至少执行一次，因为它是在循环体之后检查条件。</p>
<p><strong>语法：</strong></p>
<pre><code class="java">do&#123;  
    //code to be executed  
&#125;while(condition); // 后置条件检查
Java
</code></pre>
<p>Java <code>do-while</code>循环执行流程图如下所示 -<br><img src="http://www.yiibai.com/uploads/images/201703/0203/515230301_73132.png" alt="img"></p>
<p><strong>示例：</strong></p>
<pre><code class="java">public class DoWhileExample &#123;
    public static void main(String[] args) &#123;
        int i = 1;
        do &#123;
            System.out.println(i);
            i++;
        &#125; while (i &lt;= 10);
    &#125;
&#125;
Java
</code></pre>
<p>执行结果如下 - </p>
<pre><code class="java">1
2
3
4
5
6
7
8
9
10
Java
</code></pre>
<h2 id="Java无限do-while循环"><a href="#Java无限do-while循环" class="headerlink" title="Java无限do-while循环"></a>Java无限do-while循环</h2><p>如果在<code>do-while</code>循环中传递参数值为：<code>true</code>，它将是一个无限<code>do-while</code>循环。</p>
<p><strong>语法：</strong></p>
<pre><code class="java">do&#123;  
    //code to be executed  
&#125;while(true);
Java
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="java">public class DoWhileExample2 &#123;
    public static void main(String[] args) &#123;
        do &#123;
            System.out.println(&quot;infinitive do while loop&quot;);
        &#125; while (true);
    &#125;
&#125;
Java
</code></pre>
<p>执行结果如下 - </p>
<pre><code class="java">infinitive do while loop
infinitive do while loop
infinitive do while loop
ctrl+c
Java
</code></pre>
<blockquote>
<p>上面的需要按<code>ctrl + c</code>退出程序。</p>
</blockquote>
<h1 id="Java-break语句"><a href="#Java-break语句" class="headerlink" title="Java break语句"></a>Java break语句</h1><p>Java break用于断开循环或<code>switch</code>语句。它在指定条件下中断程序的当前流程。 在内循环的情况下，它仅中断内循环，外循环仍然可继续执行。</p>
<p><strong>语法：</strong></p>
<pre><code class="java">jump-statement;    
break;
Java
</code></pre>
<p>break语句的执行流程图如下所示 -</p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0303/987080346_98968.png" alt="img"></p>
<h2 id="Java-Break语句和循环"><a href="#Java-Break语句和循环" class="headerlink" title="Java Break语句和循环"></a>Java Break语句和循环</h2><p><strong>示例：</strong></p>
<pre><code class="java">public class BreakExample &#123;
    public static void main(String[] args) &#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            if (i == 5) &#123;
                break;
            &#125;
            System.out.println(i);
        &#125;
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码得到结果 - </p>
<pre><code class="java">1
2
3
4
Java
</code></pre>
<h2 id="Java内部循环语句"><a href="#Java内部循环语句" class="headerlink" title="Java内部循环语句"></a>Java内部循环语句</h2><p>它中断了内循环，只有当你在内循环中使用<code>break</code>语句。</p>
<p><strong>示例：</strong></p>
<pre><code class="java">public class BreakExample2 &#123;
    public static void main(String[] args) &#123;
        for (int i = 1; i &lt;= 3; i++) &#123;
            for (int j = 1; j &lt;= 3; j++) &#123;
                if (i == 2 &amp;&amp; j == 2) &#123;
                    break;
                &#125;
                System.out.println(i + &quot; &quot; + j);
            &#125;
        &#125;
    &#125;
&#125;
Java
</code></pre>
<p>上面代码输出输出：</p>
<pre><code class="java">1 1
1 2
1 3
2 1
3 1
3 2
3 3
Java
</code></pre>
<p><strong>带有Java break语句和Switch语句</strong></p>
<h1 id="Java-continue语句"><a href="#Java-continue语句" class="headerlink" title="Java continue语句"></a>Java continue语句</h1><p>Java <strong>continue语句</strong>用于继续循环。 它继续程序的当前流程，并在指定条件下跳过剩余的代码。在内循环的情况下，它仅继续内循环。</p>
<p><strong>语法：</strong></p>
<pre><code class="java">jump-statement;    
continue;
Java
</code></pre>
<h2 id="Java-continue语句示例"><a href="#Java-continue语句示例" class="headerlink" title="Java continue语句示例"></a>Java continue语句示例</h2><p><strong>示例：</strong></p>
<pre><code class="java">public class ContinueExample &#123;
    public static void main(String[] args) &#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            if (i == 5) &#123;
                continue;
            &#125;
            System.out.println(i);
        &#125;
    &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到如下结果 - </p>
<pre><code class="java">1
2
3
4
6
7
8
9
10
Java
</code></pre>
<h2 id="Java-continue语句与内循环"><a href="#Java-continue语句与内循环" class="headerlink" title="Java continue语句与内循环"></a>Java continue语句与内循环</h2><p>如果在内循环中使用<code>continue</code>语句，它将继续内循环。</p>
<p><strong>示例：</strong></p>
<pre><code class="java">public class ContinueExample2 &#123;
    public static void main(String[] args) &#123;
        for (int i = 1; i &lt;= 3; i++) &#123;
            for (int j = 1; j &lt;= 3; j++) &#123;
                if (i == 2 &amp;&amp; j == 2) &#123;
                    continue;
                &#125;
                System.out.println(i + &quot; &quot; + j);
            &#125;
        &#125;
    &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到如下结果 - </p>
<pre><code class="java">1 1
1 2
1 3
2 1
2 3
3 1
3 2
3 3
</code></pre>
<h1 id="Java注释"><a href="#Java注释" class="headerlink" title="Java注释"></a>Java注释</h1><p> <strong>java注释</strong>是不会被编译器和解释器执行的语句。 注释可以用于提供关于变量，方法，类或任何语句的信息或解释。 它也可以用于在特定时间隐藏程序代码。</p>
<h2 id="Java注释的类型"><a href="#Java注释的类型" class="headerlink" title="Java注释的类型"></a>Java注释的类型</h2><p>在Java中有<code>3</code>种类型的注释。它们分别如下 - </p>
<ol>
<li>单行注释</li>
<li>多行注释</li>
<li>文档注释</li>
</ol>
<h3 id="1-Java单行注释"><a href="#1-Java单行注释" class="headerlink" title="1)Java单行注释"></a>1)Java单行注释</h3><p>单行注释仅用于注释一行，它使用的是 <code>//</code> 两个字符作为一行注释的开始，如下语法所示 - </p>
<p><strong>语法：</strong></p>
<pre><code class="java">// This is single line comment
Java
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="java">public class CommentExample1 &#123;
    public static void main(String[] args) &#123;
        int i = 10;// Here, i is a variable
        System.out.println(i);
        int j = 20;
        // System.out.println(j); 这是另一行注释，这行代码不会被执行。
    &#125;
&#125;
Java
</code></pre>
<p>上面示例代码输出结果如下 - </p>
<pre><code class="java">10
Java
</code></pre>
<h3 id="2-Java多行注释"><a href="#2-Java多行注释" class="headerlink" title="2)Java多行注释"></a>2)Java多行注释</h3><p>多行注释用于注释多行代码。它以 <code>/*</code> 开始，并以 <code>*/</code> 结束，在 <code>/*</code> 和 <code>*/</code>之间的代码块就是一个注释块，其中的代码是不会这被执行的。</p>
<p><strong>语法：</strong></p>
<pre><code class="java">/* 
This  
is  
multi line  
comment 
*/
Java
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="java">public class CommentExample2 &#123;
    public static void main(String[] args) &#123;
        /*
         * Let&#39;s declare and print variable in java.
         *
         *  这是多行注释
         */
        int i = 10;
        System.out.println(i);
    &#125;
&#125;
Java
</code></pre>
<p>上面示例代码输出结果如下 - </p>
<pre><code class="java">10
Java
</code></pre>
<h3 id="3-Java文档注释"><a href="#3-Java文档注释" class="headerlink" title="3)Java文档注释"></a>3)Java文档注释</h3><p>文档注释用于创建文档API。 要创建文档API，需要使用<code>javadoc</code>工具。</p>
<p><strong>语法：</strong></p>
<pre><code class="java">/** 
This  
is  
documentation  
comment 
*/
Java
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="java">/**
 * The Calculator class provides methods to get addition and subtraction of
 * given 2 numbers.
 */
public class Calculator &#123;
    /** The add() method returns addition of given numbers. */
    public static int add(int a, int b) &#123;
        return a + b;
    &#125;

    /** The sub() method returns subtraction of given numbers. */
    public static int sub(int a, int b) &#123;
        return a - b;
    &#125;
&#125;
Java
</code></pre>
<p>通过<code>javac</code>工具编译：</p>
<pre><code class="java">javac Calculator.java
Java
</code></pre>
<p>通过<code>javadoc</code>工具创建文档API：</p>
<pre><code class="java">javadoc Calculator.java
Java
</code></pre>
<p>现在，将在当前目录中为上面的<code>Calculator</code>类创建了HTML文件。 打开HTML文件，并查看通过文档注释提供的<code>Calculator</code>类的说明。如下所示 - </p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0303/898090318_21765.png" alt="img"></p>
<h1 id="Java基础实例程序"><a href="#Java基础实例程序" class="headerlink" title="Java基础实例程序"></a>Java基础实例程序</h1><p>Java基础实例程序在面试中经常提到。这些程序可以从控制语句，数组，字符串，面向对象等等。让我们来看看下面java实例程序的列表。</p>
<h3 id="1-斐波纳契数列"><a href="#1-斐波纳契数列" class="headerlink" title="1. 斐波纳契数列"></a>1. 斐波纳契数列</h3><p>编写一个java程序打印斐波纳契(fibonacci)数列不使用递归和使用递归。示例链接：<a target="_blank" rel="noopener" href="http://www.yiibai.com/java/fibonacci-series-in-java.html">斐波纳契数列代码实现</a></p>
<p><strong>输入</strong>: <code>10</code></p>
<p><strong>输出</strong>: <code>0 1 1 2 3 5 8 13 21 34</code></p>
<h3 id="2-素数实例"><a href="#2-素数实例" class="headerlink" title="2. 素数实例"></a>2. 素数实例</h3><p>编写一个java程序来判定给定的一个数字是否为素数。示例链接：<a target="_blank" rel="noopener" href="http://www.yiibai.com/java/prime-number-program-in-java.html">素数实例代码</a></p>
<p><strong>输入</strong>: 44</p>
<p><strong>输出</strong>: <code>not prime number</code></p>
<p><strong>输入</strong>: 7</p>
<p><strong>输出</strong>: <code>prime number</code></p>
<h3 id="3-回文数"><a href="#3-回文数" class="headerlink" title="3. 回文数"></a>3. 回文数</h3><p>编写一个java程序断定给定的字符串是否为一个回文数。示例链接：<a target="_blank" rel="noopener" href="http://www.yiibai.com/java/palindrome-program-in-java.html">回文数示例</a></p>
<p><strong>输入：</strong> <code>123</code></p>
<p><strong>输出：</strong> <code>not palindrome number</code></p>
<p><strong>输入：</strong> <code>12321</code></p>
<p><strong>输出：</strong> <code>palindrome number</code></p>
<h3 id="4-阶乘"><a href="#4-阶乘" class="headerlink" title="4. 阶乘"></a>4. 阶乘</h3><p>编写一个java程序来打印数字的阶乘。示例链接：<a target="_blank" rel="noopener" href="http://www.yiibai.com/java/factorial-program-in-java.html">阶乘实现代码</a></p>
<p><strong>输入：</strong>  <code>5</code></p>
<p><strong>输出：</strong> <code>120</code></p>
<p><strong>输入：</strong>  <code>6</code></p>
<p><strong>输出：</strong> <code>720</code></p>
<h3 id="5-阿姆斯壮数"><a href="#5-阿姆斯壮数" class="headerlink" title="5. 阿姆斯壮数"></a>5. 阿姆斯壮数</h3><p>编写一个java程序来断定一个数值是否为阿姆斯壮(Armstrong)数。示例链接：<a target="_blank" rel="noopener" href="http://www.yiibai.com/java/armstrong-number-in-java.html">阿姆斯壮数实例</a></p>
<p><strong>输入：</strong> <code>153</code></p>
<p><strong>输出：</strong> <code>Armstrong number</code></p>
<p><strong>输入：</strong> <code>22</code></p>
<p><strong>输出：</strong> <code>not Armstrong number</code></p>
<h3 id="6-气泡排序"><a href="#6-气泡排序" class="headerlink" title="6. 气泡排序"></a>6. 气泡排序</h3><p>编写一个java程序，使用冒泡排序算法对数组元素进行排序。示例链接：<a target="_blank" rel="noopener" href="http://www.yiibai.com/java/bubble-sort-in-java.html">气泡排序实例</a></p>
<p><strong>输入：</strong> 18 9 33 4 84 32</p>
<p><strong>输出：</strong> 4 9 18 32 33 84</p>
<h3 id="7-选择排序"><a href="#7-选择排序" class="headerlink" title="7. 选择排序"></a>7. 选择排序</h3><p>编写一个java程序，使用选择排序算法对数组元素进行排序。示例链接：<a target="_blank" rel="noopener" href="http://www.yiibai.com/java/selection-sort-in-java.html">选择排序实例</a></p>
<p><strong>输入：</strong> 18 9 33 4 84 32</p>
<p><strong>输出：</strong> 4 9 18 32 33 84</p>
<h3 id="8-插入排序"><a href="#8-插入排序" class="headerlink" title="8. 插入排序"></a>8. 插入排序</h3><p>编写一个java程序，使用插入排序算法对数组元素进行排序。示例链接：<a target="_blank" rel="noopener" href="http://www.yiibai.com/java/insertion-sort-in-java.html">插入排序实例</a></p>
<h1 id="Java面向对象（OOP）概念"><a href="#Java面向对象（OOP）概念" class="headerlink" title="Java面向对象（OOP）概念"></a>Java面向对象（OOP）概念</h1><p>在本节中，将了解面向对象(OOP)的基础知识。面向对象编程只是一个模式，它提供许多概念，如继承，数据绑定，多态等等。</p>
<p><code>Simula</code>是第一种面向对象的编程语言。而一切都可表示为对象的编程模式被称为真正的面向对象的编程语言。<code>Smalltalk</code>是第一个真正的面向对象的编程语言。</p>
<h2 id="1-面向对象编程"><a href="#1-面向对象编程" class="headerlink" title="1. 面向对象编程"></a>1. 面向对象编程</h2><p>对象表示真实的单词实体，如：笔，椅子，表等。面向对象编程是一种使用类和对象来设计程序的方法或模式。它通过提供一些概念简化了软件开发和维护：</p>
<ul>
<li>对象</li>
<li>类</li>
<li>继承</li>
<li>多态性</li>
<li>抽象</li>
<li>封装</li>
<li>组合</li>
</ul>
<h4 id="1-1-对象"><a href="#1-1-对象" class="headerlink" title="1.1. 对象"></a>1.1. 对象</h4><p>任何具有状态和行为的实体都称为<strong>对象</strong>。例如：椅子，钢笔，桌子，键盘，自行车等。它可以是物理和逻辑的。</p>
<h4 id="1-2-类"><a href="#1-2-类" class="headerlink" title="1.2. 类"></a>1.2. 类</h4><p>对象的集合称为<strong>类</strong>，它是一个逻辑实体。</p>
<h4 id="1-3-继承"><a href="#1-3-继承" class="headerlink" title="1.3. 继承"></a>1.3. 继承</h4><p>当一个对象获取父对象的所有属性和行为时，称为<strong>继承</strong>。它提供代码可重用性，它用于实现运行时多态性。<br>继承是面向对象的编程概念，一个对象基于另一个对象构建。继承是代码重用的机制， 被继承的类称为超类，继承超类的类称为子类。<br>在java中使用<code>extends</code>关键字来实现继承。下面是java中继承的一个简单示例。</p>
<pre><code class="java">class SuperClassA &#123;
    public void foo()&#123;
        System.out.println(&quot;SuperClassA&quot;);
    &#125;

&#125;
// 继承 SuperClassA 类
class SubClassB extends SuperClassA&#123;

    public void bar()&#123;
        System.out.println(&quot;SubClassB&quot;);
    &#125;

&#125;

public class Test &#123;
    public static void main(String args[])&#123;
        SubClassB a = new SubClassB();

        a.foo();
        a.bar();
    &#125;
&#125;
Java
</code></pre>
<h4 id="1-4-多态性"><a href="#1-4-多态性" class="headerlink" title="1.4. 多态性"></a>1.4. 多态性</h4><p>当一个任务通过不同的方式执行时，称为<strong>多态性</strong>。例如：以不同的方式说服客户，画一些东西，如：形状或矩形等。在java中，使用方法重载和方法重写来实现多态性。另一个例子是说话，人说人话，猫说话可以是：“喵喵”，而狗说话可能是“旺旺”等，说话时表示和声音也不太一样。</p>
<p>参考以下代码 - </p>
<pre><code class="java">public class Circle &#123;

    public void draw()&#123;
        System.out.println(&quot;绘制圆形，默认颜色为黑色，直径为1厘米。&quot;);
    &#125;

    public void draw(int diameter)&#123;
        System.out.println(&quot;绘制圆形，默认颜色为黑色，直径为 &quot;+diameter+&quot;  厘米。&quot;);
    &#125;

    public void draw(int diameter, String color)&#123;
        System.out.println(&quot;绘制圆形，颜色为 &quot;+color+&quot; ，直径为  &quot;+diameter+&quot; 厘米。&quot;);
    &#125;
&#125;
Java
</code></pre>
<p>这里有多种<code>draw()</code>方法，它们都有不同的行为。这是方法重载的一种情况，因为所有方法名称都相同且参数不同。这里编译器将能够识别在编译时调用的方法，因此这也称为<strong>编译时多态</strong>。</p>
<p>当在对象之间具有“IS-A”关系时，实现运行时多态性。这也称为<strong>方法重写</strong>，因为子类必须覆盖超类方法。</p>
<p>如果在超类中，实际的实现类是在运行时决定的。编译器无法决定将调用哪个类方法。此决定在运行时完成，因此这也叫作<strong>运行时多态</strong>或<strong>动态方法分派</strong>。</p>
<p><strong>方法重写示例</strong></p>
<p><strong>类：Shape.java</strong></p>
<pre><code class="java">public interface Shape &#123;

    public void draw();
&#125;
Java
</code></pre>
<p><strong>类：Circle.java</strong></p>
<pre><code class="java">public class Circle implements Shape&#123;

    @Override
    public void draw()&#123;
        System.out.println(&quot;绘制圆形&quot;);
    &#125;
&#125;
Java
</code></pre>
<p>*<em>类：</em>Square.java*</p>
<pre><code class="java">public class Square implements Shape &#123;

    @Override
    public void draw() &#123;
        System.out.println(&quot;绘制长方形&quot;);
    &#125;

&#125;
Java
</code></pre>
<p><code>Shape</code>是超类，它有两个子类<code>Circle</code>和<code>Square</code>，下面是运行时多态性的示例。</p>
<p><strong>类：PolymorphismTest.java</strong></p>
<pre><code class="java">public class PolymorphismTest &#123;

    public static void main(String args[])&#123;
        Shape sh = new Circle();
        sh.draw();

        Shape sh1 = getShape(); //一些确定形状的第三方逻辑
        sh1.draw();
    &#125;
&#125;
Java
</code></pre>
<p>在上面的示例中，java编译器不知道在运行时使用的是哪个<code>Shape</code>的实现类，因此运行时多态性。</p>
<h4 id="1-5-抽象"><a href="#1-5-抽象" class="headerlink" title="1.5. 抽象"></a>1.5. 抽象</h4><p>隐藏内部细节和显示功能称为<strong>抽象</strong>。例如：电话，但我们不知道内部是如何处理通话/通信的。</p>
<p>抽象是隐藏内部细节和用简单的术语描述事物的概念。例如，添加两个整数的方法。该方法的内部处理对外界是隐藏的。有许多方法可以在面向对象的程序中实现抽象，例如封装和继承。</p>
<p>Java程序也是抽象的一个很好的例子。这里java负责将简单语句转换为机器语言，并隐藏外部世界的内部实现细节。</p>
<h4 id="1-6-封装"><a href="#1-6-封装" class="headerlink" title="1.6. 封装"></a>1.6. 封装</h4><p>将代码和数据绑定(或包装)在一起成为单个单元称为<strong>封装</strong>。例如：胶囊，它包裹着不同的药物。</p>
<p>一个java类是封装的例子。Java bean是完全封装的类，因为所有的数据成员在这里是私有的。</p>
<p>封装是用于在面向对象编程中实现抽象的技术。封装用于对类成员和方法的访问限制。</p>
<p>访问修饰符关键字用于面向对象编程中的封装。例如，java中的封装是使用<code>private</code>，<code>protected</code>和<code>public</code>关键字实现的。</p>
<h4 id="1-7-组合"><a href="#1-7-组合" class="headerlink" title="1.7. 组合"></a>1.7. 组合</h4><p>组合是聚合的特例。组合是一种更具限制性的聚合形式。当“HAS-A”关系中包含的对象不能独立存在时，那就是组合的情况。例如，房子里有房间。没有房子，这里的房间不可能存在。</p>
<h2 id="2-面向对象编程的优点"><a href="#2-面向对象编程的优点" class="headerlink" title="2. 面向对象编程的优点"></a>2. 面向对象编程的优点</h2><ol>
<li>OOP使开发和维护变得更容易，因为在面向过程的编程语言中，如果代码随着项目规模的增长而增长，则不容易管理。</li>
<li>OOP提供数据隐藏，而在面向过程的编程语言中，可以从任何地方访问全局数据。</li>
<li>OOP提供更有效地模拟真实世界事件的能力。如果使用面向对象的编程语言，我们可以提供真实世界里的问题的解决方案。</li>
</ol>
<p><img src="http://www.yiibai.com/uploads/images/201703/0303/507110351_80525.png" alt="img"></p>
<h1 id="Java命名约定"><a href="#Java命名约定" class="headerlink" title="Java命名约定"></a>Java命名约定</h1><p>Java命名约定是一个规则，决定标识符使用什么命名规则，如类，包，变量，常量，方法等的命名规则。</p>
<p>但是，它并不是强制要求必须遵循。这称为约定不规则。</p>
<p>java编程语言的所有类，接口，包，方法和字段都是根据java命名约定给出的。</p>
<h2 id="java命名约定的优点"><a href="#java命名约定的优点" class="headerlink" title="java命名约定的优点"></a>java命名约定的优点</h2><p>通过使用标准的Java命名约定，您可以使自己和其他程序员更容易阅读代码。Java程序的可读性非常重要。 它能让程序开发者花费更少的时间来读懂代码的作用。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>约定</th>
</tr>
</thead>
<tbody><tr>
<td>类名称</td>
<td>应以大写字母开头，并成为容易理解的名词或组合。如：<code>String</code>, <code>Color</code>, <code>Button</code>, <code>System</code>, <code>Thread</code>等。</td>
</tr>
<tr>
<td>接口名称</td>
<td>应以大写字母开头，并作为形容词。如： <code>Runnable</code>，<code>Remote</code>，<code>ActionListener</code>等。</td>
</tr>
<tr>
<td>方法名称</td>
<td>应以小写字母开头，并作为动词。如：<code>actionPerformed()</code>，<code>main()</code>，<code>print()</code>，<code>println()</code>等。</td>
</tr>
<tr>
<td>变量名称</td>
<td>应以小写字母开头。如：<code>firstName</code>，<code>orderNumber</code>等。</td>
</tr>
<tr>
<td>包名称</td>
<td>应使用小写字母。如： <code>java</code>，<code>lang</code>，<code>sql</code>，<code>util</code>等。</td>
</tr>
<tr>
<td>常量名称</td>
<td>应使用大写字母。 例如：<code>RED</code>, <code>YELLOW</code>, <code>MAX_PRIORITY</code>等</td>
</tr>
</tbody></table>
<h2 id="java的驼峰命名规则"><a href="#java的驼峰命名规则" class="headerlink" title="java的驼峰命名规则"></a>java的驼峰命名规则</h2><p>Java遵循驼峰语法，用于命名类，接口，方法和变量。</p>
<p>如果名称是使用两个单词组合，则第二个单词将以大写字母开头。例如：<code>actionPerformed()</code>，<code>firstName</code>，<code>ActionEvent</code>，<code>ActionListener</code>等。</p>
<h1 id="Java对象和类-1"><a href="#Java对象和类-1" class="headerlink" title="Java对象和类"></a>Java对象和类</h1><p>在本节教程中，我们将学习Java对象和类。在面向对象编程技术中，需要设计和使用对象和类的程序。对象是物理和逻辑实体，而类是逻辑实体。</p>
<blockquote>
<p><strong>提醒：</strong>对于Java初学者来说，对象和类是一个十分重要的概念，能否理解和掌握对之后其他Java知识有直接影响。所以，虽然本节的内容比较多，但建议认真阅读并理解，最好能结合手动实现本节中的所有示例代码。</p>
</blockquote>
<h2 id="1-Java中的对象"><a href="#1-Java中的对象" class="headerlink" title="1. Java中的对象"></a>1. Java中的对象</h2><p>具有状态和行为的实体可称为<strong>对象</strong>(女朋友也可以叫<strong>对象</strong>)。 椅子，自行车，标记，笔，桌子，汽车等。它可以是物理或逻辑(有形和无形)。 无形对象的例子是银行系统。</p>
<p>一个对象有三个特点：</p>
<ul>
<li><strong>状态：</strong> 表示一个对象的数据(值)。</li>
<li><strong>行为：</strong> 表示对象的行为(功能)，例如：存款，取款等。</li>
<li><strong>标识：</strong> 对象标识通常通过唯一ID实现。该<code>ID</code>的值对外部用户不可见。 但是，它由JVM内部使用来唯一地标识每个对象。</li>
</ul>
<p><strong>例如：</strong> <strong>汽车</strong>是一个对象。它的名字是：<strong>捷达</strong>，颜色是白色等这些就是它的状态(数据值)。它用于<strong>跑路</strong>，所以<strong>跑路</strong>就是它的行为。</p>
<p><strong>对象</strong>是<strong>类</strong>的一个实例。 类是创建对象的模板或蓝图。 所以对象是一个类的实例。</p>
<p><strong>对象定义：</strong></p>
<ul>
<li>对象是一个现实世界的实体。</li>
<li>对象是一个运行时实体。</li>
<li>对象是具有状态和行为的实体。</li>
<li>对象是类的一个实例。</li>
</ul>
<h2 id="2-Java中的类"><a href="#2-Java中的类" class="headerlink" title="2. Java中的类"></a>2. Java中的类</h2><p>类是具有共同属性的一组对象。它是创建对象的模板或蓝图。它是一个逻辑实体。 它不能是物理存在的实体。</p>
<p><strong>Java中的类可以包含：</strong></p>
<ul>
<li>字段</li>
<li>方法</li>
<li>构造函数</li>
<li>代码块</li>
<li>嵌套类和接口</li>
</ul>
<p><strong>声明一个类的语法：</strong></p>
<pre><code class="java">class &lt;class_name&gt;&#123;  
    field;  
    method;  
&#125;
Java
</code></pre>
<h3 id="2-1-Java中的实例变量"><a href="#2-1-Java中的实例变量" class="headerlink" title="2.1. Java中的实例变量"></a>2.1. Java中的实例变量</h3><p>实例变量在类内部，但在方法外部定义的变量称为实例变量。 实例变量在编译时不获取内存。 它在运行时获取对象(实例)创建时的内存。 这是为什么，它被称为实例变量。</p>
<h3 id="2-2-Java中的方法"><a href="#2-2-Java中的方法" class="headerlink" title="2.2. Java中的方法"></a>2.2. Java中的方法</h3><p>在java中的方法类似函数，用于暴露对象的行为。</p>
<p><strong>方法的优点</strong></p>
<ul>
<li>代码可重用性</li>
<li>代码优化</li>
</ul>
<h3 id="2-3-Java中的new关键字"><a href="#2-3-Java中的new关键字" class="headerlink" title="2.3. Java中的new关键字"></a>2.3. Java中的new关键字</h3><p><code>new</code>关键字用于在运行时分配内存。所有对象在堆内存区域中获取内存。</p>
<h3 id="2-4-对象和类示例：-main方法和类"><a href="#2-4-对象和类示例：-main方法和类" class="headerlink" title="2.4. 对象和类示例： main方法和类"></a>2.4. 对象和类示例： main方法和类</h3><p>在这个例子中，我们创建了一个有两个数据成员:<code>id</code>和<code>name</code>的<code>Student</code>类。并通过使用<code>new</code>关键字创建<code>Student</code>类的对象，并打印对象的值。</p>
<p>这里，在类中创建<code>main()</code>方法。<code>Student.java</code> 类文件的代码如下 -</p>
<pre><code class="java">class Student &#123;
    int id;// field or data member or instance variable
    String name;

    public static void main(String args[]) &#123;
        Student s1 = new Student();// creating an object of Student
        System.out.println(s1.id);// accessing member through reference variable
        System.out.println(s1.name);
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行结果如下 -</p>
<pre><code class="java">0 
null
Java
</code></pre>
<h3 id="2-5-对象和类示例：main方法在类外部"><a href="#2-5-对象和类示例：main方法在类外部" class="headerlink" title="2.5. 对象和类示例：main方法在类外部"></a>2.5. 对象和类示例：main方法在类外部</h3><p>在真实的开发中，我们一般创建类并从另一个类中使用它。这是比上面的在同一个类中更好的方法。 让我们来看一个简单的例子，在另一个类中有<code>main()</code>方法创建其它类。<br>在不同的java文件或单个java文件中有多个类。 如果在单个java源文件中定义多个类，则最好使用带有<code>main()</code>方法的类名作为保存的文件名。下面来看一个名称为 <code>TestStudent1.java</code> 的文件中的代码：</p>
<pre><code class="java">class Student &#123;
    int id;
    String name;
&#125;

class TestStudent1 &#123;
    public static void main(String args[]) &#123;
        Student s1 = new Student();
        System.out.println(s1.id);
        System.out.println(s1.name);
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，得到以下结果 - </p>
<pre><code class="java">0 
null
Java
</code></pre>
<h2 id="3-初始化对象"><a href="#3-初始化对象" class="headerlink" title="3. 初始化对象"></a>3. 初始化对象</h2><p>在java中初始化对象有<code>3</code>种方式，它们分别如下 - </p>
<ol>
<li>通过引用变量初始化对象</li>
<li>通过方法初始化对象</li>
<li>通过构造函数初始化对象</li>
</ol>
<h3 id="3-1-通过引用变量初始化对象"><a href="#3-1-通过引用变量初始化对象" class="headerlink" title="3.1. 通过引用变量初始化对象"></a>3.1. 通过引用变量初始化对象</h3><p>初始化对象仅仅是将数据初步地存储到对象中。下面来看看一个简单的例子，通过引用变量初始化对象。这里创建一个 <code>TestStudent2.java</code> 类文件，代码如下：</p>
<pre><code class="java">class Student &#123;
    int id;
    String name;
&#125;

class TestStudent2 &#123;
    public static void main(String args[]) &#123;
        Student s1 = new Student();
        s1.id = 101;
        s1.name = &quot;Sonoo&quot;;
        System.out.println(s1.id + &quot; &quot; + s1.name);// printing members with a
                                                    // white space
    &#125;
&#125;
Java
</code></pre>
<p>上面代码输出结果如下 - </p>
<pre><code class="java">101 Sonoo
Java
</code></pre>
<p>还可以通过引用变量创建多个对象并存储信息在这些对象。这里创建一个 <code>TestStudent3.java</code> 类文件，代码如下：</p>
<pre><code class="java">class Student &#123;
    int id;
    String name;
&#125;

class TestStudent3 &#123;
    public static void main(String args[]) &#123;
        // Creating objects
        Student s1 = new Student();
        Student s2 = new Student();
        // Initializing objects
        s1.id = 101;
        s1.name = &quot;Sonoo&quot;;
        s2.id = 102;
        s2.name = &quot;Amit&quot;;
        // Printing data
        System.out.println(s1.id + &quot; &quot; + s1.name);
        System.out.println(s2.id + &quot; &quot; + s2.name);
    &#125;
&#125;
Java
</code></pre>
<p>上面代码输出结果如下 - </p>
<pre><code class="java">101 Sonoo
102 Amit
Java
</code></pre>
<h3 id="3-2-通过方法初始化对象"><a href="#3-2-通过方法初始化对象" class="headerlink" title="3.2. 通过方法初始化对象"></a>3.2. 通过方法初始化对象</h3><p>在本示例中，将创建<code>Student</code>类的两个对象，并通过调用<code>insertRecord</code>方法来初始化这些对象的值。并通过调用<code>displayInformation()</code>方法显示对象的状态(数据)。这里创建一个 <code>TestStudent4.java</code> 类文件，代码如下：</p>
<pre><code class="java">class Student &#123;
    int rollno;
    String name;

    void insertRecord(int r, String n) &#123;
        rollno = r;
        name = n;
    &#125;

    void displayInformation() &#123;
        System.out.println(rollno + &quot; &quot; + name);
    &#125;
&#125;

class TestStudent4 &#123;
    public static void main(String args[]) &#123;
        Student s1 = new Student();
        Student s2 = new Student();
        s1.insertRecord(111, &quot;Karan&quot;);
        s2.insertRecord(222, &quot;Aryan&quot;);
        s1.displayInformation();
        s2.displayInformation();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，得到如下结果 - </p>
<pre><code class="java">111 Karan
222 Aryan
Java
</code></pre>
<p>创建对象的示意如下 -</p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0403/476070349_62943.jpg" alt="img"></p>
<p>从上图可以看出，对象在堆内存区域获取内存。 引用变量指的是在堆内存区域中分配的对象。 这里，<code>s1</code>和<code>s2</code>都是引用存储器中分配的对象的引用变量。</p>
<h3 id="3-3-通过构造函数初始化对象"><a href="#3-3-通过构造函数初始化对象" class="headerlink" title="3.3. 通过构造函数初始化对象"></a>3.3. 通过构造函数初始化对象</h3><p>有关于通过构造函数初始化对象，我们将在后面的Java构造函数中学习。</p>
<h3 id="3-3-1-对象和类示例：Employee"><a href="#3-3-1-对象和类示例：Employee" class="headerlink" title="3.3.1. 对象和类示例：Employee"></a>3.3.1. 对象和类示例：Employee</h3><p>下面我们来看看一个例子，实现维护员工信息的记录。这里创建一个 <code>TestEmployee.java</code> 类文件，代码如下所示 -</p>
<pre><code class="java">class Employee &#123;
    int id;
    String name;
    float salary;

    void insert(int i, String n, float s) &#123;
        id = i;
        name = n;
        salary = s;
    &#125;

    void display() &#123;
        System.out.println(id + &quot; &quot; + name + &quot; &quot; + salary);
    &#125;
&#125;

public class TestEmployee &#123;
    public static void main(String[] args) &#123;
        Employee e1 = new Employee();
        Employee e2 = new Employee();
        Employee e3 = new Employee();
        e1.insert(101, &quot;ajeet&quot;, 45000);
        e2.insert(102, &quot;irfan&quot;, 25000);
        e3.insert(103, &quot;nakul&quot;, 55000);
        e1.display();
        e2.display();
        e3.display();
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行得到结果如下 - </p>
<pre><code class="java">101 ajeet 45000.0
102 irfan 25000.0
103 nakul 55000.0
Java
</code></pre>
<h3 id="3-3-2-对象和类示例：Rectangle"><a href="#3-3-2-对象和类示例：Rectangle" class="headerlink" title="3.3.2. 对象和类示例：Rectangle"></a>3.3.2. 对象和类示例：Rectangle</h3><p>还有另一个维护<code>Rectangle</code>类记录的例子。这里创建一个 <code>TestRectangle1.java</code> 类文件，代码如下所示 -</p>
<pre><code class="java">class Rectangle &#123;
    int length;
    int width;

    void insert(int l, int w) &#123;
        length = l;
        width = w;
    &#125;

    void calculateArea() &#123;
        System.out.println(length * width);
    &#125;
&#125;

class TestRectangle1 &#123;
    public static void main(String args[]) &#123;
        Rectangle r1 = new Rectangle();
        Rectangle r2 = new Rectangle();
        r1.insert(11, 5);
        r2.insert(3, 15);
        r1.calculateArea();
        r2.calculateArea();
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行得到结果如下 - </p>
<pre><code class="java">55 
45
Java
</code></pre>
<h2 id="在Java中创建对象的不同方法有哪些？"><a href="#在Java中创建对象的不同方法有哪些？" class="headerlink" title="在Java中创建对象的不同方法有哪些？"></a>在Java中创建对象的不同方法有哪些？</h2><p>在java中有很多方法可以用来创建对象。它们分别是：</p>
<ul>
<li>通过<code>new</code>关键字</li>
<li>通过<code>newInstance()</code>方法</li>
<li>通过<code>clone()</code>方法</li>
<li>通过反序列化</li>
<li>通过工厂方法等</li>
</ul>
<p>在接下来的章节中，将学习这些方法用来创建对象。</p>
<h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><p>匿名只是表示没有名。没有引用的对象(也就是不使用实例变量)称为匿名对象。它只能在创建对象时使用。如果只需要使用一个对象，匿名对象是一个很好的方法。 例如：</p>
<pre><code class="java">new Calculation();//匿名对象
Calculation c = new Calculation();// 使用实例变量，所以不是匿名对象
Java
</code></pre>
<p>调用方法通过引用：</p>
<pre><code class="java">Calculation c = new Calculation();  
c.fact(5);
Java
</code></pre>
<p>通过匿名对象调用方法：</p>
<pre><code class="java">new Calculation().fact(5);
Java
</code></pre>
<p>下面来看看java中的匿名对象的完整示例。</p>
<pre><code class="java">class Calculation &#123;
    void fact(int n) &#123;
        int fact = 1;
        for (int i = 1; i &lt;= n; i++) &#123;
            fact = fact * i;
        &#125;
        System.out.println(&quot;factorial is &quot; + fact);
    &#125;

    public static void main(String args[]) &#123;
        new Calculation().fact(5);// calling method with anonymous object
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行得到结果如下 - </p>
<pre><code class="java">Factorial is 120
Java
</code></pre>
<h2 id="仅创建同个类型的多个对象"><a href="#仅创建同个类型的多个对象" class="headerlink" title="仅创建同个类型的多个对象"></a>仅创建同个类型的多个对象</h2><p>可以按照一种类型创建多个对象，就像在原始数据类型中的情况中一样。<br>原始变量的初始化：</p>
<pre><code class="java">int a=10, b=20;
Java
</code></pre>
<p>引用变量的初始化：</p>
<pre><code class="java">Rectangle r1=new Rectangle(), r2=new Rectangle();//creating two objects
Java
</code></pre>
<p>下面再看看一个例子：</p>
<pre><code class="java">class Rectangle &#123;
    int length;
    int width;

    void insert(int l, int w) &#123;
        length = l;
        width = w;
    &#125;

    void calculateArea() &#123;
        System.out.println(length * width);
    &#125;
&#125;

class TestRectangle2 &#123;
    public static void main(String args[]) &#123;
        Rectangle r1 = new Rectangle(), r2 = new Rectangle();// creating two
                                                                // objects
        r1.insert(11, 5);
        r2.insert(3, 15);
        r1.calculateArea();
        r2.calculateArea();
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行得到结果如下 - </p>
<pre><code class="java">55 
45
Java
</code></pre>
<h2 id="真实的应用示例-Account"><a href="#真实的应用示例-Account" class="headerlink" title="真实的应用示例: Account"></a>真实的应用示例: Account</h2><p>在本节的最后部分，我们来看看一个真实应用中的示例，模拟银行账户转帐的实现。这里创建一个 <code>TestAccount.java</code> 类文件，代码如下所示 -</p>
<pre><code class="java">class Account &#123;
    int acc_no;
    String name;
    float amount;

    void insert(int a, String n, float amt) &#123;
        acc_no = a;
        name = n;
        amount = amt;
    &#125;

    void deposit(float amt) &#123;
        amount = amount + amt;
        System.out.println(amt + &quot; deposited&quot;);
    &#125;

    void withdraw(float amt) &#123;
        if (amount &lt; amt) &#123;
            System.out.println(&quot;Insufficient Balance&quot;);
        &#125; else &#123;
            amount = amount - amt;
            System.out.println(amt + &quot; withdrawn&quot;);
        &#125;
    &#125;

    void checkBalance() &#123;
        System.out.println(&quot;Balance is: &quot; + amount);
    &#125;

    void display() &#123;
        System.out.println(acc_no + &quot; &quot; + name + &quot; &quot; + amount);
    &#125;
&#125;

class TestAccount &#123;
    public static void main(String[] args) &#123;
        Account a1 = new Account();
        a1.insert(832345, &quot;Ankit&quot;, 1000);
        a1.display();
        a1.checkBalance();
        a1.deposit(40000);
        a1.checkBalance();
        a1.withdraw(15000);
        a1.checkBalance();
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行得到结果如下 - </p>
<pre><code class="java">832345 Ankit 1000.0
Balance is: 1000.0
40000.0 deposited
Balance is: 41000.0
15000.0 withdrawn
Balance is: 26000.0
</code></pre>
<h1 id="Java构造器（构造方法）"><a href="#Java构造器（构造方法）" class="headerlink" title="Java构造器（构造方法）"></a>Java构造器（构造方法）</h1><p>java中的构造方法是一种特殊类型的方法，用于初始化对象。Java构造函数在对象创建时被调用。 它构造值，即提供对象的数据，这是为什么它被称为构造函数。</p>
<h2 id="创建java构造函数的规则"><a href="#创建java构造函数的规则" class="headerlink" title="创建java构造函数的规则"></a>创建java构造函数的规则</h2><p>构造函数基本上定义了两个规则。它们分别如下 -</p>
<ol>
<li>构造函数名称必须与其类名称相同</li>
<li>构造函数必须没有显式返回类型</li>
</ol>
<h2 id="Java构造函数的类型"><a href="#Java构造函数的类型" class="headerlink" title="Java构造函数的类型"></a>Java构造函数的类型</h2><p>有两种类型的构造函数：</p>
<ol>
<li>默认构造函数(无参数构造函数)</li>
<li>参数化构造函数</li>
</ol>
<p><img src="http://www.yiibai.com/uploads/images/201703/0403/511080330_21862.png" alt="img"></p>
<h3 id="1-Java默认构造函数-无参数构造函数"><a href="#1-Java默认构造函数-无参数构造函数" class="headerlink" title="1. Java默认构造函数(无参数构造函数)"></a>1. Java默认构造函数(无参数构造函数)</h3><p>没有参数的构造函数称为默认构造函数。默认构造函数的语法如下：</p>
<pre><code class="java">&lt;class_name&gt;()&#123;&#125;
Java
</code></pre>
<p><strong>默认构造函数的示例：</strong></p>
<p>在这个例子中，在<code>Bike</code>类中创建了无参数(no-arg)构造函数。它将在对象创建时被调用。</p>
<pre><code class="java">class Bike1 &#123;
    Bike1() &#123;
        System.out.println(&quot;Bike is created&quot;);
    &#125;

    public static void main(String args[]) &#123;
        Bike1 b = new Bike1();
    &#125;
&#125;
Java
</code></pre>
<p>上面的示例代码运行结果如下 - </p>
<pre><code class="java">Bike is created
Java
</code></pre>
<blockquote>
<p>规则：如果类中没有构造函数，编译器会自动创建一个默认构造函数。</p>
</blockquote>
<p><strong>问题：</strong> 默认构造函数的目的是什么？</p>
<p>默认构造函数根据类型为对象提供默认值，如：<code>0</code>，<code>null</code>等。</p>
<p><strong>显示默认值的默认构造函数示例</strong></p>
<pre><code class="java">class Student3 &#123;
    int id;
    String name;

    void display() &#123;
        System.out.println(id + &quot; &quot; + name);
    &#125;

    public static void main(String args[]) &#123;
        Student3 s1 = new Student3();
        Student3 s2 = new Student3();
        s1.display();
        s2.display();
    &#125;
&#125;
Java
</code></pre>
<p>运行上面代码，得到如下结果 - </p>
<pre><code class="java">0 null
0 null
Java
</code></pre>
<p><strong>解释：</strong> 在上面的类中，代码中并没有创建任何构造函数，但编译器自动提供了一个默认构造函数。默认构造函数分别为字段：<code>id</code> 和 <code>name</code> 分别提供了<code>0</code>和<code>null</code>值。</p>
<h3 id="2-Java参数化构造函数"><a href="#2-Java参数化构造函数" class="headerlink" title="2. Java参数化构造函数"></a>2. Java参数化构造函数</h3><p>具有参数的构造函数称为参数化构造函数。</p>
<p><strong>问题：</strong> 为什么使用参数化构造函数？<br><strong>回答：</strong> 参数化构造函数用于为不同对象提供不同初始化的值。</p>
<p><strong>参数化构造函数的示例</strong><br>在这个例子中，我们创建了具有两个参数的<code>Student</code>类的构造函数。构造函数中柯有任意数量的参数。</p>
<pre><code class="java">class Student4 &#123;
    int id;
    String name;

    Student4(int i, String n) &#123;
        id = i;
        name = n;
    &#125;

    void display() &#123;
        System.out.println(id + &quot; &quot; + name);
    &#125;

    public static void main(String args[]) &#123;
        Student4 s1 = new Student4(111, &quot;Karan&quot;);
        Student4 s2 = new Student4(222, &quot;Aryan&quot;);
        s1.display();
        s2.display();
    &#125;
&#125;
Java
</code></pre>
<p>运行上面代码，得到如下结果 - </p>
<pre><code class="java">111 Karan
222 Aryan
Java
</code></pre>
<h2 id="Java构造函数重载"><a href="#Java构造函数重载" class="headerlink" title="Java构造函数重载"></a>Java构造函数重载</h2><p>构造方法重载是Java中的一种技术，一个类可以有任何数量的参数列表不同的构造函数。编译器通过构造函数参数列表中的参数数量及其类型来区分这些构造函数。</p>
<p><strong>构造函数重载示例</strong></p>
<pre><code class="java">class Student5 &#123;
    int id;
    String name;
    int age;

    Student5(int i, String n) &#123;
        id = i;
        name = n;
    &#125;

    Student5(int i, String n, int a) &#123;
        id = i;
        name = n;
        age = a;
    &#125;

    void display() &#123;
        System.out.println(id + &quot; &quot; + name + &quot; &quot; + age);
    &#125;

    public static void main(String args[]) &#123;
        Student5 s1 = new Student5(111, &quot;Karan&quot;);
        Student5 s2 = new Student5(222, &quot;Aryan&quot;, 25);
        s1.display();
        s2.display();
    &#125;
&#125;
Java
</code></pre>
<p>上面示例代码，执行后输出结果如下 - </p>
<pre><code class="java">111 Karan 0
222 Aryan 25
Java
</code></pre>
<h2 id="java的构造函数和方法之间的区别"><a href="#java的构造函数和方法之间的区别" class="headerlink" title="java的构造函数和方法之间的区别"></a>java的构造函数和方法之间的区别</h2><p>构造函数和方法之间有许多区别，它们如下面列出 - </p>
<table>
<thead>
<tr>
<th>Java构造函数</th>
<th>Java方法</th>
</tr>
</thead>
<tbody><tr>
<td>构造器用于初始化对象的状态(数据)。</td>
<td>方法用于暴露对象的行为。</td>
</tr>
<tr>
<td>构造函数不能有返回类型。</td>
<td>方法一般都有返回类型。</td>
</tr>
<tr>
<td>构造函数隐式调用。</td>
<td>方法要显式调用。</td>
</tr>
<tr>
<td>如果没有指定任何构造函数，java编译器提供一个默认构造函数。</td>
<td>在任何情况下编译器都不会提供默认的方法调用。</td>
</tr>
<tr>
<td>构造函数名称必须与类名称相同。</td>
<td>方法名称可以或可以不与类名称相同(随意)。</td>
</tr>
</tbody></table>
<h2 id="Java拷贝构造函数"><a href="#Java拷贝构造函数" class="headerlink" title="Java拷贝构造函数"></a>Java拷贝构造函数</h2><p>在Java中没有复制构造函数。但是可以将一个对象的值复制到另一个中，就像C++中的复制构造函数。</p>
<p>在java中有很多方法可以将一个对象的值复制到另一个对象中。它们分别是：</p>
<ul>
<li>通过构造函数</li>
<li>通过将一个对象的值分配给另一个对象</li>
<li>通过Object类的<code>clone()</code>方法</li>
</ul>
<p>在这个例子中，使用java构造函数将一个对象的值复制到另一个对象中。</p>
<pre><code class="java">class Student6 &#123;
    int id;
    String name;

    Student6(int i, String n) &#123;
        id = i;
        name = n;
    &#125;

    Student6(Student6 s) &#123;
        id = s.id;
        name = s.name;
    &#125;

    void display() &#123;
        System.out.println(id + &quot; &quot; + name);
    &#125;

    public static void main(String args[]) &#123;
        Student6 s1 = new Student6(111, &quot;Karan&quot;);
        Student6 s2 = new Student6(s1);
        s1.display();
        s2.display();
    &#125;
&#125;
Java
</code></pre>
<p>上面示例代码，执行后输出结果如下 - </p>
<pre><code class="java">111 Karan
111 Karan
Java
</code></pre>
<p><strong>不使用构造函数复制值</strong></p>
<p>可以通过将对象值分配给另一个对象，将一个对象的值复制到另一个对象中。 在这种情况下，不需要创建构造函数。</p>
<pre><code class="java">class Student7 &#123;
    int id;
    String name;

    Student7(int i, String n) &#123;
        id = i;
        name = n;
    &#125;

    Student7() &#123;
    &#125;

    void display() &#123;
        System.out.println(id + &quot; &quot; + name);
    &#125;

    public static void main(String args[]) &#123;
        Student7 s1 = new Student7(111, &quot;Karan&quot;);
        Student7 s2 = new Student7();
        s2.id = s1.id;
        s2.name = s1.name;
        s1.display();
        s2.display();
    &#125;
&#125;
Java
</code></pre>
<p>上面示例代码，执行后输出结果如下 - </p>
<pre><code class="java">111 Karan
111 Karan
Java
</code></pre>
<p><strong>问题1：</strong> 构造函数有返回值 ？</p>
<p><strong>回答：</strong>  是的，构造函数返回当前类的实例(不能指定返回值类型，但它会返回一个值)。</p>
<p><strong>问题2：</strong> 可以构造函数执行其他任务而不是初始化？</p>
<p><strong>回答：</strong>  是的，比如：对象创建，启动线程，调用方法等。你可以像在方法中执行的任何操作一样，在构造函数中也可以做到这些。</p>
<h1 id="Java-static关键字"><a href="#Java-static关键字" class="headerlink" title="Java static关键字"></a>Java static关键字</h1><p>java中的<code>static</code>关键字主要用于内存管理。我们可以应用java <code>static</code>关键字在变量，方法，块和嵌套类中。 <code>static</code>关键字属于类，而不是类的实例。</p>
<p>静态(<code>static</code>)可以是：</p>
<ol>
<li>变量(也称为类变量)</li>
<li>方法(也称为类方法)</li>
<li>代码块</li>
<li>嵌套类</li>
</ol>
<h2 id="1-Java静态变量"><a href="#1-Java静态变量" class="headerlink" title="1. Java静态变量"></a>1. Java静态变量</h2><p>如果将一个变量声明为<code>static</code>，它就是所谓的静态变量了。</p>
<ul>
<li>静态变量可以用于引用所有对象的公共属性(对于每个对象不是唯一的)。如：员工公司名称，学生所在的大学名称。</li>
</ul>
<p><strong>静态变量的优点：</strong></p>
<ul>
<li>它能使程序存储器高效(即它节省内存)。</li>
</ul>
<p><strong>理解不使用静态变量的问题</strong></p>
<pre><code class="java">class Student&#123;  
     int rollno;  
     String name;  
     String college=&quot;ITS&quot;;  
&#125;
Java
</code></pre>
<p>假设在一所学校有<code>500</code>名学生，现在所有实例数据成员将在每次创建对象时获取内存。所有学生都有其唯一的注册ID：<code>rollno</code>和　<code>name</code> ，因此实例数据成员没有什么问题。<code>college</code> 指的是所有对象的共同属性。如果使它静态化(使用<code>static</code>关键字修饲)，这个字段将只获得内存一次。</p>
<blockquote>
<p>Java静态属性被共享给所有对象。</p>
</blockquote>
<p><strong>静态变量的示例</strong></p>
<pre><code class="java">//Program of static variable  

class Student8 &#123;
    int rollno;
    String name;
    static String college = &quot;ITS&quot;;

    Student8(int r, String n) &#123;
        rollno = r;
        name = n;
    &#125;

    void display() &#123;
        System.out.println(rollno + &quot; &quot; + name + &quot; &quot; + college);
    &#125;

    public static void main(String args[]) &#123;
        Student8 s1 = new Student8(111, &quot;Karan&quot;);
        Student8 s2 = new Student8(222, &quot;Aryan&quot;);

        s1.display();
        s2.display();
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行结果如下 -</p>
<pre><code class="java">111 Karan ITS
222 Aryan ITS
Java
</code></pre>
<p>创建对象示例图如下所示 -</p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0403/117100301_14333.jpg" alt="img"></p>
<p><strong>不使用静态变量的计数器程序</strong></p>
<p>在这个例子中，我们创建了一个名为<code>count</code>的实例变量用来统计创建对象的数目，它在构造函数中执行递增。 由于实例变量在创建对象时要获取内存，每个对象都将具有实例变量的副本，如果它被递增了，它也不会反映到其他对象中。所以每个对象在<code>count</code>变量中的值还是<code>1</code>。</p>
<pre><code class="java">class Counter &#123;
    int count = 0;// will get memory when instance is created

    Counter() &#123;
        count++;
        System.out.println(count);
    &#125;

    public static void main(String args[]) &#123;

        Counter c1 = new Counter();
        Counter c2 = new Counter();
        Counter c3 = new Counter();

    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行结果如下 -</p>
<pre><code class="java">1
1
1
Java
</code></pre>
<p><strong>计数器静态变量的程序</strong><br>如上所述，静态变量将只获取一次内存，如果任何对象更改静态变量的值，它将保留其值，所有实例均可访问同一变量值。</p>
<pre><code class="java">class Counter2 &#123;
    static int count = 0;// will get memory only once and retain its value

    Counter2() &#123;
        count++;
        System.out.println(count);
    &#125;

    public static void main(String args[]) &#123;

        Counter2 c1 = new Counter2();
        Counter2 c2 = new Counter2();
        Counter2 c3 = new Counter2();

    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行结果如下 -</p>
<pre><code class="java">1
2
3
Java
</code></pre>
<h2 id="2-Java静态方法"><a href="#2-Java静态方法" class="headerlink" title="2. Java静态方法"></a>2. Java静态方法</h2><p>如果在任何方法上应用<code>static</code>关键字，此方法称为静态方法。</p>
<ul>
<li>静态方法属于类，而不属于类的对象。</li>
<li>可以直接调用静态方法，而无需创建类的实例。</li>
<li>静态方法可以访问静态数据成员，并可以更改静态数据成员的值。</li>
</ul>
<p><strong>静态方法的示例</strong></p>
<pre><code class="java">//Program of changing the common property of all objects(static field).  

class Student9 &#123;
    int rollno;
    String name;
    static String college = &quot;ITS&quot;;

    static void change() &#123;
        college = &quot;BBDIT&quot;;
    &#125;

    Student9(int r, String n) &#123;
        rollno = r;
        name = n;
    &#125;

    void display() &#123;
        System.out.println(rollno + &quot; &quot; + name + &quot; &quot; + college);
    &#125;

    public static void main(String args[]) &#123;
        Student9.change();

        Student9 s1 = new Student9(111, &quot;Karan&quot;);
        Student9 s2 = new Student9(222, &quot;Aryan&quot;);
        Student9 s3 = new Student9(333, &quot;Sonoo&quot;);

        s1.display();
        s2.display();
        s3.display();
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行输出以下结果 - </p>
<pre><code class="java">111 Karan BBDIT
222 Aryan BBDIT
333 Sonoo BBDIT
Java
</code></pre>
<p><strong>执行正常计算的静态方法的另一个示例:</strong></p>
<pre><code class="java">//Program to get cube of a given number by static method  

class Calculate &#123;
    static int cube(int x) &#123;
        return x * x * x;
    &#125;

    public static void main(String args[]) &#123;
        int result = Calculate.cube(5);
        System.out.println(result);
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行输出以下结果 - </p>
<pre><code class="java">125
Java
</code></pre>
<p><strong>静态方法的限制</strong></p>
<p>静态方法有两个主要限制。它们分别是：</p>
<ul>
<li>静态方法不能直接使用非静态数据成员或调用非静态方法。</li>
<li><code>this</code>和<code>super</code>两个关键字不能在静态上下文中使用。</li>
</ul>
<pre><code class="java">class A &#123;
    int a = 40;// non static

    public static void main(String args[]) &#123;
        System.out.println(a);
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行输出以下结果 - </p>
<pre><code class="java">[编译错误！]Compile Time Error
Java
</code></pre>
<p><strong>为什么java main方法是静态的？</strong></p>
<p>这是因为对象不需要调用静态方法，如果它是非静态方法，jvm首先要创建对象，然后调用main()方法，这将导致额外的内存分配的问题。</p>
<h2 id="3-Java静态块"><a href="#3-Java静态块" class="headerlink" title="3. Java静态块"></a>3. Java静态块</h2><p>Java中的静态块主要有两个作用：</p>
<ul>
<li>用于初始化静态数据成员。</li>
<li>它在类加载时在main方法之前执行。</li>
</ul>
<p><strong>静态块的示例</strong></p>
<pre><code class="java">class A2 &#123;
    static &#123;
        System.out.println(&quot;static block is invoked&quot;);
    &#125;

    public static void main(String args[]) &#123;
        System.out.println(&quot;Hello main&quot;);
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行输出以下结果 - </p>
<pre><code class="java">static block is invoked
Hello main
Java
</code></pre>
<p><strong>可以执行程序没有main()方法吗？</strong><br><strong>答：</strong>是的，一种方式是静态块，但在以前旧的JDK版本中，不是在JDK 1.7。</p>
<pre><code class="java">class A3 &#123;
    static &#123;
        System.out.println(&quot;static block is invoked&quot;);
        System.exit(0);
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行输出以下结果 - </p>
<pre><code class="java">static block is invoked
Java
</code></pre>
<p>在JDK7及以上版本中，输出将为：</p>
<pre><code class="java">错误: 在类 Main 中找不到 main 方法, 请将 main 方法定义为:
   public static void main(String[] args)
</code></pre>
<h1 id="Java-this关键字"><a href="#Java-this关键字" class="headerlink" title="Java this关键字"></a>Java this关键字</h1><p>在java中，<code>this</code>关键字有很多种用法。 在java中，这是一个引用当前对象的引用变量。</p>
<p>java <code>this</code>关键字的用法如下：</p>
<ol>
<li><code>this</code>关键字可用来引用当前类的实例变量。</li>
<li><code>this</code>关键字可用于调用当前类方法(隐式)。</li>
<li><code>this()</code>可以用来调用当前类的构造函数。</li>
<li><code>this</code>关键字可作为调用方法中的参数传递。</li>
<li><code>this</code>关键字可作为参数在构造函数调用中传递。</li>
<li><code>this</code>关键字可用于从方法返回当前类的实例。</li>
</ol>
<blockquote>
<p><strong>建议：</strong>如果你是java初学者，只学习 <code>this</code> 关键字的前三个用法就可以了。</p>
</blockquote>
<p><img src="http://www.yiibai.com/uploads/images/201703/0503/213220320_43861.jpg" alt="img"></p>
<h2 id="1-this：引用当前类的实例变量"><a href="#1-this：引用当前类的实例变量" class="headerlink" title="1. this：引用当前类的实例变量"></a>1. this：引用当前类的实例变量</h2><p><code>this</code>关键字可以用来引用当前类的实例变量。如果实例变量和参数之间存在歧义，则 <code>this</code> 关键字可用于明确地指定类变量以解决歧义问题。</p>
<p><strong>了解没有 this 关键字的问题</strong></p>
<p>下面先来理解一个不使用 <code>this</code> 关键字的示例：</p>
<pre><code class="java">class Student &#123;
    int rollno;
    String name;
    float fee;

    Student(int rollno, String name, float fee) &#123;
        rollno = rollno;
        name = name;
        fee = fee;
    &#125;

    void display() &#123;
        System.out.println(rollno + &quot; &quot; + name + &quot; &quot; + fee);
    &#125;
&#125;

class TestThis1 &#123;
    public static void main(String args[]) &#123;
        Student s1 = new Student(111, &quot;ankit&quot;, 5000f);
        Student s2 = new Student(112, &quot;sumit&quot;, 6000f);
        s1.display();
        s2.display();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码输出结果如下 - </p>
<pre><code class="java">0 null 0.0
0 null 0.0
Java
</code></pre>
<p>在上面的例子中，参数(形式参数)和实例变量(<code>rollno</code>和<code>name</code>)是相同的。 所以要使用<code>this</code>关键字来区分局部变量和实例变量。</p>
<p><strong>使用 this 关键字解决了上面的问题</strong></p>
<pre><code class="java">class Student &#123;
    int rollno;
    String name;
    float fee;

    Student(int rollno, String name, float fee) &#123;
        this.rollno = rollno;
        this.name = name;
        this.fee = fee;
    &#125;

    void display() &#123;
        System.out.println(rollno + &quot; &quot; + name + &quot; &quot; + fee);
    &#125;
&#125;

class TestThis2 &#123;
    public static void main(String args[]) &#123;
        Student s1 = new Student(111, &quot;ankit&quot;, 5000f);
        Student s2 = new Student(112, &quot;sumit&quot;, 6000f);
        s1.display();
        s2.display();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码输出结果如下 - </p>
<pre><code class="java">111 ankit 5000
112 sumit 6000
Java
</code></pre>
<p>如果局部变量(形式参数)和实例变量不同，则不需要像下面的程序一样使用<code>this</code>关键字：</p>
<p><strong>不需要 this 关键字的程序示例</strong></p>
<pre><code class="java">class Student &#123;
    int rollno;
    String name;
    float fee;

    Student(int r, String n, float f) &#123;
        rollno = r;
        name = n;
        fee = f;
    &#125;

    void display() &#123;
        System.out.println(rollno + &quot; &quot; + name + &quot; &quot; + fee);
    &#125;
&#125;

class TestThis3 &#123;
    public static void main(String args[]) &#123;
        Student s1 = new Student(111, &quot;ankit&quot;, 5000f);
        Student s2 = new Student(112, &quot;sumit&quot;, 6000f);
        s1.display();
        s2.display();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码输出结果如下 - </p>
<pre><code class="java">111 ankit 5000
112 sumit 6000
Java
</code></pre>
<blockquote>
<p>对变量使用有意义的名称是一种好的编程习惯。所以使用相同名称的实例变量和参数，并且总是使用<code>this</code>关键字。</p>
</blockquote>
<h2 id="2-this：调用当前类方法"><a href="#2-this：调用当前类方法" class="headerlink" title="2. this：调用当前类方法"></a>2. this：调用当前类方法</h2><p>可以使用<code>this</code>关键字调用当前类的方法。如果不使用<code>this</code>关键字，编译器会在调用方法时自动添加此 <code>this</code> 关键字。我们来看看这个例子。<br><img src="http://www.yiibai.com/uploads/images/201703/0603/406080352_39957.jpg" alt="img"></p>
<p>执行上面代码输出结果如下 - </p>
<pre><code class="java">hello n
hello m
Java
</code></pre>
<h2 id="3-this-：调用当前类的构造函数"><a href="#3-this-：调用当前类的构造函数" class="headerlink" title="3. this()：调用当前类的构造函数"></a>3. this()：调用当前类的构造函数</h2><p><code>this()</code>构造函数调用可以用来调用当前类的构造函数。 它用于重用构造函数。 换句话说，它用于构造函数链接。</p>
<p><strong>从参数化构造函数调用默认构造函数：</strong></p>
<pre><code class="java">class A &#123;
    A() &#123;
        System.out.println(&quot;hello a&quot;);
    &#125;

    A(int x) &#123;
        this();
        System.out.println(x);
    &#125;
&#125;

class TestThis5 &#123;
    public static void main(String args[]) &#123;
        A a = new A(10);
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码输出结果如下 - </p>
<pre><code class="java">hello a
10
Java
</code></pre>
<p><strong>从默认构造函数调用参数化构造函数：</strong></p>
<pre><code class="java">class A &#123;
    A() &#123;
        this(5);
        System.out.println(&quot;hello a&quot;);
    &#125;

    A(int x) &#123;
        System.out.println(x);
    &#125;
&#125;

class TestThis6 &#123;
    public static void main(String args[]) &#123;
        A a = new A();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码输出结果如下 - </p>
<pre><code class="java">5
hello a
Java
</code></pre>
<h3 id="使用this-构造函数调用"><a href="#使用this-构造函数调用" class="headerlink" title="使用this()构造函数调用"></a>使用this()构造函数调用</h3><p><code>this()</code>构造函数调用用于从构造函数重用构造函数。 它维护构造函数之间的链，即它用于构造函数链接。看看下面给出的示例，显示<code>this</code>关键字的实际使用。</p>
<pre><code class="java">class Student &#123;
    int rollno;
    String name, course;
    float fee;

    Student(int rollno, String name, String course) &#123;
        this.rollno = rollno;
        this.name = name;
        this.course = course;
    &#125;

    Student(int rollno, String name, String course, float fee) &#123;
        this(rollno, name, course);// reusing constructor
        this.fee = fee;
    &#125;

    void display() &#123;
        System.out.println(rollno + &quot; &quot; + name + &quot; &quot; + course + &quot; &quot; + fee);
    &#125;
&#125;

class TestThis7 &#123;
    public static void main(String args[]) &#123;
        Student s1 = new Student(111, &quot;ankit&quot;, &quot;java&quot;);
        Student s2 = new Student(112, &quot;sumit&quot;, &quot;java&quot;, 6000f);
        s1.display();
        s2.display();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码输出结果如下 - </p>
<pre><code class="java">111 ankit java null
112 sumit java 6000
Java
</code></pre>
<blockquote>
<p>注意：调用<code>this()</code>必须是构造函数中的第一个语句。</p>
</blockquote>
<p>下面示例为不把 <code>this()</code> 语句放在第一行，因此编译不通过。</p>
<pre><code class="java">class Student &#123;
    int rollno;
    String name, course;
    float fee;

    Student(int rollno, String name, String course) &#123;
        this.rollno = rollno;
        this.name = name;
        this.course = course;
    &#125;

    Student(int rollno, String name, String course, float fee) &#123;
        this.fee = fee;
        this(rollno, name, course);// C.T.Error
    &#125;

    void display() &#123;
        System.out.println(rollno + &quot; &quot; + name + &quot; &quot; + course + &quot; &quot; + fee);
    &#125;
&#125;

class TestThis8 &#123;
    public static void main(String args[]) &#123;
        Student s1 = new Student(111, &quot;ankit&quot;, &quot;java&quot;);
        Student s2 = new Student(112, &quot;sumit&quot;, &quot;java&quot;, 6000f);
        s1.display();
        s2.display();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码输出结果如下 - </p>
<pre><code class="java">Compile Time Error: Call to this must be first statement in constructor
Java
</code></pre>
<h2 id="4-this：作为参数传递给方法"><a href="#4-this：作为参数传递给方法" class="headerlink" title="4. this：作为参数传递给方法"></a>4. this：作为参数传递给方法</h2><p><code>this</code>关键字也可以作为方法中的参数传递。 它主要用于事件处理。 看看下面的一个例子：</p>
<pre><code class="java">class S2 &#123;
    void m(S2 obj) &#123;
        System.out.println(&quot;method is invoked&quot;);
    &#125;

    void p() &#123;
        m(this);
    &#125;

    public static void main(String args[]) &#123;
        S2 s1 = new S2();
        s1.p();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码输出结果如下 - </p>
<pre><code class="java">method is invoked
Java
</code></pre>
<p><strong>这个应用程序可以作为参数传递：</strong></p>
<p>在事件处理(或)的情况下，必须提供一个类的引用到另一个。 它用于在多个方法中重用一个对象。</p>
<h2 id="this：在构造函数调用中作为参数传递"><a href="#this：在构造函数调用中作为参数传递" class="headerlink" title="this：在构造函数调用中作为参数传递"></a>this：在构造函数调用中作为参数传递</h2><p>也可以在构造函数中传递<code>this</code>关键字。 如果必须在多个类中使用一个对象，可以使用这种方式。 看看下面的一个例子：</p>
<pre><code class="java">class B &#123;
    A4 obj;

    B(A4 obj) &#123;
        this.obj = obj;
    &#125;

    void display() &#123;
        System.out.println(obj.data);// using data member of A4 class
    &#125;
&#125;

class A4 &#123;
    int data = 10;

    A4() &#123;
        B b = new B(this);
        b.display();
    &#125;

    public static void main(String args[]) &#123;
        A4 a = new A4();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码输出结果如下 - </p>
<pre><code class="java">10
Java
</code></pre>
<h2 id="6-this关键字用来返回当前类的实例"><a href="#6-this关键字用来返回当前类的实例" class="headerlink" title="6. this关键字用来返回当前类的实例"></a>6. this关键字用来返回当前类的实例</h2><p>可以从方法中 <code>this</code> 关键字作为语句返回。 在这种情况下，方法的返回类型必须是类类型(非原始)。 看看下面的一个例子：</p>
<p><strong>作为语句返回的语法</strong></p>
<pre><code class="java">return_type method_name()&#123;  
    return this;  
&#125;
Java
</code></pre>
<p><strong>从方法中返回为语句的 this 关键字的示例</strong></p>
<pre><code class="java">class A &#123;
    A getA() &#123;
        return this;
    &#125;

    void msg() &#123;
        System.out.println(&quot;Hello java&quot;);
    &#125;
&#125;

class Test1 &#123;
    public static void main(String args[]) &#123;
        new A().getA().msg();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码输出结果如下 - </p>
<pre><code class="java">Hello java
Java
</code></pre>
<p><strong>验证 this 关键字</strong></p>
<p>现在来验证 <code>this</code> 关键字引用当前类的实例变量。 在这个程序中将打印参考变量，这两个变量的输出是相同的。</p>
<pre><code class="java">class A5 &#123;
    void m() &#123;
        System.out.println(this);// prints same reference ID
    &#125;

    public static void main(String args[]) &#123;
        A5 obj = new A5();
        System.out.println(obj);// prints the reference ID
        obj.m();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码输出结果如下 - </p>
<pre><code class="java">A5@22b3ea59
A5@22b3ea59
</code></pre>
<h1 id="Java继承"><a href="#Java继承" class="headerlink" title="Java继承"></a>Java继承</h1><p>Java中的继承是一种机制，表示为一个对象获取父对象的所有属性和行为。</p>
<p>在Java中继承是：可以创建基于现有类构建新的类。 当您从现有类继承时，就可以重复使用父类的方法和字段，也可以在继承的新类中添加新的方法和字段。</p>
<p>继承表示<strong>IS-A</strong>关系，也称为父子关系。</p>
<h2 id="为什么在java中使用继承？"><a href="#为什么在java中使用继承？" class="headerlink" title="为什么在java中使用继承？"></a>为什么在java中使用继承？</h2><p>对于方法覆盖(因此可以实现运行时的多态性)，提高代码可重用性。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写(覆盖)。</p>
<p><strong>Java继承的语法</strong></p>
<pre><code class="java">class Subclass-name extends Superclass-name  
&#123;  
   //methods and fields  
&#125;
Java
</code></pre>
<p><code>extends</code>关键字表示正在从现有类派生创建的新类。 “<code>extends</code>”的含义是增加功能。在Java的术语中，继承的类称为父类或超类，新类称为子或子类。</p>
<p><strong>Java继承示例</strong></p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0603/842090342_85538.jpg" alt="img"></p>
<p>如上图所示，<code>Programmer</code>是子类，<code>Employee</code>是超类。 两个类之间的关系是<code>Programmer IS-A Employee</code>. 它表示 <code>Programmer</code> 是一种 <code>Employee</code> 的类型。</p>
<p>参考下面示例代码的实现 - </p>
<pre><code class="java">class Employee &#123;
    float salary = 40000;
&#125;

class Programmer extends Employee &#123;
    int bonus = 10000;

    public static void main(String args[]) &#123;
        Programmer p = new Programmer();
        System.out.println(&quot;Programmer salary is:&quot; + p.salary);
        System.out.println(&quot;Bonus of Programmer is:&quot; + p.bonus);
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码得到以下结果 - </p>
<pre><code class="java">Programmer salary is:40000.0
Bonus of programmer is:10000
Java
</code></pre>
<p>在上面的例子中，<code>Programmer</code>对象可以访问自身类以及<code>Employee</code>类的字段，即提高了代码可重用性。</p>
<h2 id="java继承类型"><a href="#java继承类型" class="headerlink" title="java继承类型"></a>java继承类型</h2><p>在类的基础上，在java中可以有三种类型的继承：单一，多级和分层。在Java编程中，仅能通过接口支持多重和混合继承。稍后章节中我们将了解学习接口的应用。</p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0603/816090354_21318.jpg" alt="img"></p>
<blockquote>
<p>注意：在java中的类不支持多继承。</p>
</blockquote>
<p>当一个类扩展多个类，即被称为多重继承。 例如：</p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0603/372090352_40634.jpg" alt="img"></p>
<h3 id="1-单一继承示例"><a href="#1-单一继承示例" class="headerlink" title="(1). 单一继承示例"></a>(1). 单一继承示例</h3><p>文件 <code>TestInheritance.java</code> 中的代码如下 - </p>
<pre><code class="java">class Animal &#123;
    void eat() &#123;
        System.out.println(&quot;eating...&quot;);
    &#125;
&#125;

class Dog extends Animal &#123;
    void bark() &#123;
        System.out.println(&quot;barking...&quot;);
    &#125;
&#125;

class TestInheritance &#123;
    public static void main(String args[]) &#123;
        Dog d = new Dog();
        d.bark();
        d.eat();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码得到以下结果 - </p>
<pre><code class="java">barking...
eating...
Java
</code></pre>
<h3 id="2-多级继承示例"><a href="#2-多级继承示例" class="headerlink" title="(2). 多级继承示例"></a>(2). 多级继承示例</h3><p>文件 <code>TestInheritance2.java</code> 中的代码如下 - </p>
<pre><code class="java">class Animal &#123;
    void eat() &#123;
        System.out.println(&quot;eating...&quot;);
    &#125;
&#125;

class Dog extends Animal &#123;
    void bark() &#123;
        System.out.println(&quot;barking...&quot;);
    &#125;
&#125;

class BabyDog extends Dog &#123;
    void weep() &#123;
        System.out.println(&quot;weeping...&quot;);
    &#125;
&#125;

class TestInheritance2 &#123;
    public static void main(String args[]) &#123;
        BabyDog d = new BabyDog();
        d.weep();
        d.bark();
        d.eat();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码得到以下结果 - </p>
<pre><code class="java">weeping...
barking...
eating...
Java
</code></pre>
<h3 id="3-多级继承示例"><a href="#3-多级继承示例" class="headerlink" title="(3). 多级继承示例"></a>(3). 多级继承示例</h3><p>文件 <code>TestInheritance3.java</code> 中的代码如下 - </p>
<pre><code class="java">class Animal &#123;
    void eat() &#123;
        System.out.println(&quot;eating...&quot;);
    &#125;
&#125;

class Dog extends Animal &#123;
    void bark() &#123;
        System.out.println(&quot;barking...&quot;);
    &#125;
&#125;

class Cat extends Animal &#123;
    void meow() &#123;
        System.out.println(&quot;meowing...&quot;);
    &#125;
&#125;

class TestInheritance3 &#123;
    public static void main(String args[]) &#123;
        Cat c = new Cat();
        c.meow();
        c.eat();
        // c.bark();//C.T.Error
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码得到以下结果 - </p>
<pre><code class="java">meowing...
eating...
Java
</code></pre>
<p><strong>问题：为什么在Java中不支持多重继承？</strong></p>
<p>为了降低复杂性并简化语言，Java中不支持多重继承。想象一个：<strong>A</strong>，<strong>B</strong>和<strong>C</strong>是三个类。 <strong>C</strong>类继承<strong>A</strong>和<strong>B</strong>类。 如果<strong>A</strong>和<strong>B</strong>类有相同的方法，并且从子类对象调用它，<strong>A</strong>或<strong>B</strong>类的调用方法会有歧义。</p>
<p>因为编译时错误比运行时错误好，如果继承<code>2</code>个类，java会在编译时报告错误。 所以无论子类中是否有相同的方法，都会有报告编译时错误。例如下面的代码是编译出错的。</p>
<pre><code class="java">class A &#123;
    void msg() &#123;
        System.out.println(&quot;Hello&quot;);
    &#125;
&#125;

class B &#123;
    void msg() &#123;
        System.out.println(&quot;Welcome&quot;);
    &#125;
&#125;

class C extends A,B
&#123;//suppose if it were  

 Public Static

    void main(String args[]) &#123;
        C obj = new C();
        obj.msg();// Now which msg() method would be invoked?
    &#125;
&#125;
</code></pre>
<h1 id="Java聚合"><a href="#Java聚合" class="headerlink" title="Java聚合"></a>Java聚合</h1><p>聚合</p>
<p>如果一个类有一个类的实体引用(类中的类)，则它称为聚合。 聚合表示<strong>HAS-A</strong>关系。<br>考虑有一种情况，<code>Employee</code>对象包含许多信息，例如：<code>id</code>，<code>name</code>，<code>emailId</code>等。它包含另一个类对象：<code>address</code>，其包含它自己的信息，例如：城市，州，国家，邮政编码等，如下所示。</p>
<pre><code class="java">class Employee&#123;  
    int id;  
    String name;  
    Address address;//Address is a class  
    ...  
&#125;
Java
</code></pre>
<p>在这种情况下，<code>Employee</code>有一个实体引用地址(<code>Address</code>)，因此关系是：<code>Employee HAS-A Address</code>。</p>
<h2 id="为什么要使用聚合？"><a href="#为什么要使用聚合？" class="headerlink" title="为什么要使用聚合？"></a>为什么要使用聚合？</h2><ul>
<li>代码可重用性。</li>
</ul>
<h3 id="聚合的简单示例"><a href="#聚合的简单示例" class="headerlink" title="聚合的简单示例"></a>聚合的简单示例</h3><p><img src="http://www.yiibai.com/uploads/images/201703/0603/965100309_75158.jpg" alt="img"></p>
<p>在这个例子中，在<code>Circle</code>类中创建了<code>Operation</code>类的引用。</p>
<pre><code class="java">class Operation &#123;
    int square(int n) &#123;
        return n * n;
    &#125;
&#125;

class Circle &#123;
    Operation op;// aggregation
    double pi = 3.14;

    double area(int radius) &#123;
        op = new Operation();
        int rsquare = op.square(radius);// code reusability (i.e. delegates the
                                        // method call).
        return pi * rsquare;
    &#125;

    public static void main(String args[]) &#123;
        Circle c = new Circle();
        double result = c.area(5);
        System.out.println(result);
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，得到以下结果 - </p>
<pre><code class="java">78.5
Java
</code></pre>
<h3 id="何时使用聚合？"><a href="#何时使用聚合？" class="headerlink" title="何时使用聚合？"></a>何时使用聚合？</h3><ul>
<li>当没有<code>is-a</code>关系时，通过聚合也能最好地实现代码重用。</li>
<li>只有在所涉及的对象的整个生命周期内维持关系为<code>is-a</code>时，才应使用继承; 否则，聚合是最好的选择。</li>
</ul>
<h3 id="理解聚合的一个示例"><a href="#理解聚合的一个示例" class="headerlink" title="理解聚合的一个示例"></a>理解聚合的一个示例</h3><p>在此示例中，<code>Employee</code>中拥有<code>Address</code>对象，<code>address</code>对象包含其自己的信息，例如城市，州，国家等。在这种情况下，关系是员工(<code>Employee</code>)<code>HAS-A</code>地址(<code>Address</code>)。</p>
<p><strong>Address.java</strong></p>
<pre><code class="java">public class Address &#123;
    String city, province;

    public Address(String city, String province) &#123;
        this.city = city;
        this.province = province;
    &#125;

&#125;
Java
</code></pre>
<p><strong>Emp.java</strong></p>
<pre><code class="java">public class Emp &#123;
    int id;
    String name;
    Address address;

    public Emp(int id, String name, Address address) &#123;
        this.id = id;
        this.name = name;
        this.address = address;
    &#125;

    void display() &#123;
        System.out.println(id + &quot; &quot; + name);
        System.out.println(address.city + &quot; &quot; + address.province);
    &#125;

    public static void main(String[] args) &#123;
        Address address1 = new Address(&quot;广州&quot;, &quot;广东&quot;);
        Address address2 = new Address(&quot;海口&quot;, &quot;海南&quot;);

        Emp e = new Emp(111, &quot;Wang&quot;, address1);
        Emp e2 = new Emp(112, &quot;Zhang&quot;, address2);

        e.display();
        e2.display();

    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，得到以下结果 - </p>
<pre><code class="java">111 Wang
广州 广东
112 Zhang
海口 海南
</code></pre>
<h1 id="Java方法重载"><a href="#Java方法重载" class="headerlink" title="Java方法重载"></a>Java方法重载</h1><p>如果一个类中有多个具有相同名称但参数不同的方法，则称为方法重载。如果只需要执行一个操作，具有相同的方法名称将增加程序的可读性。</p>
<p>假设必须执行给定数值的添加操作(求和)，但是参数的数量不固定，如果为两个参数编写<code>add1(int，int)</code>方法，为三个参数编写<code>add2(int，int，int)</code>方法，可能对其他程序员来说很难理解这样的方法的行为，因为它的名称不同。</p>
<p>因此，执行方法重载能比较容易理解程序含义。</p>
<p><strong>方法重载的优点</strong></p>
<ul>
<li>方法重载提高了程序的可读性。</li>
</ul>
<p><strong>重载方法不同的方式</strong></p>
<p>在java中重载方法有两种方式，它们分别是：</p>
<ul>
<li>通过改变参数的数量</li>
<li>通过更改数据类型</li>
</ul>
<blockquote>
<p>注意：在java中，只通过更改方法的返回类型来实现方法重载是不可以的。</p>
</blockquote>
<h2 id="1-方法重载：-修改参数的数量"><a href="#1-方法重载：-修改参数的数量" class="headerlink" title="1. 方法重载： 修改参数的数量"></a>1. 方法重载： 修改参数的数量</h2><p>在这个例子中，我们将创建了两个方法，第一个<code>add()</code>方法执行两个数值的相加操作，第二个<code>add()</code>方法执行三个数值的相加操作。</p>
<p>在这个例子中，我们创建静态方法，所以不需要创建实例来调用方法。</p>
<pre><code class="java">class Adder &#123;
    static int add(int a, int b) &#123;
        return a + b;
    &#125;

    static int add(int a, int b, int c) &#123;
        return a + b + c;
    &#125;
&#125;

class TestOverloading1 &#123;
    public static void main(String[] args) &#123;
        System.out.println(Adder.add(11, 11));
        System.out.println(Adder.add(11, 11, 11));
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行后，输出结果如下 -</p>
<pre><code class="java">22
33
Java
</code></pre>
<h2 id="2-方法重载：更改参数的数据类型"><a href="#2-方法重载：更改参数的数据类型" class="headerlink" title="2. 方法重载：更改参数的数据类型"></a>2. 方法重载：更改参数的数据类型</h2><p>在这个例子中，创建了两种数据类型不同的方法。 第一个<code>add</code>方法接收两个整数参数，第二个<code>add</code>方法接收两个双精度型参数。</p>
<pre><code class="java">class Adder &#123;
    static int add(int a, int b) &#123;
        return a + b;
    &#125;

    static double add(double a, double b) &#123;
        return a + b;
    &#125;
&#125;

class TestOverloading2 &#123;
    public static void main(String[] args) &#123;
        System.out.println(Adder.add(11, 11));
        System.out.println(Adder.add(12.3, 12.6));
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行后，输出结果如下 -</p>
<pre><code class="java">22
24.9
Java
</code></pre>
<p><strong>问题：为什么方法重载不能通过更改方法的返回类型？</strong></p>
<p>在java中，只通过改变方法的返回类型来实现方法重载是不可能的，因为这样具有模糊性。 让我们来看看模糊性是怎么样发生的：</p>
<pre><code class="java">class Adder &#123;
    static int add(int a, int b) &#123;
        return a + b;
    &#125;

    static double add(int a, int b) &#123;
        return a + b;
    &#125;
&#125;

class TestOverloading3 &#123;
    public static void main(String[] args) &#123;
        System.out.println(Adder.add(11, 11));// ambiguity
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行后，输出结果如下 -</p>
<pre><code class="java">Compile Time Error: method add(int,int) is already defined in class Adder
Java
</code></pre>
<p><code>System.out.println(Adder.add(11,11));</code>//这里，java如何确定应该调用哪个<code>sum()</code>方法？</p>
<blockquote>
<p>注意：编译时错误优于运行时错误。 所以，如果你声明相同的方法具有相同的参数，java编译器渲染编译器时间错误。</p>
</blockquote>
<p><strong>可以重载java main()方法吗？</strong></p>
<p>这是完全可以的。 可以通过方法重载在类中有任意数量的<code>main</code>方法。 但是JVM调用<code>main()</code>方法，它只接收字符串数组作为参数。 让我们来看一个简单的例子：</p>
<pre><code class="java">class TestOverloading4&#123;  
    public static void main(String[] args)&#123;System.out.println(&quot;main with String[]&quot;);&#125;  
    public static void main(String args)&#123;System.out.println(&quot;main with String&quot;);&#125;  
    public static void main()&#123;System.out.println(&quot;main without args&quot;);&#125;  
&#125;
Java
</code></pre>
<p>上面代码执行后，输出结果如下 -</p>
<pre><code class="java">main with String[]
Java
</code></pre>
<h2 id="方法重载和类型提升"><a href="#方法重载和类型提升" class="headerlink" title="方法重载和类型提升"></a>方法重载和类型提升</h2><p>如果没有找到匹配的数据类型，那么会隐式地将一个类型提升到另一个类型。 让我们通过下面的图示来理解这个概念：<br><img src="http://www.yiibai.com/uploads/images/201703/0603/289110316_15512.jpg" alt="img"></p>
<p>如上图所示，<code>byte</code>可以被提升为<code>short</code>，<code>int</code>，<code>long</code>，<code>float</code>或<code>double</code>。 <code>short</code>数据类型可以提升为<code>int</code>，<code>long</code>，<code>float</code>或<code>double</code>。 <code>char</code>数据类型可以提升为<code>int</code>，<code>long</code>，<code>float</code>或<code>double</code>等等。</p>
<p><strong>使用类型提升方法重载的示例</strong></p>
<pre><code class="java">class OverloadingCalculation1 &#123;
    void sum(int a, long b) &#123;
        System.out.println(a + b);
    &#125;

    void sum(int a, int b, int c) &#123;
        System.out.println(a + b + c);
    &#125;

    public static void main(String args[]) &#123;
        OverloadingCalculation1 obj = new OverloadingCalculation1();
        obj.sum(20, 20);// now second int literal will be promoted to long
        obj.sum(20, 20, 20);

    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行后，输出结果如下 -</p>
<pre><code class="java">40
60
Java
</code></pre>
<p><strong>如果找到匹配使用类型提升方法重载示例</strong><br>如果方法中存在匹配类型参数，则不会执行类型提升方法重载。</p>
<pre><code class="java">class OverloadingCalculation2 &#123;
    void sum(int a, int b) &#123;
        System.out.println(&quot;int arg method invoked&quot;);
    &#125;

    void sum(long a, long b) &#123;
        System.out.println(&quot;long arg method invoked&quot;);
    &#125;

    public static void main(String args[]) &#123;
        OverloadingCalculation2 obj = new OverloadingCalculation2();
        obj.sum(20, 20);// now int arg sum() method gets invoked
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行后，输出结果如下 -</p>
<pre><code class="java">Output:int arg method invoked
Java
</code></pre>
<p><strong>在模糊的情况下使用类型提升来实现方法重载的示例</strong></p>
<p>如果在方法中没有匹配的类型参数，并且每个方法都会提升相同数量的参数，那么会出现歧义。如下示例代码，将会产生编译时错误。</p>
<pre><code class="java">class OverloadingCalculation3 &#123;
    void sum(int a, long b) &#123;
        System.out.println(&quot;a method invoked&quot;);
    &#125;

    void sum(long a, int b) &#123;
        System.out.println(&quot;b method invoked&quot;);
    &#125;

    public static void main(String args[]) &#123;
        OverloadingCalculation3 obj = new OverloadingCalculation3();
        obj.sum(20, 20);// now ambiguity
    &#125;
&#125;
Java
</code></pre>
<blockquote>
<p>注意： 只有一种类型不被隐式地去提升，例如<code>double</code>不能被隐含地提升到任何类型。</p>
</blockquote>
<h1 id="Java方法重写"><a href="#Java方法重写" class="headerlink" title="Java方法重写"></a>Java方法重写</h1><p>如果子类中具有与父类中声明相同的方法，在java中称为方法覆盖。换句话说，如果子类提供了由其父类提供的其中一个方法的特定实现，则它被称为方法覆盖。所以方法覆盖有两个前提条件：继承和子父类中方法名称相同。</p>
<p><strong>Java方法覆盖的用法</strong></p>
<ul>
<li>方法重写用于提供有别于超类提供的方法的特定实现。</li>
<li>方法重写用于运行时多态性。</li>
</ul>
<p><strong>Java方法覆盖的规则</strong></p>
<ol>
<li>方法必须与父类中的名称相同。</li>
<li>方法必须具有与父类中相同的参数。</li>
<li>必须是<strong>IS-A</strong>关系(继承)。</li>
</ol>
<p><strong>理解没有方法覆盖的问题</strong></p>
<p>下面让我们来了解如果在程序中不使用方法覆盖可能面临的问题。</p>
<pre><code class="java">class Vehicle &#123;
    void run() &#123;
        System.out.println(&quot;Vehicle is running&quot;);
    &#125;
&#125;

class Bike extends Vehicle &#123;

    public static void main(String args[]) &#123;
        Bike obj = new Bike();
        obj.run();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，输出结果如下 - </p>
<pre><code class="java">Vehicle is running
Java
</code></pre>
<p>问题是，必须在子类中提供一个<code>run()</code>方法，这就是为什么要使用方法覆盖。</p>
<h3 id="方法覆盖的示例"><a href="#方法覆盖的示例" class="headerlink" title="方法覆盖的示例"></a>方法覆盖的示例</h3><p>在下面的这个例子中，在父类中和子类中都定义了<code>run</code>方法，但子类中有一些特定的实现。 方法的名称和参数是相同的，并且类之间有<strong>IS-A</strong>关系，因此这里<code>run</code>方法被覆盖了。</p>
<pre><code class="java">class Vehicle &#123;
    void run() &#123;
        System.out.println(&quot;Vehicle is running&quot;);
    &#125;
&#125;

class Bike2 extends Vehicle &#123;
    void run() &#123;
        System.out.println(&quot;Bike is running safely&quot;);
    &#125;

    public static void main(String args[]) &#123;
        Bike2 obj = new Bike2();
        obj.run();
    &#125;
&#125;
Java
</code></pre>
<p>执行输出结果如下 -</p>
<pre><code class="java">Bike is running safely
Java
</code></pre>
<h2 id="Java方法重写的实例"><a href="#Java方法重写的实例" class="headerlink" title="Java方法重写的实例"></a>Java方法重写的实例</h2><p>考虑下面一个真实应用的情况，<code>Bank</code>是一个提供获取利率的功能的类。 但是，利息率因银行不同而有所区别。 例如，<code>SBI</code>，<code>ICICI</code>和<code>AXIS</code>银行可以提供<code>8％</code>，<code>7％</code>和<code>9％</code>的利率。</p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0603/950140330_77161.png" alt="img"></p>
<pre><code class="java">class Bank &#123;
    int getRateOfInterest() &#123;
        return 0;
    &#125;
&#125;

class SBI extends Bank &#123;
    int getRateOfInterest() &#123;
        return 8;
    &#125;
&#125;

class ICICI extends Bank &#123;
    int getRateOfInterest() &#123;
        return 7;
    &#125;
&#125;

class AXIS extends Bank &#123;
    int getRateOfInterest() &#123;
        return 9;
    &#125;
&#125;

class Test2 &#123;
    public static void main(String args[]) &#123;
        SBI s = new SBI();
        ICICI i = new ICICI();
        AXIS a = new AXIS();
        System.out.println(&quot;SBI Rate of Interest: &quot; + s.getRateOfInterest());
        System.out.println(&quot;ICICI Rate of Interest: &quot; + i.getRateOfInterest());
        System.out.println(&quot;AXIS Rate of Interest: &quot; + a.getRateOfInterest());
    &#125;
&#125;
Java
</code></pre>
<p>执行输出结果如下 -</p>
<pre><code class="java">SBI Rate of Interest: 8
ICICI Rate of Interest: 7
AXIS Rate of Interest: 9
Java
</code></pre>
<p><strong>问题：可以覆盖静态方法吗？</strong></p>
<p><strong>答：</strong> 这是不可以的，静态方法不能被覆盖。可以通过运行时多态来证明不能覆盖，在稍后章节中将学习它。</p>
<p><strong>问题： 为什么不能覆盖静态方法？</strong><br><strong>答：</strong> 因为静态方法是绑定类，而实例方法绑定对象。 静态属于类区域，实例属于堆区域。</p>
<p><strong>问题：可以重写java main方法吗？</strong></p>
<p><strong>答：</strong> 这是不可以的，因为<code>main</code>是一个静态方法。</p>
<p><strong>java方法重载和方法重写之间的区别：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.yiibai.com/java/method-overloading-vs-method-overriding-in-java.html">方法重载和覆盖的区别</a></li>
</ul>
<h1 id="Java-super关键字"><a href="#Java-super关键字" class="headerlink" title="Java super关键字"></a>Java super关键字</h1><p>作者：                     初生不惑                 <strong>Java技术QQ群：227270512 / Linux QQ群：479429477</strong>             </p>
<p>​                                                                                    </p>
<p>java中的<code>super</code>关键字是一个引用变量，用于引用直接父类对象。</p>
<p>每当创建子类的实例时，父类的实例被隐式创建，由<code>super</code>关键字引用变量引用。</p>
<p>java <code>super</code>关键字的用法如下：</p>
<ul>
<li><code>super</code>可以用来引用直接父类的实例变量。</li>
<li><code>super</code>可以用来调用直接父类方法。</li>
<li><code>super()</code>可以用于调用直接父类构造函数。</li>
</ul>
<h2 id="1-super用于引用直接父类实例变量"><a href="#1-super用于引用直接父类实例变量" class="headerlink" title="1. super用于引用直接父类实例变量"></a>1. super用于引用直接父类实例变量</h2><p>可以使用<code>super</code>关键字来访问父类的数据成员或字段。 如果父类和子类具有相同的字段，则使用<code>super</code>来指定为父类数据成员或字段。</p>
<pre><code class="java">class Animal &#123;
    String color = &quot;white&quot;;
&#125;

class Dog extends Animal &#123;
    String color = &quot;black&quot;;

    void printColor() &#123;
        System.out.println(color);// prints color of Dog class
        System.out.println(super.color);// prints color of Animal class
    &#125;
&#125;

class TestSuper1 &#123;
    public static void main(String args[]) &#123;
        Dog d = new Dog();
        d.printColor();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，输出结果如下 -</p>
<pre><code class="java">black
white
Java
</code></pre>
<p>在上面的例子中，<code>Animal</code>和<code>Dog</code>都有一个共同的属性：<code>color</code>。 如果我们打印<code>color</code>属性，它将默认打印当前类的颜色。 要访问父属性，需要使用<code>super</code>关键字指定。</p>
<h2 id="2-通过-super-来调用父类方法"><a href="#2-通过-super-来调用父类方法" class="headerlink" title="2. 通过 super 来调用父类方法"></a>2. 通过 super 来调用父类方法</h2><p><code>super</code>关键字也可以用于调用父类方法。 如果子类包含与父类相同的方法，则应使用<code>super</code>关键字指定父类的方法。 换句话说，如果方法被覆盖就可以使用 <code>super</code> 关键字来指定父类方法。</p>
<pre><code class="java">class Animal &#123;
    void eat() &#123;
        System.out.println(&quot;eating...&quot;);
    &#125;
&#125;

class Dog extends Animal &#123;
    void eat() &#123;
        System.out.println(&quot;eating bread...&quot;);
    &#125;

    void bark() &#123;
        System.out.println(&quot;barking...&quot;);
    &#125;

    void work() &#123;
        super.eat();
        bark();
    &#125;
&#125;

class TestSuper2 &#123;
    public static void main(String args[]) &#123;
        Dog d = new Dog();
        d.work();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，输出结果如下 -</p>
<pre><code class="java">eating...
barking...
Java
</code></pre>
<p>在上面的例子中，<code>Animal</code>和<code>Dog</code>两个类都有<code>eat()</code>方法，如果要调用<code>Dog</code>类中的<code>eat()</code>方法，它将默认调用<code>Dog</code>类的<code>eat()</code>方法，因为当前类的优先级比父类的高。<br>所以要调用父类方法，需要使用<code>super</code>关键字指定。</p>
<h2 id="3-使用-super-来调用父类构造函数"><a href="#3-使用-super-来调用父类构造函数" class="headerlink" title="3. 使用 super 来调用父类构造函数"></a>3. 使用 super 来调用父类构造函数</h2><p><code>super</code>关键字也可以用于调用父类构造函数。下面来看一个简单的例子：</p>
<pre><code class="java">class Animal &#123;
    Animal() &#123;
        System.out.println(&quot;animal is created&quot;);
    &#125;
&#125;

class Dog extends Animal &#123;
    Dog() &#123;
        super();
        System.out.println(&quot;dog is created&quot;);
    &#125;
&#125;

class TestSuper3 &#123;
    public static void main(String args[]) &#123;
        Dog d = new Dog();
    &#125;
&#125;
Java
</code></pre>
<blockquote>
<p>注意：如果没有使用<code>super()</code>或<code>this()</code>，则<code>super()</code>在每个类构造函数中由编译器自动添加。</p>
</blockquote>
<p><img src="http://www.yiibai.com/uploads/images/201703/0603/850160347_42602.jpg" alt="img"></p>
<p>我们知道，如果没有构造函数，编译器会自动提供默认构造函数。 但是，它还添加了<code>super()</code>作为第一个语句。</p>
<p>下面是<code>super</code>关键字的另一个例子，这里<code>super()</code>由编译器隐式提供。</p>
<pre><code class="java">class Animal &#123;
    Animal() &#123;
        System.out.println(&quot;animal is created&quot;);
    &#125;
&#125;

class Dog extends Animal &#123;
    Dog() &#123;
        System.out.println(&quot;dog is created&quot;);
    &#125;
&#125;

class TestSuper4 &#123;
    public static void main(String args[]) &#123;
        Dog d = new Dog();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，输出结果如下 -</p>
<pre><code class="java">animal is created
dog is created
Java
</code></pre>
<h2 id="super实际使用示例"><a href="#super实际使用示例" class="headerlink" title="super实际使用示例"></a>super实际使用示例</h2><p>下面来看看<code>super</code>关键字的实际用法。 在这里，<code>Emp</code>类继承了<code>Person</code>类，所以<code>Person</code>的所有属性都将默认继承到<code>Emp</code>。 要初始化所有的属性，可使用子类的父类构造函数。 这样，我们重用了父类的构造函数。</p>
<pre><code class="java">class Person &#123;
    int id;
    String name;

    Person(int id, String name) &#123;
        this.id = id;
        this.name = name;
    &#125;
&#125;

class Emp extends Person &#123;
    float salary;

    Emp(int id, String name, float salary) &#123;
        super(id, name);// reusing parent constructor
        this.salary = salary;
    &#125;

    void display() &#123;
        System.out.println(id + &quot; &quot; + name + &quot; &quot; + salary);
    &#125;
&#125;

class TestSuper5 &#123;
    public static void main(String[] args) &#123;
        Emp e1 = new Emp(1, &quot;ankit&quot;, 45000f);
        e1.display();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，输出结果如下 -</p>
<pre><code class="java">1 ankit 45000
</code></pre>
<h1 id="Java实例初始化程序块"><a href="#Java实例初始化程序块" class="headerlink" title="Java实例初始化程序块"></a>Java实例初始化程序块</h1><p>实例初始化程序块用于初始化实例数据成员。 它在每次创建类的对象时运行。实例变量的初始化可以是直接的，但是可以在初始化实例初始化块中的实例变量时执行额外的操作。</p>
<p><strong>什么是实例初始化块的使用，我们可以直接分配一个值在实例数据成员？</strong> 例如：</p>
<pre><code class="java">class Bike&#123;  
    int speed=100;  
&#125;
Java
</code></pre>
<h2 id="为什么要使用实例初始化块？"><a href="#为什么要使用实例初始化块？" class="headerlink" title="为什么要使用实例初始化块？"></a>为什么要使用实例初始化块？</h2><p>假设在赋值给实例数据成员时必须要执行一些操作。 如：使用<code>for</code>循环来填充复杂数组或错误处理等。</p>
<p><strong>实例初始化程序块的示例</strong></p>
<p>下面来看看实例初始化块执行初始化的简单例子。</p>
<pre><code class="java">class Bike7 &#123;
    int speed;

    Bike7() &#123;
        System.out.println(&quot;speed is &quot; + speed);
    &#125;

    &#123;
        speed = 100;
    &#125;

    public static void main(String args[]) &#123;
        Bike7 b1 = new Bike7();
        Bike7 b2 = new Bike7();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码得到以下结果 - </p>
<pre><code class="shell">speed is 100
speed is 100
Shell
</code></pre>
<p>在Java中有三个地方可以执行实例初始化块操作：</p>
<ol>
<li>方法</li>
<li>构造函数</li>
<li>代码块</li>
</ol>
<p><strong>实例初始化块或构造函数哪个先调用？</strong></p>
<p>看看下面代码就知道了。</p>
<pre><code class="java">class Bike8 &#123;
    int speed;

    Bike8() &#123;
        System.out.println(&quot;constructor is invoked&quot;);
    &#125;

    &#123;
        System.out.println(&quot;instance initializer block invoked&quot;);
    &#125;

    public static void main(String args[]) &#123;
        Bike8 b1 = new Bike8();
        Bike8 b2 = new Bike8();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码得到以下结果 - </p>
<pre><code class="shell">instance initializer block invoked
constructor is invoked
instance initializer block invoked
constructor is invoked
Shell
</code></pre>
<p>在上面的例子中，似乎首先调用实例初始化块，但是可惜不是。 实例初始化块在对象创建时被调用。 java编译器在第一个语句<code>super()</code>之后的构造函数中复制实例初始化块。 首先，调用构造函数。 让我们通过下面的图来理解它：</p>
<p><strong>注意：</strong>java编译器在每个构造函数中会自动复制实例初始化块的代码。</p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0603/665170344_26739.jpg" alt="img"></p>
<p><strong>实例初始化块的规则：</strong></p>
<p>实例初始化块主要有三个规则。 它们如下：</p>
<ol>
<li>在创建类的实例时创建实例初始化程序块。</li>
<li>在父类构造函数被调用之后(即在<code>super()</code>构造函数调用之后)调用实例初始化块。</li>
<li>实例初始化程序块按它们显示的顺序排列。</li>
</ol>
<p>在<code>super()</code>之后调用的实例初始化块的程序示例：</p>
<pre><code class="java">class A &#123;
    A() &#123;
        System.out.println(&quot;parent class constructor invoked&quot;);
    &#125;
&#125;

class B2 extends A &#123;
    B2() &#123;
        super();
        System.out.println(&quot;child class constructor invoked&quot;);
    &#125;

    &#123;
        System.out.println(&quot;instance initializer block is invoked&quot;);
    &#125;

    public static void main(String args[]) &#123;
        B2 b = new B2();
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行结果如下 - </p>
<pre><code class="java">parent class constructor invoked
instance initializer block is invoked
child class constructor invoked
Java
</code></pre>
<p><strong>实例块的另一个示例</strong></p>
<pre><code class="java">class A &#123;
    A() &#123;
        System.out.println(&quot;parent class constructor invoked&quot;);
    &#125;
&#125;

class B3 extends A &#123;
    B3() &#123;
        super();
        System.out.println(&quot;child class constructor invoked&quot;);
    &#125;

    B3(int a) &#123;
        super();
        System.out.println(&quot;child class constructor invoked &quot; + a);
    &#125;

    &#123;
        System.out.println(&quot;instance initializer block is invoked&quot;);
    &#125;

    public static void main(String args[]) &#123;
        B3 b1 = new B3();
        B3 b2 = new B3(10);
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行结果如下 - </p>
<pre><code class="java">parent class constructor invoked
instance initializer block is invoked
child class constructor invoked
parent class constructor invoked
instance initializer block is invoked
child class constructor invoked 10
</code></pre>
<h1 id="Java-final关键字"><a href="#Java-final关键字" class="headerlink" title="Java final关键字"></a>Java final关键字</h1><p>java中的<code>final</code>关键字用于限制用户修改变量或重写一个类或方法。 java <code>final</code>关键字可以在许多上下文中使用。 <code>final</code>可以是：</p>
<ol>
<li>变量</li>
<li>方法</li>
<li>类</li>
</ol>
<p><code>final</code>关键字可以应用于变量，没有值的<code>final</code>变量称为空白变量或未初始化的最终变量。 它只能在构造函数中初始化。 空白最终变量也可以是静态的，它将仅在静态块中初始化。 在之后的文章中我们将详细学习这些。 下面先学习<code>final</code>关键字的基础知识。</p>
<h2 id="1-Java-final变量"><a href="#1-Java-final变量" class="headerlink" title="1. Java final变量"></a>1. Java final变量</h2><p>如果将变量设置为<code>final</code>，则不能更改<code>final</code>变量的值(它将是常量)。final关键字应用有以下几点需要注意：</p>
<ol>
<li>禁止变量的值被改变；</li>
<li>禁止方法重写；</li>
<li>禁止类继承；</li>
</ol>
<p><strong>final变量的示例</strong></p>
<p>要改变<code>final</code>变量的值，这是不可能的，因为一个<code>final</code>变量一次分配一个值永远不能更改。如下试图修改 speedlimit 变量的值为 400，这是不允许的。</p>
<pre><code class="java">class Bike9 &#123;
    final int speedlimit = 90;// final variable

    void run() &#123;
        speedlimit = 400; // 不可以修改 final 变量的值
    &#125;

    public static void main(String args[]) &#123;
        Bike9 obj = new Bike9();
        obj.run();
    &#125;
&#125;// end of class
Java
</code></pre>
<p>上面代码执行后生成以下结果 -</p>
<pre><code class="java">[编译错误]Compile Time Error
Java
</code></pre>
<h2 id="2-Java-final方法"><a href="#2-Java-final方法" class="headerlink" title="2. Java final方法"></a>2. Java final方法</h2><p>如果任何方法声明为<code>final</code>，则不能覆盖它。</p>
<p><code>final</code>方法的示例，下面方法是不能覆盖的 - </p>
<pre><code class="java">class Bike &#123;
    final void run() &#123;
        System.out.println(&quot;running&quot;);
    &#125;
&#125;

class Honda extends Bike &#123;
    void run() &#123; // final方法,不可以重写
        System.out.println(&quot;running safely with 100kmph&quot;);
    &#125;

    public static void main(String args[]) &#123;
        Honda honda = new Honda();
        honda.run();
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行后生成以下结果 -</p>
<pre><code class="java">[编译错误]Compile Time Error
Java
</code></pre>
<h2 id="3-Java-final类"><a href="#3-Java-final类" class="headerlink" title="3. Java final类"></a>3. Java final类</h2><p>如果把任何一个类声明为<code>final</code>，则不能扩展它。<code>final</code>类的示例</p>
<pre><code class="java">final class Bike &#123;
&#125;

class Honda1 extends Bike &#123; // 不可以扩展 final 类
    void run() &#123;
        System.out.println(&quot;running safely with 100kmph&quot;);
    &#125;

    public static void main(String args[]) &#123;
        Honda1 honda = new Honda();
        honda.run();
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行后生成以下结果 -</p>
<pre><code class="java">[编译错误]Compile Time Error
Java
</code></pre>
<p><strong>问题：是否可继承final方法？</strong></p>
<p><strong>答：</strong> 是的，<code>final</code>方法是继承的，但是不能覆盖它。 例如：</p>
<pre><code class="java">class Bike &#123;
    final void run() &#123;
        System.out.println(&quot;running...&quot;);
    &#125;
&#125;

class Honda2 extends Bike &#123;
    public static void main(String args[]) &#123;
        new Honda2().run();
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行后生成以下结果 -</p>
<pre><code class="java">Output:running...
Java
</code></pre>
<p><strong>问题：什么是空白或未初始化的final变量？</strong></p>
<p>在声明时未初始化的<code>final</code>变量称为空白<code>final</code>变量。</p>
<p>如果要在创建一个对象时初始化变量，并且变量在初始化后就不会被改变， 这是非常有用的。 例如员工的<code>PAN CARD</code>号码。它只能在构造函数中初始化。</p>
<p>空白<code>final</code>变量的示例</p>
<pre><code class="java">class Student&#123;  
    int id;  
    String name;  
    final String PAN_CARD_NUMBER;  
    ...  
&#125;
Java
</code></pre>
<p><strong>问题：可以初始化空白的final变量吗？</strong></p>
<p><strong>答：</strong> 是的，但只能在构造函数中。 例如：</p>
<pre><code class="java">class Bike10 &#123;
    final int speedlimit;// blank final variable

    Bike10() &#123; // 在构造函数中初始化
        speedlimit = 70;
        System.out.println(speedlimit);
    &#125;

    public static void main(String args[]) &#123;
        new Bike10();
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行后生成以下结果 -</p>
<pre><code class="java">70
Java
</code></pre>
<h2 id="静态空白final变量"><a href="#静态空白final变量" class="headerlink" title="静态空白final变量"></a>静态空白final变量</h2><p>在声明时未初始化的静态<code>final</code>变量称为静态空白<code>final</code>变量。 它只能在静态块中初始化。</p>
<p><strong>静态空白final变量的示例</strong></p>
<pre><code class="java">class A &#123;
    static final int data;// static blank final variable
    static &#123;
        data = 50;
    &#125;

    public static void main(String args[]) &#123;
        System.out.println(A.data);
    &#125;
&#125;
Java
</code></pre>
<p><strong>问题：什么是final参数？</strong></p>
<p>如果将任何参数声明为<code>final</code>，则不能更改它的值。</p>
<pre><code class="java">class Bike11 &#123;

    int cube(final int n) &#123;
        n = n + 2;// can&#39;t be changed as n is final
        // n*n*n; // 不能修改 n 的值
        return n;
    &#125;

    public static void main(String args[]) &#123;
        Bike11 b = new Bike11();
        b.cube(5);
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行后生成以下结果 -</p>
<pre><code class="java">[编译错误]Compile Time Error
</code></pre>
<h1 id="Java多态"><a href="#Java多态" class="headerlink" title="Java多态"></a>Java多态</h1><p>Java中的多态是一个概念，通过它我们可以通过不同的方式执行单个动作(方法)。 多态性派生自<code>2</code>个希腊词：“<code>poly</code>”和“<code>morphs</code>”。 词语“<code>poly</code>”意为许多，“<code>morphs</code>”意为形式。 所以多态表示为多种形式。</p>
<p>在Java中有两种类型的多态性：编译时多态性和运行时多态性。 我们可以通过方法重载和方法覆盖在java中执行多态性。</p>
<p>如果在Java中重载静态方法，它就是编译时多态性的例子。 这里，我们将关注Java中的运行时多态性。</p>
<h2 id="1-Java运行时多态性"><a href="#1-Java运行时多态性" class="headerlink" title="1. Java运行时多态性"></a>1. Java运行时多态性</h2><p>运行时多态性或动态方法分派是一个过程，它对重写方法的调用在运行时体现而不是编译时。</p>
<p>在此过程中，通过超类的引用变量调用重写的方法。 要调用的方法基于引用的对象。</p>
<p>了解运行时多态性之前，让我们先来向上转换。</p>
<p><strong>向上转换</strong></p>
<p>当父类的引用变量引用子类的对象时，称为向上转换。 例如：</p>
<pre><code class="java">class A&#123;&#125;  
class B extends A&#123;&#125;  
A a=new B();  //向上转换...
Java
</code></pre>
<p><strong>Java运行时多态性示例1</strong></p>
<p>在这个例子中，我们创建两个类：<code>Bike</code>和<code>Splendar</code>。 <code>Splendar</code>类扩展<code>Bike</code>类并覆盖其<code>run()</code>方法。通过父类(<code>Bike</code>)的引用变量调用<code>run</code>方法。 因为它引用子类对象，并且子类方法覆盖父类方法，子类方法在运行时被调用。</p>
<pre><code class="java">因为方法调用是由JVM不是编译器决定的，所以它被称为运行时多态性。
Java
class Bike &#123;
    void run() &#123;
        System.out.println(&quot;running&quot;);
    &#125;
&#125;

class Splender extends Bike &#123;
    void run() &#123;
        System.out.println(&quot;running safely with 60km&quot;);
    &#125;

    public static void main(String args[]) &#123;
        Bike b = new Splender();// upcasting - 向上转换
        b.run();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码得到以下结果 -</p>
<pre><code class="java">running safely with 60km.
Java
</code></pre>
<p><strong>Java运行时多态性示例2：Bank</strong></p>
<p>考虑一种情况，<code>Bank</code>类是一个提供获得利率的方法的类。 但是，利率可能因银行而异。 例如，<code>SBI</code>，<code>ICICI</code>和<code>AXIS</code>银行分别提供<code>8.4％</code>，<code>7.3％</code>和<code>9.7％</code>的利率。</p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0703/690090348_34428.png" alt="img"></p>
<blockquote>
<p>注意：此示例也在方法覆盖中给出，但没有向上转换。</p>
</blockquote>
<pre><code class="java">class Bank &#123;
    float getRateOfInterest() &#123;
        return 0;
    &#125;
&#125;

class SBI extends Bank &#123;
    float getRateOfInterest() &#123;
        return 8.4f;
    &#125;
&#125;

class ICICI extends Bank &#123;
    float getRateOfInterest() &#123;
        return 7.3f;
    &#125;
&#125;

class AXIS extends Bank &#123;
    float getRateOfInterest() &#123;
        return 9.7f;
    &#125;
&#125;

class TestPolymorphism &#123;
    public static void main(String args[]) &#123;
        Bank b;
        b = new SBI();
        System.out.println(&quot;SBI Rate of Interest: &quot; + b.getRateOfInterest());
        b = new ICICI();
        System.out.println(&quot;ICICI Rate of Interest: &quot; + b.getRateOfInterest());
        b = new AXIS();
        System.out.println(&quot;AXIS Rate of Interest: &quot; + b.getRateOfInterest());
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行结果如下 - </p>
<pre><code class="java">SBI Rate of Interest: 8.4
ICICI Rate of Interest: 7.3
AXIS Rate of Interest: 9.7
Java
</code></pre>
<p><strong>Java运行时多态性示例3：Shape</strong></p>
<pre><code class="java">class Shape &#123; // 基类(形状)
    void draw() &#123;
        System.out.println(&quot;drawing...&quot;);
    &#125;
&#125;

class Rectangle extends Shape &#123;
    void draw() &#123;
        System.out.println(&quot;drawing rectangle...&quot;);
    &#125;
&#125;

class Circle extends Shape &#123;
    void draw() &#123;
        System.out.println(&quot;drawing circle...&quot;);
    &#125;
&#125;

class Triangle extends Shape &#123;
    void draw() &#123;
        System.out.println(&quot;drawing triangle...&quot;);
    &#125;
&#125;

class TestPolymorphism2 &#123;
    public static void main(String args[]) &#123;
        Shape s;
        s = new Rectangle();
        s.draw();
        s = new Circle();
        s.draw();
        s = new Triangle();
        s.draw();
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行结果如下 - </p>
<pre><code class="java">drawing rectangle...
drawing circle...
drawing triangle...
Java
</code></pre>
<p><strong>Java运行时多态性示例4：Animal</strong></p>
<pre><code class="java">class Animal &#123;
    void eat() &#123;
        System.out.println(&quot;eating...&quot;);
    &#125;
&#125;

class Dog extends Animal &#123;
    void eat() &#123;
        System.out.println(&quot;eating bread...&quot;);
    &#125;
&#125;

class Cat extends Animal &#123;
    void eat() &#123;
        System.out.println(&quot;eating rat...&quot;);
    &#125;
&#125;

class Lion extends Animal &#123;
    void eat() &#123;
        System.out.println(&quot;eating meat...&quot;);
    &#125;
&#125;

class TestPolymorphism3 &#123;
    public static void main(String[] args) &#123;
        Animal a;
        a = new Dog();
        a.eat();
        a = new Cat();
        a.eat();
        a = new Lion();
        a.eat();
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行结果如下 - </p>
<pre><code class="java">eating bread...
eating rat...
eating meat...
Java
</code></pre>
<h2 id="Java运行时多态性与数据成员"><a href="#Java运行时多态性与数据成员" class="headerlink" title="Java运行时多态性与数据成员"></a>Java运行时多态性与数据成员</h2><p>上面示例中，都是有关方法被覆盖而不是数据成员，因此运行时多态性不能由数据成员实现。<br>在下面给出的例子中，这两个类都有一个数据成员:<code>speedlimit</code>，通过引用子类对象的父类的引用变量来访问数据成员。 由于我们访问的数据成员没有被重写，因此它将访问父类的数据成员。</p>
<blockquote>
<p><strong>规则：</strong> 运行时多态性不能由数据成员实现。</p>
</blockquote>
<pre><code class="java">class Bike &#123;
    int speedlimit = 90;
&#125;

class Honda3 extends Bike &#123;
    int speedlimit = 150;

    public static void main(String args[])&#123;  
        Bike obj=new Honda3();  
        System.out.println(obj.speedlimit);//90 
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行结果如下 - </p>
<pre><code class="java">90
Java
</code></pre>
<h2 id="Java运行时多态性与多级继承"><a href="#Java运行时多态性与多级继承" class="headerlink" title="Java运行时多态性与多级继承"></a>Java运行时多态性与多级继承</h2><p>下面让我们来看看一个带有多级继承的运行时多态性的简单例子。</p>
<pre><code class="java">class Animal &#123;
    void eat() &#123;
        System.out.println(&quot;eating&quot;);
    &#125;
&#125;

class Dog extends Animal &#123;
    void eat() &#123;
        System.out.println(&quot;eating fruits&quot;);
    &#125;
&#125;

class BabyDog extends Dog &#123;
    void eat() &#123;
        System.out.println(&quot;drinking milk&quot;);
    &#125;

    public static void main(String args[]) &#123;
        Animal a1, a2, a3;
        a1 = new Animal();
        a2 = new Dog();
        a3 = new BabyDog();
        a1.eat();
        a2.eat();
        a3.eat();
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行结果如下 - </p>
<pre><code class="java">eating
eating fruits
drinking Milk
Java
</code></pre>
<p><strong>尝试下面一段代码的输出：</strong></p>
<pre><code class="java">class Animal &#123;
    void eat() &#123;
        System.out.println(&quot;animal is eating...&quot;);
    &#125;
&#125;

class Dog extends Animal &#123;
    void eat() &#123;
        System.out.println(&quot;dog is eating...&quot;);
    &#125;
&#125;

class BabyDog1 extends Dog &#123;
    public static void main(String args[]) &#123;
        Animal a = new BabyDog1();
        a.eat();
    &#125;
&#125;
Java
</code></pre>
<p>执行上述代码，结果如下：</p>
<pre><code class="java">Dog is eating
Java
</code></pre>
<p>因为，<code>BabyDog</code>不会覆盖<code>eat()</code>方法，所以这里是<code>Dog</code>类的<code>eat()</code>方法被调用。</p>
<h1 id="Java静态绑定和动态绑定"><a href="#Java静态绑定和动态绑定" class="headerlink" title="Java静态绑定和动态绑定"></a>Java静态绑定和动态绑定</h1><p>将方法调用连接到方法体称为绑定。</p>
<p>在java中有两种类型的绑定：</p>
<ul>
<li>静态绑定(也称为早期绑定)。</li>
<li>动态绑定(也称为后期绑定)。</li>
</ul>
<h2 id="了解类型"><a href="#了解类型" class="headerlink" title="了解类型"></a>了解类型</h2><p>下面让我们来了解实例的类型。</p>
<h3 id="1-变量有一个类型"><a href="#1-变量有一个类型" class="headerlink" title="1. 变量有一个类型"></a>1. 变量有一个类型</h3><p>每个变量都有一个类型，它可能是原始的和非原始的。</p>
<pre><code class="java">int data=30;
Java
</code></pre>
<p>这里的数据变量是一个<code>int</code>类型。</p>
<h3 id="2-引用有一个类型"><a href="#2-引用有一个类型" class="headerlink" title="2. 引用有一个类型"></a>2. 引用有一个类型</h3><pre><code class="java">class Dog &#123;
    public static void main(String args[]) &#123;
        Dog d1;// Here d1 is a type of Dog
    &#125;
&#125;
Java
</code></pre>
<h3 id="2-对象有一个类型"><a href="#2-对象有一个类型" class="headerlink" title="2. 对象有一个类型"></a>2. 对象有一个类型</h3><p>对象是特定的<code>java</code>类的实例，但它也是其超类的实例。</p>
<pre><code class="java">class Animal &#123;
&#125;

class Dog extends Animal &#123;
    public static void main(String args[]) &#123;
        Dog d1 = new Dog();
    &#125;
&#125;
Java
</code></pre>
<p>这里<code>d1</code>是<code>Dog</code>类的一个实例，但它也是<code>Animal</code>的一个实例。</p>
<h2 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h2><p>当编译时(由编译器)确定对象的类型时，它被称为静态绑定。如果在类中有任何<code>private</code>，<code>final</code>或<code>static</code>方法，则有静态绑定。</p>
<p><strong>静态绑定的示例</strong></p>
<pre><code class="java">class Dog &#123;
    private void eat() &#123;
        System.out.println(&quot;dog is eating...&quot;);
    &#125;

    public static void main(String args[]) &#123;
        Dog d1 = new Dog();
        d1.eat();
    &#125;
&#125;
Java
</code></pre>
<h2 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h2><p>当在运行时确定对象的类型时，它被称为动态绑定。</p>
<p><strong>动态绑定的示例</strong></p>
<pre><code class="java">class Animal &#123;
    void eat() &#123;
        System.out.println(&quot;animal is eating...&quot;);
    &#125;
&#125;

class Dog extends Animal &#123;
    void eat() &#123;
        System.out.println(&quot;dog is eating...&quot;);
    &#125;

    public static void main(String args[]) &#123;
        Animal a = new Dog();
        a.eat();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码输出结果如下 -</p>
<pre><code class="shell">dog is eating...
Shell
</code></pre>
<p>在上面的例子中，对象类型不能由编译器决定，因为<code>Dog</code>的实例也是<code>Animal</code>的一个实例。编译器不知道它的类型，只知道它的基类型。</p>
<h1 id="Java-instanceof运算符"><a href="#Java-instanceof运算符" class="headerlink" title="Java instanceof运算符"></a>Java instanceof运算符</h1><p>java <code>instanceof</code>运算符用于测试指定对象是否是指定类型(类或子类或接口)的实例。</p>
<p>java中的<code>instanceof</code>也称为类型比较运算符，因为它将类型与实例进行比较。 它返回<code>true</code>或<code>false</code>。 如果对任何具有<code>null</code>值的变量应用<code>instanceof</code>运算符，则返回false。</p>
<p><strong>java instanceof的简单示例</strong></p>
<p>下面来看看实例运算符的简单示例，它测试当前类。</p>
<pre><code class="java">class Simple1 &#123;
    public static void main(String args[]) &#123;
        Simple1 s = new Simple1();
        System.out.println(s instanceof Simple1);// true
    &#125;
&#125;
Java
</code></pre>
<p>执行上面试代码，得到以下结果 -</p>
<pre><code class="shell">true
Shell
</code></pre>
<p>子类类型的对象也是父类的类型。 例如，如果<code>Dog</code>扩展了<code>Animal</code>，那么<code>Dog</code>的对象可以通过<code>Dog</code>或<code>Animal</code>类来引用。</p>
<p><strong>java instanceof运算符的另一个例子</strong></p>
<pre><code class="java">class Animal &#123;
&#125;

class Dog1 extends Animal &#123;// Dog inherits Animal

    public static void main(String args[]) &#123;
        Dog1 d = new Dog1();
        System.out.println(d instanceof Animal);// true
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，得到以下结果 - </p>
<pre><code class="java">true
Java
</code></pre>
<p><strong>instanceof测试null值的变量示例</strong></p>
<p>如果我们对具有<code>null</code>值的变量应用<code>instanceof</code>运算符，则返回<code>false</code>。来看看下面给出的例子，将<code>instanceof</code>运算符应用于具有<code>null</code>值的变量。</p>
<pre><code class="java">class Dog2 &#123;
    public static void main(String args[]) &#123;
        Dog2 d = null;
        System.out.println(d instanceof Dog2);// false
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，得到以下结果 - </p>
<pre><code class="java">false
Java
</code></pre>
<p><strong>使用java instanceof运算符的向下转换</strong></p>
<p>当子类型引用父类的对象时，它被称为向下转换(downcasting)。 如果直接执行它，编译器会出现编译错误。 如果通过类型转换来执行，在运行时会抛出：<code>ClassCastException</code> 。 但是如果使用<code>instanceof</code>运算符，可以进行向下转换。</p>
<pre><code class="java">Dog d=new Animal();//Compilation error
Java
</code></pre>
<p>如果通过类型转换执行向下转换，则在运行时抛出：<code>ClassCastException</code>。</p>
<pre><code class="java">Dog d=(Dog)new Animal();  
//Compiles successfully but ClassCastException is thrown at runtime
Java
</code></pre>
<p><strong>使用instanceof进行向下转换</strong></p>
<p>现在看看下面这个例子，通过<code>instanceof</code>运算符进行向下转换。</p>
<pre><code class="java">class Animal &#123;
&#125;

class Dog3 extends Animal &#123;
    static void method(Animal a) &#123;
        if (a instanceof Dog3) &#123;
            Dog3 d = (Dog3) a;// downcasting
            System.out.println(&quot;ok downcasting performed&quot;);
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        Animal a = new Dog3();
        Dog3.method(a);
    &#125;

&#125;
Java
</code></pre>
<p>执行上面代码，得到以下结果 - </p>
<pre><code class="java">ok downcasting performed
Java
</code></pre>
<p><strong>向下转换不使用instanceof</strong></p>
<p>也可以在不使用<code>instanceof</code>运算符的情况下执行下转换，如以下示例代码所示：</p>
<pre><code class="java">class Animal &#123;
&#125;

class Dog4 extends Animal &#123;
    static void method(Animal a) &#123;
        Dog4 d = (Dog4) a;// downcasting
        System.out.println(&quot;ok downcasting performed&quot;);
    &#125;

    public static void main(String[] args) &#123;
        Animal a = new Dog4();
        Dog4.method(a);
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，得到以下结果 - </p>
<pre><code class="java">ok downcasting performed
Java
</code></pre>
<p>仔细看看，被引用的实际对象是<code>Dog</code>类的对象。 所以如果向下转换它，它是没有问题的。 但是，如果也可以这样写：</p>
<pre><code class="java">Animal a=new Animal();  
Dog.method(a);  
//Now ClassCastException but not in case of instanceof operator
Java
</code></pre>
<h2 id="理解在java中使用instanceof的实例"><a href="#理解在java中使用instanceof的实例" class="headerlink" title="理解在java中使用instanceof的实例"></a>理解在java中使用instanceof的实例</h2><p>这是一个instanceof的终极示例，通过下面的例子中的代码看看<code>instanceof</code>关键字的真正用法。</p>
<pre><code class="java">interface Printable &#123;
&#125;

class A implements Printable &#123;
    public void a() &#123;
        System.out.println(&quot;a method&quot;);
    &#125;
&#125;

class B implements Printable &#123;
    public void b() &#123;
        System.out.println(&quot;b method&quot;);
    &#125;
&#125;

class Call &#123;
    void invoke(Printable p) &#123;// upcasting
        if (p instanceof A) &#123;
            A a = (A) p;// Downcasting
            a.a();
        &#125;
        if (p instanceof B) &#123;
            B b = (B) p;// Downcasting
            b.b();
        &#125;

    &#125;
&#125;// end of Call class

class Test4 &#123;
    public static void main(String args[]) &#123;
        Printable p = new B();
        Call c = new Call();
        c.invoke(p);
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，得到以下结果 - </p>
<pre><code class="java">b method
</code></pre>
<h1 id="Java抽象类"><a href="#Java抽象类" class="headerlink" title="Java抽象类"></a>Java抽象类</h1><p>在java中用<code>abstract</code>关键字声明的类称为抽象类。 它可以有抽象和非抽象方法(带主体的方法)。</p>
<p>在学习java抽象类之前，先来了解java中的抽象。</p>
<h2 id="Java中的抽象"><a href="#Java中的抽象" class="headerlink" title="Java中的抽象"></a>Java中的抽象</h2><p>抽象是隐藏实现细节并仅向用户显示功能的过程。</p>
<p>另一种方式，它只向用户显示重要的事情，并隐藏内部详细信息，例如：发送短信，只需输入文本并发送消息。您也不需要知道有关邮件传递的内部处理过程。</p>
<p>抽象可以让你专注于对象做什么(实现的功能)，而不是它如何做。</p>
<h3 id="实现抽象的方法"><a href="#实现抽象的方法" class="headerlink" title="实现抽象的方法"></a>实现抽象的方法</h3><p>在java中有两种实现抽象的方法，它们分别是：</p>
<ol>
<li>抽象类(部分)</li>
<li>接口 (完全)</li>
</ol>
<h2 id="1-Java中的抽象类"><a href="#1-Java中的抽象类" class="headerlink" title="1. Java中的抽象类"></a>1. Java中的抽象类</h2><p>使用 <code>abstract</code>关键字声明的类被称为抽象类。需要扩展和实现它的方法。 它不能被实例化。</p>
<p><strong>抽象类示例</strong></p>
<pre><code class="java">abstract class A&#123;&#125;
Java
</code></pre>
<p><strong>抽象方法</strong></p>
<p>一个被声明为 <code>abstract</code> 而没有实现的方法称为抽象方法。</p>
<p><strong>抽象方法示例</strong></p>
<pre><code class="java">abstract void printStatus();//no body and abstract
Java
</code></pre>
<p><strong>具有抽象方法的抽象类的示例</strong></p>
<p>在这个例子中，<code>Bike</code>是一个抽象类，只包含一个抽象方法：<code>run()</code>。 它由 <code>Honda</code> 类提供实现。</p>
<pre><code class="java">abstract class Bike &#123;
    abstract void run();
&#125;

class Honda4 extends Bike &#123;
    void run() &#123;// run 方法的实现
        System.out.println(&quot;running safely..&quot;);
    &#125;

    public static void main(String args[]) &#123;
        Bike obj = new Honda4();
        obj.run();
    &#125;
&#125;
Java
</code></pre>
<p>上面示例中的代码执行结果如下 -</p>
<pre><code class="java">running safely..
Java
</code></pre>
<h2 id="理解抽象类的真实应用场景"><a href="#理解抽象类的真实应用场景" class="headerlink" title="理解抽象类的真实应用场景"></a>理解抽象类的真实应用场景</h2><p>在这个例子中，<code>Shape</code>是一个抽象类，它的实现分别由<code>Rectangle</code>和<code>Circle</code>类提供。 大多数情况下，我们不知道实现类(即对最终用户隐藏)，实现类的对象由工厂方法提供。<br><strong>工厂方法</strong>是用于返回类的实例的方法。 稍后我们将在下一节中了解和学习<strong>工厂方法</strong>。<br>在这个例子中，创建<code>Rectangle</code>类的实例，<code>Rectangle</code>类的<code>draw()</code>方法将被调用。创建一个类文件：<code>TestAbstraction1.java</code> ，它的代码如下所示 -</p>
<pre><code class="java">abstract class Shape &#123;
    abstract void draw();
&#125;

// In real scenario, implementation is provided by others i.e. unknown by end
// user
class Rectangle extends Shape &#123;
    void draw() &#123;
        System.out.println(&quot;drawing rectangle&quot;);
    &#125;
&#125;

class Circle1 extends Shape &#123;
    void draw() &#123;
        System.out.println(&quot;drawing circle&quot;);
    &#125;
&#125;

// In real scenario, method is called by programmer or user
class TestAbstraction1 &#123;
    public static void main(String args[]) &#123;
        Shape s = new Circle1();// In real scenario, object is provided through
                                // method e.g. getShape() method
        s.draw();
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行结果如下 -</p>
<pre><code class="java">drawing circle
Java
</code></pre>
<p><strong>在java中抽象类的另一个例子</strong></p>
<p>创建一个Java文件：<code>TestBank.java</code>，代码如下所示 -</p>
<pre><code class="java">abstract class Bank &#123;
    abstract int getRateOfInterest();
&#125;

class SBI extends Bank &#123;
    int getRateOfInterest() &#123;
        return 7;
    &#125;
&#125;

class PNB extends Bank &#123;
    int getRateOfInterest() &#123;
        return 8;
    &#125;
&#125;

class TestBank &#123;
    public static void main(String args[]) &#123;
        Bank b;
        b = new SBI();
        System.out.println(&quot;Rate of Interest is: &quot; + b.getRateOfInterest() + &quot; %&quot;);
        b = new PNB();
        System.out.println(&quot;Rate of Interest is: &quot; + b.getRateOfInterest() + &quot; %&quot;);
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行结果如下 -</p>
<pre><code class="java">Rate of Interest is: 7 %
Rate of Interest is: 8 %
Java
</code></pre>
<p><strong>具有构造函数，数据成员，方法等的抽象类</strong></p>
<p>抽象类可以有数据成员，抽象方法，方法体，构造函数甚至<code>main()</code>方法。创建一个Java文件：<code>TestAbstraction2.java</code>，代码如下所示 -</p>
<pre><code class="java">//example of abstract class that have method body  
abstract class Bike &#123;
    Bike() &#123;
        System.out.println(&quot;bike is created&quot;);
    &#125;

    abstract void run();

    void changeGear() &#123;
        System.out.println(&quot;gear changed&quot;);
    &#125;
&#125;

class Honda extends Bike &#123;
    void run() &#123;
        System.out.println(&quot;running safely..&quot;);
    &#125;
&#125;

class TestAbstraction2 &#123;
    public static void main(String args[]) &#123;
        Bike obj = new Honda();
        obj.run();
        obj.changeGear();
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行结果如下 -</p>
<pre><code class="java">bike is created
running safely..
gear changed
Java
</code></pre>
<blockquote>
<p>规则：如果在类中有任何抽象方法，那个类必须声明为抽象的。</p>
</blockquote>
<pre><code class="java">class Bike12&#123;  
    abstract void run();  
&#125;
Java
</code></pre>
<p>上面的 <code>Bike12</code> 是无法编译通过的。</p>
<blockquote>
<p>规则：如果你扩展任何具有抽象方法的抽象类，必须提供方法的实现或使这个类抽象化。</p>
</blockquote>
<h2 id="抽象类的另一个真实场景"><a href="#抽象类的另一个真实场景" class="headerlink" title="抽象类的另一个真实场景"></a>抽象类的另一个真实场景</h2><p>抽象类也可以用于提供接口的一些实现。 在这种情况下，终端用户可能不会被强制覆盖接口的所有方法。</p>
<blockquote>
<p>注意：如果您是初学者到Java，请跳过此示例先学习<a target="_blank" rel="noopener" href="http://www.yiibai.com/java/interface-in-java.html">接口(interface)</a>。</p>
</blockquote>
<pre><code class="java">interface A &#123;
    void a();

    void b();

    void c();

    void d();
&#125;

abstract class B implements A &#123;
    public void c() &#123;
        System.out.println(&quot;I am C&quot;);
    &#125;
&#125;

class M extends B &#123;
    public void a() &#123;
        System.out.println(&quot;I am a&quot;);
    &#125;

    public void b() &#123;
        System.out.println(&quot;I am b&quot;);
    &#125;

    public void d() &#123;
        System.out.println(&quot;I am d&quot;);
    &#125;
&#125;

class Test5 &#123;
    public static void main(String args[]) &#123;
        A a = new M();
        a.a();
        a.b();
        a.c();
        a.d();
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行结果如下 -</p>
<pre><code class="java">I am a
I am b
I am c
I am d
</code></pre>
<h1 id="Java接口"><a href="#Java接口" class="headerlink" title="Java接口"></a>Java接口</h1><p>java中的接口是类的蓝图。 它有静态常量和抽象方法。java中的接口是一种实现抽象的机制。 接口中只有抽象方法而不是方法体。接口用于在Java中实现抽象和多重继承。</p>
<p>Java接口也表示IS-A关系。它不能像抽象类一样被实例化。</p>
<h2 id="为什么要使用Java接口？"><a href="#为什么要使用Java接口？" class="headerlink" title="为什么要使用Java接口？"></a>为什么要使用Java接口？</h2><p>需要使用接口主要有三个原因。如下面给出。</p>
<ul>
<li>它用于实现抽象。</li>
<li>通过接口，可以支持多重继承的功能。</li>
<li>它可用于实现松耦合。</li>
</ul>
<h2 id="Java-8接口的改进"><a href="#Java-8接口的改进" class="headerlink" title="Java 8接口的改进"></a>Java 8接口的改进</h2><p>由于Java 8，接口可以有默认和静态方法，稍后讨论。</p>
<p><strong>由编译器内部添加</strong><br>java编译器在接口方法之前添加<code>public</code>和<code>abstract</code>关键字。还有，它在数据成员之前添加<code>public</code>，<code>static</code>和<code>final</code>关键字。</p>
<p>换句话说，接口字段默认是<code>public</code>，<code>static</code>和<code>final</code>，方法默认是<code>public</code>和<code>abstract</code>。</p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0703/957110359_32640.png" alt="img"></p>
<h2 id="了解类和接口之间的关系"><a href="#了解类和接口之间的关系" class="headerlink" title="了解类和接口之间的关系"></a>了解类和接口之间的关系</h2><p>如下图所示，一个类扩展了另一个类，一个接口扩展了另一个接口，一个类实现了一个接口。<br><img src="http://www.yiibai.com/uploads/images/201703/0703/573120302_99574.png" alt="img"></p>
<p><strong>Java接口示例</strong></p>
<p>在这个例子中，<code>Printable</code>接口只有一个方法，它的实现是在<code>A</code>类中提供的。</p>
<pre><code class="java">interface printable &#123;
    void print();
&#125;

class A6 implements printable &#123;
    public void print() &#123;
        System.out.println(&quot;Hello, Interface&quot;);
    &#125;

    public static void main(String args[]) &#123;
        A6 obj = new A6();
        obj.print();
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行结果如下 - </p>
<pre><code class="java">Hello, Interface
Java
</code></pre>
<p><strong>Java接口示例：Drawable</strong></p>
<p>在这个例子中，<code>Drawable</code>接口只有一个方法。 它的实现由<code>Rectangle</code>和<code>Circle</code>类提供。 在实际情况下，接口由一些开发者定义，但实现由不同的实现提供者提供。 并且它被别人使用。实现部分被使用接口的用户隐藏。</p>
<p>创建一个 Java 文件：<code>TestInterface1.java</code>，其代码如下 -</p>
<pre><code class="java">//Interface declaration: by first user  
interface Drawable &#123;
    void draw();
&#125;

// Implementation: by second user
class Rectangle implements Drawable &#123;
    public void draw() &#123;
        System.out.println(&quot;drawing rectangle&quot;);
    &#125;
&#125;

class Circle implements Drawable &#123;
    public void draw() &#123;
        System.out.println(&quot;drawing circle&quot;);
    &#125;
&#125;

// Using interface: by third user
class TestInterface1 &#123;
    public static void main(String args[]) &#123;
        Drawable d = new Circle();// In real scenario, object is provided by
                                    // method e.g. getDrawable()
        d.draw();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码得到以下结果 -</p>
<pre><code class="java">drawing circle
Java
</code></pre>
<p><strong>Java接口示例：Bank</strong></p>
<p>让我们来看看另一个提供了<code>Bank</code>接口实现的java接口的例子。创建一个 Java 文件：<code>TestInterface2.java</code>，其代码如下 -</p>
<pre><code class="java">interface Bank &#123;
    float rateOfInterest();
&#125;

class SBI implements Bank &#123;
    public float rateOfInterest() &#123;
        return 9.15f;
    &#125;
&#125;

class PNB implements Bank &#123;
    public float rateOfInterest() &#123;
        return 9.7f;
    &#125;
&#125;

class TestInterface2 &#123;
    public static void main(String[] args) &#123;
        Bank b = new SBI();
        System.out.println(&quot;ROI: &quot; + b.rateOfInterest());
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码得到以下结果 -</p>
<pre><code class="java">ROI: 9.15
Java
</code></pre>
<h2 id="Java多继承接口"><a href="#Java多继承接口" class="headerlink" title="Java多继承接口"></a>Java多继承接口</h2><p>如果一个类实现了多个接口，或者一个接口扩展了多个接口，即被称为多重继承。</p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0703/469120316_18026.png" alt="img"></p>
<p>参考以下示例代码的实现 -</p>
<pre><code class="java">interface Printable &#123;
    void print();
&#125;

interface Showable &#123;
    void show();
&#125;

class A7 implements Printable, Showable &#123;
    public void print() &#123;
        System.out.println(&quot;Hello&quot;);
    &#125;

    public void show() &#123;
        System.out.println(&quot;Welcome&quot;);
    &#125;

    public static void main(String args[]) &#123;
        A7 obj = new A7();
        obj.print();
        obj.show();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码得到以下结果 -</p>
<pre><code class="java">Hello
Welcome
Java
</code></pre>
<p><strong>问题：在java中不支持通过类实现多继承，但可通过接口实现，为什么？</strong></p>
<p>正如在继承章节中所解释的，在类中不支持多重继承是因为模糊。 但是在接口的情况下可以支持，因为接口没有歧义，接口的具体实现由实现类提供。 例如：</p>
<pre><code class="java">interface Printable &#123;
    void print();
&#125;

interface Showable &#123;
    void print();
&#125;

class TestTnterface3 implements Printable, Showable &#123;
    public void print() &#123;
        System.out.println(&quot;Hello&quot;);
    &#125;

    public static void main(String args[]) &#123;
        TestTnterface1 obj = new TestTnterface1();
        obj.print();
    &#125;
&#125;
Java
</code></pre>
<p>上面代码执行得到以下结果 -</p>
<pre><code class="java">Hello
Java
</code></pre>
<p>从上面的例子可以看到，<code>Printable</code>和<code>Showable</code>接口有相同的方法，但它的实现是由<code>TestTnterface1</code>类提供的，所以没有歧义。</p>
<h2 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h2><p>类可以实现多个接口，但接口也扩展另一个接口。</p>
<pre><code class="java">interface Printable &#123;
    void print();
&#125;

interface Showable extends Printable &#123;
    void show();
&#125;

class TestInterface4 implements Showable &#123;
    public void print() &#123;
        System.out.println(&quot;Hello&quot;);
    &#125;

    public void show() &#123;
        System.out.println(&quot;Welcome&quot;);
    &#125;

    public static void main(String args[]) &#123;
        TestInterface4 obj = new TestInterface4();
        obj.print();
        obj.show();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，得到如下结果 -</p>
<pre><code class="java">Hello
Welcome
Java
</code></pre>
<h3 id="Java-8接口中的默认方法"><a href="#Java-8接口中的默认方法" class="headerlink" title="Java 8接口中的默认方法"></a>Java 8接口中的默认方法</h3><p>从Java 8开始，我们可以在接口中有方法体。 但需要使其为默认方法。现在来看看一个例子，创建一个Java文件：<code>TestInterfaceDefault.java</code>，其代码如下 -</p>
<pre><code class="java">interface Drawable &#123;
    void draw();

    default void msg() &#123;
        System.out.println(&quot;default method&quot;);
    &#125;
&#125;

class Rectangle implements Drawable &#123;
    public void draw() &#123;
        System.out.println(&quot;drawing rectangle&quot;);
    &#125;
&#125;

class TestInterfaceDefault &#123;
    public static void main(String args[]) &#123;
        Drawable d = new Rectangle();
        d.draw();
        d.msg();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，得到如下结果 -</p>
<pre><code class="java">drawing rectangle
default method
Java
</code></pre>
<h3 id="Java-8接口中的静态方法"><a href="#Java-8接口中的静态方法" class="headerlink" title="Java 8接口中的静态方法"></a>Java 8接口中的静态方法</h3><p>从Java 8开始，我们可以在接口中有静态方法。 让我们来看看下面的一个例子，创建一个Java文件：<code>TestInterfaceStatic.java</code> 其代码如下：</p>
<pre><code class="java">interface Drawable &#123;
    void draw();

    static int cube(int x) &#123;
        return x * x * x;
    &#125;
&#125;

class Rectangle implements Drawable &#123;
    public void draw() &#123;
        System.out.println(&quot;drawing rectangle&quot;);
    &#125;
&#125;

class TestInterfaceStatic &#123;
    public static void main(String args[]) &#123;
        Drawable d = new Rectangle();
        d.draw();
        System.out.println(Drawable.cube(3));
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，得到如下结果 -</p>
<pre><code class="java">drawing rectangle
27
Java
</code></pre>
<p><strong>问题：什么是标记或标记的接口？</strong></p>
<p>没有成员的接口(仅定义一个空的接口)称为标记或标记接口。 例如：可序列化，可克隆，远程等。它们用于向JVM提供一些基本信息，以便JVM可以执行一些有用的操作。</p>
<pre><code class="java">//How Serializable interface is written?  
public interface Serializable&#123;  
&#125;
Java
</code></pre>
<p><strong>Java嵌套接口</strong></p>
<p><strong>注意：</strong> 一个接口中可以有另一个接口，即被称为嵌套接口。有关于这方面的知识，将在<a target="_blank" rel="noopener" href="http://www.yiibai.com/java/nested-interface.html">嵌套类</a>的章节中详细学习。 例如：</p>
<pre><code class="java">interface printable &#123;
    void print();

    interface MessagePrintable &#123;
        void msg();
    &#125;
&#125;
</code></pre>
<h1 id="Java抽象类和接口的区别"><a href="#Java抽象类和接口的区别" class="headerlink" title="Java抽象类和接口的区别"></a>Java抽象类和接口的区别</h1><p>抽象类和接口之间的区别是一个流行的问试问题。抽象类和接口是java编程语言的核心部分。是选择接口还是抽象类是每个架构师都面临的设计决策。</p>
<p>在本系列Java教程中，提供了有关<a target="_blank" rel="noopener" href="https://www.yiibai.com/java/interface-in-java.html">java接口</a>和<a target="_blank" rel="noopener" href="https://www.yiibai.com/java/abstract-class-in-java.html">抽象类</a>的讲解和示例。</p>
<p>抽象类和接口都用于实现抽象，可以声明抽象方法。抽象类和接口都不能被实例化。但是在下面给出的抽象类和接口之间有许多区别。</p>
<table>
<thead>
<tr>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>抽象类可以有抽象和非抽象方法。</td>
<td>接口只能有抽象方法。从Java 8开始，它也可以有默认和静态方法。</td>
</tr>
<tr>
<td>抽象类不支持多重继承。</td>
<td>接口支持多继承。</td>
</tr>
<tr>
<td>抽象类可以有<code>final</code>，非<code>final</code>，静态和非静态变量。</td>
<td>接口只有静态和<code>final</code>变量。</td>
</tr>
<tr>
<td>抽象类可以提供接口的实现。</td>
<td>接口不能提供抽象类的实现。</td>
</tr>
<tr>
<td><code>abstract</code>关键字用来声明抽象类。</td>
<td><code>interface</code>关键字用于声明接口。</td>
</tr>
</tbody></table>
<p>简单地说，抽象类实现了部分抽象(0到100％)，而接口实现了完全抽象(100％)。</p>
<h4 id="使用抽象类和接口"><a href="#使用抽象类和接口" class="headerlink" title="使用抽象类和接口"></a>使用抽象类和接口</h4><p>在大多数时候，使用接口和抽象类是设计系统的最佳方法，例如在JDK中<code>java.util.List</code>是一个包含很多方法的接口，因此有一个抽象类　－　<code>java.util.AbstractLis</code>为<code>List</code>接口的所有方法提供基础实现，以便任何子类都可以扩展此类并仅实现所需的方法。</p>
<p>应该始终以接口为基础并在定义每个子类时都应该实现方法，如果有一些方法只应该实现某些子类，可以扩展基接口并使用这些方法创建一个新接口。子类可以选择在基接口或子接口之间进行选择，以根据其要求实现。如果方法的数量增长很多，那么提供一个实现子接口的骨架抽象类并为子类提供在接口和抽象类之间进行选择的灵活性也是一个不错的做法。</p>
<h4 id="Java抽象类和接口的示例"><a href="#Java抽象类和接口的示例" class="headerlink" title="Java抽象类和接口的示例"></a>Java抽象类和接口的示例</h4><p>让我们来看看下面一个简单的例子，使用接口和抽象类。</p>
<pre><code class="java">//创建具有4种方法的接口
interface A &#123;
    void a();// 默认使用修辞符是：public 和 abstract

    void b();

    void c();

    void d();
&#125;

// 创建实现接口A的方法的抽象类
// 
abstract class B implements A &#123;
    public void c() &#123;
        System.out.println(&quot;I am C&quot;);
    &#125;
&#125;

// 创建抽象类的子类，需要提供抽象类方法的实现
class M extends B &#123;
    public void a() &#123;
        System.out.println(&quot;I am a&quot;);
    &#125;

    public void b() &#123;
        System.out.println(&quot;I am b&quot;);
    &#125;

    public void d() &#123;
        System.out.println(&quot;I am d&quot;);
    &#125;
&#125;

// 创建一个调用A接口方法的测试类
class Test5 &#123;
    public static void main(String args[]) &#123;
        A a = new M();
        a.a();
        a.b();
        a.c();
        a.d();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面的示例代码，得到以下结果 -</p>
<pre><code class="shell">I am a
I am b
I am c
I am d
</code></pre>
<h1 id="Java包-1"><a href="#Java包-1" class="headerlink" title="Java包"></a>Java包</h1><p>一个java包是一组相似类型的类，接口和子包。java中的包可以分为两种形式，内置包和用户定义包。</p>
<p>java中有很多内置的包，如：<code>java</code>，<code>lang</code>，<code>awt</code>，<code>javax</code>，<code>swing</code>，<code>net</code>，<code>io</code>，<code>util</code>，<code>sql</code>等。</p>
<p>在这里，我们将详细学习创建和使用用户定义的包。</p>
<p><strong>Java包的优点</strong></p>
<ol>
<li>Java包用于对类和接口进行分类，以便更好地维护它们。</li>
<li>Java包提供访问保护。</li>
<li>Java包消除命名冲突。</li>
</ol>
<p><img src="http://www.yiibai.com/uploads/images/201703/0703/948140330_85972.png" alt="img"></p>
<p><strong>java包的简单示例</strong></p>
<p><code>package</code>关键字用于在java中创建一个包。</p>
<pre><code class="java">//save as Simple.java  
package com.yiibai;

public class Simple &#123;
    public static void main(String args[]) &#123;
        System.out.println(&quot;Welcome to package&quot;);
    &#125;
&#125;
Java
</code></pre>
<p><strong>如何编译java包</strong></p>
<p>如果您没有使用任何IDE，则需要遵循以下语法：</p>
<pre><code class="java">javac -d directory javafilename
Java
</code></pre>
<p><strong>例如</strong></p>
<pre><code class="java">javac -d . Simple.java
Java
</code></pre>
<p><code>-d</code> 指定放置生成的类文件的目标位置。 您可以使用任何目录名称，如<code>/home</code>(在Linux的情况下)，<code>D:\workspace</code>(在Windows的情况下)等。如果想保持包在同一目录，可以使用<code>.</code>(点)表示当前目录。</p>
<p><strong>如何运行java包程序</strong></p>
<p>您需要使用完全限定(指定)名称。如：<code>com.yiibai.Simple</code>等来运行类。</p>
<p><strong>编译</strong>：<code>javac -d . Simple.java</code><br><strong>运行</strong>：<code>java com.yiibai.Simple</code></p>
<p>输出结果如下 -</p>
<pre><code class="java">Welcome to package
Java
</code></pre>
<p><code>-d</code>是一个开关，它告诉编译器放置类文件的位置，即它代表目的地。 <code>.</code>(点符号)表示当前文件夹。</p>
<p><strong>如何从一个包中访问另一个包？</strong></p>
<p>有三种方法从包外部来访问一个包。它们分别如下 - </p>
<ol>
<li>import package.*;</li>
<li>import package.classname;</li>
<li>完全限定名</li>
</ol>
<h2 id="1-使用-packagename"><a href="#1-使用-packagename" class="headerlink" title="1. 使用 packagename."></a>1. 使用 packagename.</h2><p>如果使用<code>package.*</code>，那么这个包的所有类和接口都是可访问的，而不是子包。<br><code>import</code>关键字用于使当前包可访问的另一个包的类和接口。<br>导入<code>packagename</code>的包的示例。<br>一个Java文件：<code>A.java</code>，在 <code>pack</code> 包下。</p>
<pre><code class="java">//save by A.java  
package pack;  
public class A&#123;  
    public void msg()&#123;System.out.println(&quot;Hello&quot;);&#125;  
&#125;
Java
</code></pre>
<p>另一个Java文件：<code>B.java</code>，在 <code>mypack</code> 包下，下面看看它是如何引用 <code>pack</code> 包中的 <code>A.java</code> 这个类。</p>
<pre><code class="java">//save by B.java  
package mypack;  
import pack.*;  

class B&#123;  
  public static void main(String args[])&#123;  
     A obj = new A();  
     obj.msg();  
  &#125;  
&#125;
Java
</code></pre>
<p>执行上面代码，输出结果如下 -</p>
<pre><code>Hello
</code></pre>
<h2 id="2-使用packagename-classname"><a href="#2-使用packagename-classname" class="headerlink" title="2. 使用packagename.classname"></a>2. 使用packagename.classname</h2><p>如果要导入<code>package.classname</code>，那么只有这个包的类声明为可访问的。</p>
<p><strong>通过导入<code>package.classname</code>的包的示例</strong><br>以下是 <code>A.java</code> 文件中的代码 - </p>
<pre><code class="java">//save by A.java  

package pack;  
public class A&#123;  
  public void msg()&#123;System.out.println(&quot;Hello&quot;);&#125;  
&#125;
Java
</code></pre>
<p>以下是 <code>B.java</code> 文件中的代码 - </p>
<pre><code class="java">//save by B.java  
package mypack;

import pack.A;

class B &#123;
    public static void main(String args[]) &#123;
        A obj = new A();
        obj.msg();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，输出结果如下 -</p>
<pre><code>Hello
</code></pre>
<h2 id="3-使用完全限定名"><a href="#3-使用完全限定名" class="headerlink" title="3. 使用完全限定名"></a>3. 使用完全限定名</h2><p>如果使用完全限定名，那么只有这个包的声明类将可访问。现在没有必要导入，但是需要在每次访问类或接口时使用完全限定名。<br>它通常用于两个包具有相同类名的情况。 <code>java.util</code>和<code>java.sql</code>包包含<code>Date</code>类。</p>
<p><strong>通过导入完全限定名称的包的示例</strong><br>创建一个Java文件：<code>A.java</code>，其代码如下所示 -</p>
<pre><code class="java">//save by A.java  
package pack;

public class A &#123;
    public void msg() &#123;
        System.out.println(&quot;Hello&quot;);
    &#125;
&#125;
Java
</code></pre>
<p>创建另一个Java文件：<code>B.java</code>，其代码如下所示 -</p>
<pre><code class="java">//save by B.java  
package mypack;

class B &#123;
    public static void main(String args[]) &#123;
        pack.A obj = new pack.A();// using fully qualified name
        obj.msg();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，得到以下结果 -</p>
<pre><code class="shell">Hello
Shell
</code></pre>
<blockquote>
<p><strong>注意</strong>：如果导入包，则不会导入子包。</p>
</blockquote>
<p>如果导入包，则将导入该包的所有类和接口，但不包括子包的类和接口。 因此，您还需要导入子包。</p>
<p><strong>注意：</strong>程序的序列必须先是包，然后再导入类。</p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0703/861170333_30787.jpg" alt="img"></p>
<h2 id="在java中的子包"><a href="#在java中的子包" class="headerlink" title="在java中的子包"></a>在java中的子包</h2><p>包内的包称为子包。创建它用以进一步分类包。<br>举个例子，<strong>Sun Microsystem</strong>定义了一个名为<code>java</code>的包，其中包含了很多类，比如<code>System</code>，<code>String</code>，<code>Reader</code>，<code>Writer</code>，<code>Socket</code>等。 <code>Reader</code>和<code>Writer</code>类用于输入/输出操作，<code>Socket</code>和<code>ServerSocket</code>类用于网络等等。 所以，Sun已经将java包子类化为子包，如：<code>lang</code>，<code>net</code>，<code>io</code>等，并将输入/输出相关类放在<code>io</code>包中，将<code>Server</code>和<code>ServerSocket</code>类放在<code>net</code>包中等等。</p>
<blockquote>
<p>注：定义包的标准是<code>domain.company.package</code>,例如：<code>com.yiibai.bean</code>或<code>org.apache.dao</code>。</p>
</blockquote>
<p><strong>子包示例</strong></p>
<pre><code class="java">package com.yiibai.core;

class Simple &#123;
    public static void main(String args[]) &#123;
        System.out.println(&quot;Hello subpackage&quot;);
    &#125;
&#125;
Java
</code></pre>
<p><strong>编译执行的命令</strong>：<code>javac -d . Simple.java</code><br><strong>运行执行的命令</strong>：<code>java com.yiibai.core.Simple</code></p>
<pre><code class="java">Hello subpackage
Java
</code></pre>
<p><strong>如何将类文件发送到另一个目录或驱动器？</strong></p>
<p>有一个场景，想要把<code>A.java</code>源文件的类文件放在<code>C</code> 盘的<code>classes</code>文件夹中。 例如：</p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0703/148170344_58434.jpg" alt="img"></p>
<p>首先在 <code>E:\source</code> 目录中创建 <code>A.java</code> 文件，如下代码 - </p>
<pre><code class="java">//save as Simple.java  
package mypack;

public class Simple &#123;
    public static void main(String args[]) &#123;
        System.out.println(&quot;Welcome to package&quot;);
    &#125;
&#125;
Java
</code></pre>
<p><strong>编译：</strong></p>
<pre><code class="shell">E:\sources&gt; javac -d c:\classes Simple.java
Shell
</code></pre>
<p><strong>运行：</strong><br>要在<code>E:\source</code>目录运行此程序，需要设置类文件所在目录的类路径。</p>
<pre><code class="java">e:\sources&gt; set classpath=c:\classes;.;
e:\sources&gt; java mypack.Simple
Java
</code></pre>
<p><strong>另一种方式运行这个程序通过 -classpath切换java：</strong></p>
<p><code>-classpath</code>切换可以与<code>javac</code>和<code>java</code>工具一起使用。</p>
<p>要在<code>E:\source</code>目录运行此程序，可以使用java的<code>-classpath</code>选项，告诉在哪里查找类文件。 例如：</p>
<pre><code class="java">e:\sources&gt; java -classpath c:\classes mypack.Simple
Java
</code></pre>
<p>执行上面代码，得到以下结果 - </p>
<pre><code class="java">Welcome to package
Java
</code></pre>
<p><strong>加载类文件或jar文件的方式</strong><br>有两种方法用来临时和永久加载类文件。</p>
<ul>
<li>加载临时类文件<ul>
<li>通过在命令提示符中设置类路径</li>
<li>通过 <code>-classpath</code> 开关选项</li>
</ul>
</li>
<li>永久加载类文件<ul>
<li>通过在环境变量中设置类路径</li>
<li>通过创建jar文件，其中包含所有类文件，并将jar文件复制到JDK安装目录的<code>jre/lib/ext</code>文件夹中。</li>
</ul>
</li>
</ul>
<blockquote>
<p>规则：在java源文件中只能有一个公共类，它必须以公共类的名称保存。</p>
</blockquote>
<pre><code class="java">//save as C.java otherwise Compilte Time Error  

class A &#123;
&#125;

class B &#123;
&#125;

public class C &#123;
&#125;
Java
</code></pre>
<p><strong>如何将两个公共类放在包中？</strong></p>
<p>如果想把两个公共类放在同一个包中，有两个java源文件都包含一个公共类，只需保持包名称相同即可。 例如：<br>文件：<code>A.java</code>，代码如下所示 -</p>
<pre><code class="java">//save as A.java  

package yiibai;  
public class A&#123;&#125;
Java
</code></pre>
<p>文件：<code>B.java</code>，代码如下所示 -</p>
<pre><code class="java">//save as B.java  

package yiibai;  
public class B&#123;&#125;
</code></pre>
<h1 id="Java访问修饰符"><a href="#Java访问修饰符" class="headerlink" title="Java访问修饰符"></a>Java访问修饰符</h1><p>java中有两种类型的修饰符：访问修饰符和非修饰符。<br>java中的访问修饰符指定数据成员，方法，构造函数或类的辅助功能(范围)。<br>一共有<code>4</code>种类型的java访问修饰符：</p>
<ul>
<li><code>private</code></li>
<li><code>default</code></li>
<li><code>protected</code></li>
<li><code>public</code></li>
</ul>
<p>有许多非访问修饰符，如：<code>static</code>, <code>abstract</code>, <code>synchronized</code>, <code>native</code>, <code>volatile</code>, <code>transient</code>等修饰符。这里，我们将只学习访问修饰符。</p>
<h2 id="private访问修饰符"><a href="#private访问修饰符" class="headerlink" title="private访问修饰符"></a>private访问修饰符</h2><p>私有(<code>private</code>)访问修饰符只能在类中访问。</p>
<p><strong>private访问修饰符的简单示例</strong></p>
<p>在这个例子中，我们创建了两个类:<code>A</code>和<code>Simple</code>。 类包含私有数据成员和私有方法。 我们从类外访问这些私有成员，所以会产生编译时错误。</p>
<pre><code class="java">class A &#123;
    private int data = 40;

    private void msg() &#123;
        System.out.println(&quot;Hello java&quot;);
    &#125;
&#125;

public class Simple &#123;
    public static void main(String args[]) &#123;
        A obj = new A();
        System.out.println(obj.data);// 私有变量，不可以从外部类中直接访问，因此有编译错误
        obj.msg();// 私有方法，不可以从外部类中直接访问，因此有编译错误
    &#125;
&#125;
Java
</code></pre>
<h2 id="1-private访问修饰符"><a href="#1-private访问修饰符" class="headerlink" title="1. private访问修饰符"></a>1. private访问修饰符</h2><p>如果将类的构造函数声明为私有，则不能从类外部创建该类的实例。 例如：</p>
<pre><code class="java">class A &#123;
    private A() &#123;
    &#125;// private constructor

    void msg() &#123;
        System.out.println(&quot;Hello java&quot;);
    &#125;
&#125;

public class Simple &#123;
    public static void main(String args[]) &#123;
        A obj = new A();// Compile Time Error
    &#125;
&#125;
Java
</code></pre>
<blockquote>
<p><strong>注意：</strong>类不能是私有或保护，除非是嵌套类。</p>
</blockquote>
<h2 id="2-default访问修饰符"><a href="#2-default访问修饰符" class="headerlink" title="2. default访问修饰符"></a>2. default访问修饰符</h2><p>如果不使用任何修饰符，默认情况下将其视为<code>default</code>修饰符。<code>default</code>修饰符只能在包内访问。</p>
<p><strong>default访问修饰符示例</strong></p>
<p>在这个例子中，我们创建了两个包<code>pack</code>和<code>mypack</code>。从它的包外部访问<code>A</code>类，因为一个类不是<code>public</code>的，所以它不能从包外部访问。如下两个类：<code>A.java</code> 和 <code>B.java</code> 代码。</p>
<pre><code class="java">//save by A.java  
package pack;  
class A&#123;  
    void msg()&#123;System.out.println(&quot;Hello&quot;);&#125;  
&#125;
Java
</code></pre>
<p><code>B.java</code> 代码的代码如下 - </p>
<pre><code class="java">//save by B.java  
package mypack;

import pack.*;

class B &#123;
    public static void main(String args[]) &#123;
        A obj = new A();// Compile Time Error
        obj.msg();// Compile Time Error
    &#125;
&#125;
Java
</code></pre>
<p>在上面的例子中，<code>A</code>类的范围和它的方法<code>msg()</code>是默认(<code>default</code>)的，所以它不能从包外部访问。</p>
<h2 id="3-protected访问修饰符"><a href="#3-protected访问修饰符" class="headerlink" title="3. protected访问修饰符"></a>3. protected访问修饰符</h2><p><code>protected</code>访问修饰符可以在包中和包外部访问，但只能通过继承。<code>protected</code>访问修饰符可以应用于数据成员，方法和构造函数。 它不能应用于类。</p>
<p><strong>protected访问修饰符的示例</strong></p>
<p>在这个例子中，我们创建了两个包<code>pack</code>和<code>mypack</code>。 <code>A</code>类的包是<code>public</code>的，所以可以从外部访问包。 但是这个包的<code>msg</code>方法声明为<code>protected</code>，因此只能通过继承从类外面访问它。如下两个类：<code>A.java</code> 和 <code>B.java</code> 代码。</p>
<pre><code class="java">//save by A.java  
package pack;

public class A &#123;
    protected void msg() &#123;
        System.out.println(&quot;Hello&quot;);
    &#125;
&#125;
Java
</code></pre>
<p> <code>B.java</code> 代码如下 - </p>
<pre><code class="java">//save by B.java  
package mypack;

import pack.*;

class B extends A &#123;
    public static void main(String args[]) &#123;
        B obj = new B();
        obj.msg();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，得到如下结果 -</p>
<pre><code class="java">Hello
Java
</code></pre>
<h2 id="4-public访问修饰符"><a href="#4-public访问修饰符" class="headerlink" title="4. public访问修饰符"></a>4. public访问修饰符</h2><p>公共(<code>public</code>)访问修饰符可随处访问。 它在所有其他修饰符中具有最广泛的范围。</p>
<p><strong>public访问修饰符示例</strong></p>
<p>如下两个类：<code>A.java</code> 和 <code>B.java</code> 代码。</p>
<p><code>A.java</code> 的代码</p>
<pre><code class="java">//save by A.java  

package pack;

public class A &#123;
    public void msg() &#123;
        System.out.println(&quot;Hello&quot;);
    &#125;
&#125;
Java
</code></pre>
<p> <code>B.java</code> 的代码</p>
<pre><code class="java">//save by B.java  

package mypack;

import pack.*;

class B &#123;
    public static void main(String args[]) &#123;
        A obj = new A();
        obj.msg();
    &#125;
&#125;
Java
</code></pre>
<p>执行上面的代码，得到以下结果 -</p>
<pre><code class="java">Hello
Java
</code></pre>
<h2 id="理解所有java访问修饰符"><a href="#理解所有java访问修饰符" class="headerlink" title="理解所有java访问修饰符"></a>理解所有java访问修饰符</h2><p>让我们通过下面的一个简单的表来理解访问修饰符。</p>
<table>
<thead>
<tr>
<th>访问修饰符</th>
<th>在类内</th>
<th>在包内</th>
<th>外部包只通过子类</th>
<th>外部包</th>
</tr>
</thead>
<tbody><tr>
<td>Private</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>Default</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>Protected</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Public</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
<p>如果你要覆盖任何方法，重写的方法(即在子类中声明)则不能声明得更严格。</p>
<pre><code class="java">class A &#123;
    protected void msg() &#123;
        System.out.println(&quot;Hello java&quot;);
    &#125;
&#125;

public class Simple extends A &#123;
    void msg() &#123;
        System.out.println(&quot;Hello java&quot;);
    &#125;// C.T.Error

    public static void main(String args[]) &#123;
        Simple obj = new Simple();
        obj.msg();
    &#125;
&#125;
Java
</code></pre>
<p>默认(<code>default</code>)修饰符比受保护的修饰符更严格。 这就是为什么有编译时错误。</p>
<h1 id="Java封装"><a href="#Java封装" class="headerlink" title="Java封装"></a>Java封装</h1><p>java中的封装是将代码和数据一起封装到单个单元中的过程，例如胶囊，即几种药物的混合。</p>
<p>我们可以通过将类的所有数据成员设为<code>private</code>，以在java中创建一个完全封装的类。现在我们可以使用<code>setter</code>和<code>getter</code>方法来设置和获取其中的数据。</p>
<p>Java Bean类是完全封装类的示例。</p>
<h2 id="在java中封装的优势"><a href="#在java中封装的优势" class="headerlink" title="在java中封装的优势"></a>在java中封装的优势</h2><p>通过仅提供<code>setter</code>或<code>getter</code>方法，可以使类为只读或只写。<br>它为您提供对数据的控制。 假设要设置<code>id</code>的值，即：要求大于<code>100</code>，您可以在<code>setter</code>方法内写入逻辑。</p>
<p><strong>在java中封装的简单示例</strong></p>
<p>让我们来看看一个简单的封装示例，它只有一个字段及其<code>setter</code>和<code>getter</code>方法。</p>
<pre><code class="java">//save as Student.java  
package com.yiibai;

public class Student &#123;
    private String name;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;
Java
</code></pre>
<p><code>Test.java</code> 的代码如下 - </p>
<pre><code class="java">//save as Test.java  
package com.yiibai;

class Test &#123;
    public static void main(String[] args) &#123;
        Student s = new Student();
        s.setName(&quot;vijay&quot;);
        System.out.println(s.getName());
    &#125;
&#125;
Java
</code></pre>
<p><strong>编译:</strong> <code>javac -d . Test.java</code><br><strong>运行:</strong> <code>java com.yiibai.Test</code></p>
<p>上面代码输出结果如下 - </p>
<pre><code class="java">vijay
</code></pre>
<h1 id="Java-Object类"><a href="#Java-Object类" class="headerlink" title="Java Object类"></a>Java Object类</h1><p>默认情况下，<code>Object</code>类是java中所有类的父类。 换句话说，它是java的顶级类。</p>
<p>如果想引用你不知道的类型的对象，使用<code>Object</code>类是没有错的。请注意，父类引用变量可以引用子类对象，称为上转换。</p>
<p>下面举一个例子，有一个<code>getObject()</code>方法返回一个对象，但它可以是任何类型，如：<code>Employee</code>，<code>Student</code>等这样的类，我们可以使用<code>Object</code>类引用来引用该对象。 例如：</p>
<pre><code class="java">Object obj=getObject();//we don&#39;t know what object will be returned from this method
Java
</code></pre>
<p><code>Object</code>类为所有对象提供了一些常见的行为，如对象可以进行比较，对象可以克隆，对象可以通知等。</p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0803/878080359_28912.gif" alt="img"></p>
<h2 id="Object类的方法"><a href="#Object类的方法" class="headerlink" title="Object类的方法"></a>Object类的方法</h2><p><code>Object</code>类提供了许多方法。 它们如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>public final Class getClass()</code></td>
<td>返回此对象的<code>Class</code>类对象。 <code>Class</code>类可以进一步用于获取此类的元数据。</td>
</tr>
<tr>
<td><code>public int hashCode()</code></td>
<td>返回此对象的哈希码值</td>
</tr>
<tr>
<td><code>public boolean equals(Object obj)</code></td>
<td>将给定对象与此对象进行比较。</td>
</tr>
<tr>
<td><code>protected Object clone() throws CloneNotSupportedException</code></td>
<td>创建并返回此对象的精确副本(克隆)。</td>
</tr>
<tr>
<td><code>public String toString()</code></td>
<td>返回此对象的字符串表示形式。</td>
</tr>
<tr>
<td><code>public final void notify()</code></td>
<td>唤醒单线程，等待此对象的监视器。</td>
</tr>
<tr>
<td><code>public final void notifyAll()</code></td>
<td>唤醒所有线程，等待此对象的监视器。</td>
</tr>
<tr>
<td><code>public final void wait(long timeout)throws InterruptedException</code></td>
<td>导致当前线程等待指定的毫秒，直到另一个线程通知(调用<code>notify()</code>或<code>notifyAll()</code>方法)。</td>
</tr>
<tr>
<td><code>public final void wait(long timeout,int nanos)throws InterruptedException</code></td>
<td>导致当前线程等待指定的毫秒和纳秒，直到另一个线程通知(调用<code>notify()</code>或<code>notifyAll()</code>方法)。</td>
</tr>
<tr>
<td><code>public final void wait()throws InterruptedException</code></td>
<td>导致当前线程等待，直到另一个线程通知(调用<code>notify()</code>或<code>notifyAll()</code>方法)。</td>
</tr>
<tr>
<td><code>protected void finalize()throws Throwable</code></td>
<td>在对象被垃圾收集之前由垃圾收集器调用。</td>
</tr>
</tbody></table>
<p>我们将在下一章详细学习这些方法。</p>
<h1 id="Java对象克隆"><a href="#Java对象克隆" class="headerlink" title="Java对象克隆"></a>Java对象克隆</h1><p>对象克隆是一种创建对象的精确副本的方法。 <code>Object</code>类的<code>clone()</code>方法用于克隆对象。<code>java.lang.Cloneable</code>接口必须由我们要创建其对象克隆的类实现。如果我们不实现<code>Cloneable</code>接口，<code>clone()</code>方法生成<code>CloneNotSupportedException</code>。</p>
<p><code>clone()</code>方法在<code>Object</code>类中定义。 <code>clone()</code>方法的语法如下：</p>
<pre><code class="java">protected Object clone() throws CloneNotSupportedException
Java
</code></pre>
<h2 id="为什么要使用clone-方法？"><a href="#为什么要使用clone-方法？" class="headerlink" title="为什么要使用clone()方法？"></a>为什么要使用clone()方法？</h2><p><code>clone()</code>方法保存用于创建对象的精确副本的额外处理任务。 如果我们使用<code>new</code>关键字执行它，它将需要执行大量的处理，这就是为什么我们使用对象克隆。</p>
<p><strong>对象克隆的优点</strong></p>
<ul>
<li>少处理任务。</li>
</ul>
<h2 id="clone-方法示例-对象克隆"><a href="#clone-方法示例-对象克隆" class="headerlink" title="clone()方法示例(对象克隆)"></a>clone()方法示例(对象克隆)</h2><p>让我们来看看对象克隆的简单例子</p>
<pre><code class="java">class Student18 implements Cloneable &#123;
    int rollno;
    String name;

    Student18(int rollno, String name) &#123;
        this.rollno = rollno;
        this.name = name;
    &#125;

    public Object clone() throws CloneNotSupportedException &#123;
        return super.clone();
    &#125;

    public static void main(String args[]) &#123;
        try &#123;
            Student18 s1 = new Student18(101, &quot;amit&quot;);

            Student18 s2 = (Student18) s1.clone();

            System.out.println(s1.rollno + &quot; &quot; + s1.name);
            System.out.println(s2.rollno + &quot; &quot; + s2.name);

        &#125; catch (CloneNotSupportedException c) &#123;
        &#125;

    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，得到如下结果 - </p>
<pre><code class="java">101 amit
101 amit
Java
</code></pre>
<p>从上面的例子可以看出，两个引用变量都有相同的值。 因此，<code>clone()</code>将对象的值复制到另一个对象。 因此，在实际应用中我们不需要编写显式代码将对象的值复制到另一个对象。</p>
<p>如果通过<code>new</code>关键字创建另一个对象并将另一个对象的值赋给这个对象，则需要对该对象进行大量处理。 所以为了节省额外的处理任务，我们使用<code>clone()</code>方法。</p>
<h1 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h1><p>通常，数组是具有连续内存位置的类似类型的元素的集合。Java数组是一个包含类似数据类型的元素的对象。 它是一个数据结构，我们存储类似的元素。 只能在java数组中存储固定的元素集合。</p>
<p>java中的数组是基于索引的，数组的第一个元素存储的索引为：<code>0</code>。</p>
<p><img src="http://www.yiibai.com/uploads/images/201703/0803/992090348_12650.gif" alt="img"></p>
<p><strong>Java Array的优点</strong></p>
<p><strong>代码优化：</strong> 它使代码优化，可以轻松地检索或排序数据。<br><strong>随机访问：</strong> 可以获取任何位于任何索引位置的数据。</p>
<p><strong>Java Array的缺点</strong></p>
<p><strong>大小限制：</strong> 只能在数组中存储固定大小的元素。 它在运行时不会增长其大小。 为了解决这个问题，在java中使用了集合框架。</p>
<p><strong>java中的数组类型</strong></p>
<p>有两种类型的数组。</p>
<ul>
<li>一维数组</li>
<li>多维数组</li>
</ul>
<p><strong>java中的单维数组</strong></p>
<p>在java中声明一个数组的语法。</p>
<pre><code class="java">dataType[] arr; (or)  
dataType []arr; (or)  
dataType arr[];
Java
</code></pre>
<p><strong>在java中实例化数组</strong></p>
<pre><code class="java">arrayRefVar=new datatype[size];
Java
</code></pre>
<p><strong>一维java数组的示例</strong></p>
<p>让我们来看看java数组的简单例子，下面声明，实例化，初始化和遍历数组。</p>
<pre><code class="java">class Testarray &#123;
    public static void main(String args[]) &#123;

        int a[] = new int[5];// declaration and instantiation
        a[0] = 10;// initialization
        a[1] = 20;
        a[2] = 70;
        a[3] = 40;
        a[4] = 50;

        // printing array
        for (int i = 0; i &lt; a.length; i++)// length is the property of array
            System.out.println(a[i]);

    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码的得到下面的结果 -</p>
<pre><code class="shell">10
20
70
40
50
Shell
</code></pre>
<p><strong>Java数组的声明，实例化和初始化</strong></p>
<p>可以通过以下方式声明，实例化和初始化java数组：</p>
<pre><code class="shell">int a[]=&#123;33,3,4,5&#125;;//declaration, instantiation and initialization
Shell
</code></pre>
<p>让我们来看看打印数组的简单例子。</p>
<pre><code class="java">class Testarray1 &#123;
    public static void main(String args[]) &#123;

        int a[] = &#123; 33, 3, 4, 5 &#125;;// declaration, instantiation and
                                    // initialization

        // printing array
        for (int i = 0; i &lt; a.length; i++)// length is the property of array
            System.out.println(a[i]);

    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，得到以下结果 -</p>
<pre><code class="java">33
3
4
5
Java
</code></pre>
<p><strong>在Java中将数组传递给方法</strong></p>
<p>我们可以将java数组传递给方法，以便可以在数组上重复使用相同的逻辑。</p>
<p>让我们来看看获取使用方法的数组的最小数的一个简单的例子。</p>
<pre><code class="java">class Testarray2 &#123;
    static void min(int arr[]) &#123;
        int min = arr[0];
        for (int i = 1; i &lt; arr.length; i++)
            if (min &gt; arr[i])
                min = arr[i];

        System.out.println(min);
    &#125;

    public static void main(String args[]) &#123;

        int a[] = &#123; 33, 3, 4, 5 &#125;;
        min(a);// passing array to method

    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，得到以下结果 -</p>
<pre><code class="java">3
Java
</code></pre>
<p>**<br>java中的多维数组**</p>
<p>在这种情况下，数据存储在基于行和列的索引(也称为矩阵形式)中。在Java中声明多维数组的语法。</p>
<pre><code class="java">dataType[][] arrayRefVar; (or)  
dataType [][]arrayRefVar; (or)  
dataType arrayRefVar[][]; (or)  
dataType []arrayRefVar[];
Java
</code></pre>
<p><strong>在java中实例化多维数组的示例</strong></p>
<pre><code class="java">int[][] arr=new int[3][3];//3 row and 3 column
Java
</code></pre>
<p><strong>在java中初始化多维数组的示例</strong></p>
<pre><code class="java">arr[0][0]=1;  
arr[0][1]=2;  
arr[0][2]=3;  
arr[1][0]=4;  
arr[1][1]=5;  
arr[1][2]=6;  
arr[2][0]=7;  
arr[2][1]=8;  
arr[2][2]=9;
Java
</code></pre>
<p><strong>多维java数组示例</strong></p>
<p>让我们来看看一个简单的例子来声明，实例化，初始化并打印二维数组。</p>
<pre><code class="java">class Testarray3 &#123;
    public static void main(String args[]) &#123;

        // declaring and initializing 2D array
        int arr[][] = &#123; &#123; 1, 2, 3 &#125;, &#123; 2, 4, 5 &#125;, &#123; 4, 4, 5 &#125; &#125;;

        // printing 2D array
        for (int i = 0; i &lt; 3; i++) &#123;
            for (int j = 0; j &lt; 3; j++) &#123;
                System.out.print(arr[i][j] + &quot; &quot;);
            &#125;
            System.out.println();
        &#125;

    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，得到以下结果 -</p>
<pre><code class="java">1 2 3
2 4 5
4 4 5
Java
</code></pre>
<p><strong>java数组的类名是什么？</strong></p>
<p>在java中，数组是一个对象。 对于数组对象，创建一个代理类，其名称可以通过对象上的<code>getClass()</code>。<code>getName()</code>方法获取。</p>
<pre><code class="java">class Testarray4 &#123;
    public static void main(String args[]) &#123;

        int arr[] = &#123; 4, 4, 5 &#125;;

        Class c = arr.getClass();
        String name = c.getName();

        System.out.println(name);

    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，得到以下代码 - </p>
<pre><code class="java">I
Java
</code></pre>
<p><strong>复制java数组</strong></p>
<p>可以通过<code>System</code>类的<code>arraycopy</code>方法将数组复制到另一个数组。</p>
<p><strong>arraycopy方法的语法</strong></p>
<pre><code class="java">public static void arraycopy(  
Object src, int srcPos,Object dest, int destPos, int length  
)
Java
</code></pre>
<p><strong>arraycopy方法的示例</strong></p>
<pre><code class="java">class TestArrayCopyDemo &#123;
    public static void main(String[] args) &#123;
        char[] copyFrom = &#123; &#39;d&#39;, &#39;e&#39;, &#39;c&#39;, &#39;a&#39;, &#39;f&#39;, &#39;f&#39;, &#39;e&#39;, &#39;i&#39;, &#39;n&#39;, &#39;a&#39;, &#39;t&#39;, &#39;e&#39;, &#39;d&#39; &#125;;
        char[] copyTo = new char[7];

        System.arraycopy(copyFrom, 2, copyTo, 0, 7);
        System.out.println(new String(copyTo));
    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，得到以下代码 - </p>
<pre><code class="java">caffein
Java
</code></pre>
<p><strong>在java中添加2个矩阵</strong></p>
<p>让我们来看看一个简单的例子，添加两个矩阵。</p>
<pre><code class="java">class Testarray5 &#123;
    public static void main(String args[]) &#123;
        // creating two matrices
        int a[][] = &#123; &#123; 1, 3, 4 &#125;, &#123; 3, 4, 5 &#125; &#125;;
        int b[][] = &#123; &#123; 1, 3, 4 &#125;, &#123; 3, 4, 5 &#125; &#125;;

        // creating another matrix to store the sum of two matrices
        int c[][] = new int[2][3];

        // adding and printing addition of 2 matrices
        for (int i = 0; i &lt; 2; i++) &#123;
            for (int j = 0; j &lt; 3; j++) &#123;
                c[i][j] = a[i][j] + b[i][j];
                System.out.print(c[i][j] + &quot; &quot;);
            &#125;
            System.out.println();// new line
        &#125;

    &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，得到以下代码 - </p>
<pre><code class="java">2 6 8
6 8 10
</code></pre>
<h1 id="Java包装类"><a href="#Java包装类" class="headerlink" title="Java包装类"></a>Java包装类</h1><p>java中的包装类提供了将原始数据类型转换为对象，以及将对象转换为原始数据类型的机制。</p>
<p>自J2SE 5.0以来，自动装箱和取消装箱功能将原始对象和对象自动转换为原始数据类型。将原始数据类型自动转换为对象称为自动装箱，反之亦然。</p>
<p><code>java.lang</code>包的八个类在java中称为包装类。八个包装类的列表如下：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<p><strong>为什么需要包装类？</strong></p>
<p>将原始类型和包装类分开以保持简单是一个明智的做法。当需要一个适合像面向对象编程的类型时就需要包装类。当希望数据类型变得简单时就使用原始类型。</p>
<p>原始类型不能为<code>null</code>，但包装类可以为<code>null</code>。包装类可用于实现多态性。</p>
<p>下面是一个简单的程序，显示了java中包装类的不同方面应用。</p>
<pre><code class="java">import java.util.ArrayList;
import java.util.List;

public class WrapperClasses &#123;

    private static void doSomething(Object obj)&#123;

    &#125;

    public static void main(String args[])&#123;
        int i = 10;
        char c = &#39;a&#39;;

        // 原始数据很容易使用
        int j = i+3;

        // 由包装类实现的多态性，不能在这里传递原始数据
        doSomething(new Character(c));

        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        // 包装类可以在集合中使用
        Integer in = new Integer(i);
        list.add(in);

        // 自动装箱负责原始到包装器类的转换
        list.add(j);

        //包装类可以为 null
        in = null;
    &#125;
&#125;
Java
</code></pre>
<p><strong>包装类示例：原始类型到包装类型</strong></p>
<pre><code class="java">public class WrapperExample1 &#123;
    public static void main(String args[]) &#123;
        // Converting int into Integer
        int a = 20;
        Integer i = Integer.valueOf(a);// converting int into Integer
        Integer j = a;// autoboxing, now compiler will write Integer.valueOf(a)
                        // internally

        System.out.println(a + &quot; &quot; + i + &quot; &quot; + j);
    &#125;
&#125;
Java
</code></pre>
<p>输出结果 - </p>
<pre><code class="java">20 20 20
Java
</code></pre>
<p><strong>包装类示例：包装类型到原始类型</strong></p>
<pre><code class="java">public class WrapperExample2 &#123;
    public static void main(String args[]) &#123;
        // Converting Integer to int
        Integer a = new Integer(3);
        int i = a.intValue();// converting Integer to int
        int j = a;// unboxing, now compiler will write a.intValue() internally

        System.out.println(a + &quot; &quot; + i + &quot; &quot; + j);
    &#125;
&#125;
Java
</code></pre>
<p>输出结果 - </p>
<pre><code class="java">3 3 3
</code></pre>
<h1 id="Java按值调用和引用调用"><a href="#Java按值调用和引用调用" class="headerlink" title="Java按值调用和引用调用"></a>Java按值调用和引用调用</h1><p>在java中只有通过值调用，而不是通过引用调用。 如果要调用一个传递值的方法，则称为按值调用。 在被调用方法中完成的更改，在调用方法的外部不受影响。</p>
<p><strong>在java中通过值调用的示例</strong></p>
<p>在值调用的情况下，原始值不改变。 看看下面一个简单的例子：</p>
<pre><code class="java">class Operation &#123;
    int data = 50;

    void change(int data) &#123;
        data = data + 100;// changes will be in the local variable only
    &#125;

    public static void main(String args[]) &#123;
        Operation op = new Operation();

        System.out.println(&quot;before change &quot; + op.data);
        op.change(500);
        System.out.println(&quot;after change &quot; + op.data);

    &#125;
&#125;
Java
</code></pre>
<p>在执行上面示例代码后，得到以下结果 -</p>
<pre><code class="shell">before change 50
after change 50
Shell
</code></pre>
<p><strong>在java中通过值调用的另一个示例</strong></p>
<p>在通过引用调用的情况下，如果在被调用的方法中做出的改变，则会改变原始值。 如果通过对象代替任何原始值，原始值将被改变。 在这个例子中，我们将对象作为值传递。 我们来看看下面的一个简单例子：</p>
<pre><code class="java">class Operation2 &#123;
    int data = 50;

    void change(Operation2 op) &#123;
        op.data = op.data + 100;// changes will be in the instance variable
    &#125;

    public static void main(String args[]) &#123;
        Operation2 op = new Operation2();

        System.out.println(&quot;before change &quot; + op.data);
        op.change(op);// passing object
        System.out.println(&quot;after change &quot; + op.data);

    &#125;
&#125;
Java
</code></pre>
<p>在执行上面示例代码后，得到以下结果 -</p>
<pre><code class="shell">before change 50
after change 150
</code></pre>
<h1 id="Java-strictfp关键字"><a href="#Java-strictfp关键字" class="headerlink" title="Java strictfp关键字"></a>Java strictfp关键字</h1><p>Java <code>strictfp</code>关键字确保您将在每个平台上获得相同的结果，如果在浮点变量中执行操作。 不同平台的精度可能不同，这就是为什么java编程语言提供了<code>strictfp</code>关键字，它用于在每个平台上获得相同的结果。 所以，现在我们就可以更好的控制浮点数据类型运算了。</p>
<p><strong>strictfp关键字的全法代码</strong></p>
<p><code>strictfp</code>关键字可以应用于方法，类和接口。</p>
<pre><code class="java">strictfp class A&#123;&#125;//strictfp applied on class  

strictfp interface M&#123;&#125;//strictfp applied on interface  

class B&#123;  
    strictfp void m()&#123;&#125;//strictfp applied on method  
&#125;
Java
</code></pre>
<p><strong>strictfp关键字的非法代码</strong></p>
<p><code>strictfp</code>关键字不能应用于抽象方法，变量或构造函数。</p>
<pre><code class="java">class B&#123;  
    strictfp abstract void m();//Illegal combination of modifiers  
&#125;  

class B1&#123;  
    strictfp int data=10;//modifier strictfp not allowed here  
&#125;  

class B2&#123;  
    strictfp B()&#123;&#125;//modifier strictfp not allowed here  
&#125;
</code></pre>
<h1 id="Java命令行参数"><a href="#Java命令行参数" class="headerlink" title="Java命令行参数"></a>Java命令行参数</h1><p>java命令行参数是一个参数，即在运行java程序时传递的参数。从控制台传递的参数可以在java程序中接收，并且可以用作输入。</p>
<p>因此，它提供了一种方便的方法来检查不同值的程序的行为。 可以从命令提示符传递<code>N(1,2,3等)</code>个参数。</p>
<p><strong>java中的命令行参数的简单示例</strong></p>
<p>在这个例子中，只接收一个参数并打印它。 要运行此Java程序，必须从命令提示符传递至少一个参数。</p>
<pre><code class="java">class CommandLineExample &#123;
    public static void main(String args[]) &#123;
        System.out.println(&quot;Your first argument is: &quot; + args[0]);
    &#125;
&#125;
Java
</code></pre>
<p><strong>编译命令：</strong>  <code>javac CommandLineExample.java</code><br><strong>执行命令：</strong> <code>java CommandLineExample sonoo</code></p>
<p>执行以上命令，输出以下结果 - </p>
<pre><code class="java">Your first argument is: sonoo
Java
</code></pre>
<p><strong>打印命令行参数所有值的示例</strong></p>
<p>在这个例子中，打印命令行传递的所有参数。 为此，这里使用<code>for</code>循环遍历了数组。</p>
<pre><code class="java">class A &#123;
    public static void main(String args[]) &#123;

        for (int i = 0; i &lt; args.length; i++)
            System.out.println(args[i]);

    &#125;
&#125;
Java
</code></pre>
<p><strong>编译命令：</strong>  <code>javac A.java</code><br><strong>执行命令：</strong> <code>java A sonoo jaiswal 1 3 abc</code></p>
<p>执行以上命令，输出以下结果 - </p>
<pre><code class="java">sonoo
jaiswal
1
3
abc
</code></pre>
<p>对象和类之间的区别</p>
<p>对象和类之间有很多区别。 下面给出了对象和类之间的差异(区别)列表：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>对象</th>
<th>类</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>对象是类的一个实例。</td>
<td>类是创建对象的蓝图或模板。</td>
</tr>
<tr>
<td>2</td>
<td>对象是真实世界的实体，如笔，笔记本电脑，手机，床，键盘，鼠标，椅子等。</td>
<td>类是一组类似的对象。</td>
</tr>
<tr>
<td>3</td>
<td>对象是一个物理实体。</td>
<td>类是一个逻辑实体。</td>
</tr>
<tr>
<td>4</td>
<td>对象主要通过<code>new</code>关键字创建，例如：<code>Student s1=new Student();</code></td>
<td>类使用<code>class</code>关键字，如：<code>class Student &#123;&#125;</code></td>
</tr>
<tr>
<td>5</td>
<td>对象根据需要可创建多次。</td>
<td>类只声明一次。</td>
</tr>
<tr>
<td>6</td>
<td>对象在创建时分配内存。</td>
<td>类在创建时不需要分配内存。</td>
</tr>
<tr>
<td>7</td>
<td>有很多方法在java中创建对象，如<code>new</code>关键字，<code>newInstance()</code>方法，<code>clone()</code>方法，工厂方法和反序列化。</td>
<td>在java中只有一种方法：使用<code>class</code>关键字来定义类。</td>
</tr>
</tbody></table>
<h1 id="Java决策制定"><a href="#Java决策制定" class="headerlink" title="Java决策制定"></a>Java决策制定</h1><p>决策制定具有一个或多个由程序评估或测试的条件，在条件确定为真时要执行的一个或多个语句；以及可选地，如果条件为假时则执行其他语句。</p>
<p>以下是大多数编程语言中常见决策结构的一般形式 - </p>
<p><img src="https://www.yiibai.com/uploads/article/2019/03/12/101536_54369.jpg" alt="Java决策制定"></p>
<p>Java编程语言提供以下类型的决策制定语句。 可通过单击以下链接来了解和学习。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>语句</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/if_statement_in_java.html">if语句</a></td>
<td><code>if</code>语句由布尔表达式后跟一个或多个语句组成。</td>
</tr>
<tr>
<td>2</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/if_else_statement_in_java.html">if…else语句</a></td>
<td><code>if</code>语句后面可以跟一个可选的<code>else</code>语句，<code>else</code>语句在布尔表达式为<code>false</code>时执行。</td>
</tr>
<tr>
<td>3</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/nested_if_statements_in_java.html">嵌套if语句</a></td>
<td>可以在一个<code>if</code>或<code>else if</code>语句中使用另一个<code>if</code>或<code>else if</code>语句。</td>
</tr>
<tr>
<td>4</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/switch_statement_in_java.html">switch语句</a></td>
<td><code>switch</code>语句允许测试变量与值列表的相等性。</td>
</tr>
</tbody></table>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="? : 运算符"></a>? : 运算符</h2><p>在前面的内容中覆盖了<code>?;</code>条件运算符，可以使用<code>if...else</code>语句来替代<code>?;</code>条件运算符。 它具有以下一般形式 - </p>
<pre><code class="java">Exp1 ? Exp2 : Exp3;
Java
</code></pre>
<p><code>Exp1</code>，<code>Exp2</code>和<code>Exp3</code>是表达式。 注意冒号(<code>:</code>)的放置和使用。要确定整个表达式的值，首先计算<code>Exp1</code>。</p>
<ul>
<li>如果<code>Exp1</code>的值为<code>true</code>，则<code>Exp2</code>的值将成为整个表达式的值。</li>
<li>如果<code>Exp1</code>的值为<code>false</code>，则计算<code>Exp3</code>的值将成为整个表达式的值。</li>
</ul>
<p><strong>示例代码</strong></p>
<pre><code class="java">public class ConditionalOperator &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        int a = 5;
        int b = 20;
        int c = 0;

        c = a &gt; b ? a - b : b - a;

        System.out.println(&quot;C的值是：&quot; + c);
    &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">C的值是：15
</code></pre>
<h1 id="Java-Number类"><a href="#Java-Number类" class="headerlink" title="Java Number类"></a>Java Number类</h1><p>通常，当要在Java编程中使用数字时，可以使用原始数据类型，如：<code>byte</code>，<code>int</code>，<code>long</code>，<code>double</code>等。</p>
<p><strong>示例</strong></p>
<pre><code class="java">int i = 5000;
float gpa = 13.65;
double mask = 0xaf;
Java
</code></pre>
<p>但是，在开发过程中，我们遇到的是需要使用对象而不是原始数据类型的情况。要实现这一点，可使用Java提供的包装类。</p>
<p>所有包装类(如：<code>Integer</code>，<code>Long</code>，<code>Byte</code>，<code>Double</code>，<code>Float</code>，<code>Short</code>)都是抽象类<code>Number</code>的子类。</p>
<p><img src="https://www.yiibai.com/uploads/article/2019/03/12/141530_85700.jpg" alt="Number类"></p>
<p>包装类的对象包含或包装其各自的基本数据类型。将原始数据类型转换为对象称为<strong>装箱</strong>，编译器会对此进行处理。 因此，在使用包装器类时，只需将原始数据类型的值传递给包装类的构造函数就可以对它进行对应的操作。</p>
<p>并且包装对象将转换回原始数据类型，并且此过程称为<strong>拆箱</strong>。 <code>Number</code>类是<code>java.lang</code>包的一部分。</p>
<p>以下是装箱和拆箱的示例 - </p>
<pre><code class="java">public class Test &#123;

   public static void main(String args[]) &#123;
      Integer x = 5; // 装箱：将 int 添加到 Integer 对象
      x =  x + 1000;   // 拆箱：将Integer 对象转为 int 
      System.out.println(x); 
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">1005
Shell
</code></pre>
<p>当<code>x</code>赋予整数值时，编译器将整数装箱，因为<code>x</code>是整数对象。 之后，<code>x</code>又被拆箱，以便它们可以作为整数执行加法运算。</p>
<h2 id="Number类的方法"><a href="#Number类的方法" class="headerlink" title="Number类的方法"></a>Number类的方法</h2><p>以下是<code>Number</code>类的所有子类实现方法的列表 - </p>
<table>
<thead>
<tr>
<th>编号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_xxxvalue.html">xxxValue()方法</a></td>
<td>将此<code>Number</code>对象的值转换为<code>xxx</code>数据类型并返回它。</td>
</tr>
<tr>
<td>2</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_compareto.html">compareTo()方法</a></td>
<td>将此<code>Number</code>对象与参数进行比较。</td>
</tr>
<tr>
<td>3</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_equals.html">equals()方法</a></td>
<td>确定此<code>Number</code>对象是否等于参数。</td>
</tr>
<tr>
<td>4</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_valueof.html">valueOf()方法</a></td>
<td>返回包含指定原始值的<code>Integer</code>对象。</td>
</tr>
<tr>
<td>5</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_tostring.html">toString()方法</a></td>
<td>返回表示指定<code>int</code>或<code>Integer</code>值的<code>String</code>对象。</td>
</tr>
<tr>
<td>6</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_parseint.html">parseInt()方法</a></td>
<td>返回某个<code>String</code>的原始数据类型值。</td>
</tr>
<tr>
<td>7</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_abs.html">abs()方法</a></td>
<td>返回参数的绝对值。</td>
</tr>
<tr>
<td>8</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_ceil.html">ceil()方法</a></td>
<td>返回大于或等于参数的最小整数，结果整数为<code>double</code>类型。</td>
</tr>
<tr>
<td>9</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_floor.html">floor()方法</a></td>
<td>返回小于或等于参数的最大整数，结果整数为<code>double</code>类型。</td>
</tr>
<tr>
<td>10</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_rint.html">rint()方法</a></td>
<td>返回与参数值最接近的整数，结果整数为<code>double</code>类型。</td>
</tr>
<tr>
<td>11</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_round.html">round()方法</a></td>
<td>返回最接近<code>long</code>或<code>int</code>值，由方法返回类型指示参数的返回类型。</td>
</tr>
<tr>
<td>12</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_min.html">min()方法</a></td>
<td>返回两个参数中最小的那一个。</td>
</tr>
<tr>
<td>13</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_max.html">max()方法</a></td>
<td>返回两个参数中最大的那一个。</td>
</tr>
<tr>
<td>14</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_exp.html">exp()方法</a></td>
<td>返回 e 的 x 次幂。e 代表自然对数的底数，其值近似为 <code>2.71828</code>。</td>
</tr>
<tr>
<td>15</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_log.html">log()方法</a></td>
<td>返回参数的自然对数。</td>
</tr>
<tr>
<td>16</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_pow.html">pow()方法</a></td>
<td>返回第一个参数的第二个参数的指数幂(乘方)值。</td>
</tr>
<tr>
<td>17</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_sqrt.html">sqrt()方法</a></td>
<td>返回参数的平方根。</td>
</tr>
<tr>
<td>18</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_sin.html">sin()方法</a></td>
<td>返回指定<code>double</code>值的正弦值。</td>
</tr>
<tr>
<td>19</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_cos.html">cos()方法</a></td>
<td>返回指定<code>double</code>值的余弦值。</td>
</tr>
<tr>
<td>20</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_tan.html">tan()方法</a></td>
<td>返回指定<code>double</code>值的正切值。</td>
</tr>
<tr>
<td>21</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_asin.html">asin()方法</a></td>
<td>返回指定<code>double</code>值的反正弦值。</td>
</tr>
<tr>
<td>22</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_acos.html">acos()方法</a></td>
<td>返回指定<code>double</code>值的反余弦值。</td>
</tr>
<tr>
<td>23</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_atan.html">atan()方法</a></td>
<td>返回指定<code>double</code>值的反正切值。</td>
</tr>
<tr>
<td>24</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_atan2.html">atan2()方法</a></td>
<td>将直角坐标(x，y)转换为极坐标(r，theta)并返回theta。</td>
</tr>
<tr>
<td>25</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_todegrees.html">toDegrees()方法</a></td>
<td>将参数转换为度数。</td>
</tr>
<tr>
<td>26</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_toradians.html">toRadians()方法</a></td>
<td>将参数转换为弧度。</td>
</tr>
<tr>
<td>27</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/number_random.html">random()方法</a></td>
<td>返回一个随机数。</td>
</tr>
</tbody></table>
<h1 id="Java-Character类"><a href="#Java-Character类" class="headerlink" title="Java Character类"></a>Java Character类</h1><p>通常，当处理字符时，使用原始数据类型<code>char</code>。</p>
<p><strong>示例</strong></p>
<pre><code class="java">char ch = &#39;a&#39;;

// Unicode的大写字符
char uniChar = &#39;\u039A&#39;; 

// 字符数组
char[] charArray =&#123; &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; &#125;;
Java
</code></pre>
<p>但是在开发过程中，经常遇到的是需要使用对象而不是原始数据类型的情况。 为了实现这一点，Java为原始数据类型<code>char</code>提供了包装类<code>Character</code>。</p>
<p><code>Character</code>类提供了许多用于操作字符的有用类(即静态)方法。 可以使用<code>Character</code>构造函数创建<code>Character</code>对象，例如 - </p>
<pre><code class="java">Character ch = new Character(&#39;a&#39;);
Java
</code></pre>
<p>在某些情况下，Java编译器还会创建一个<code>Character</code>对象。 例如，如果将原始字符传递给需要对象的方法，则编译器会自动将<code>char</code>转换为<code>Character</code>。此功能称为自动装箱或拆箱。</p>
<p><strong>示例</strong></p>
<pre><code class="java">// 这里是原始的char类型值：&#39;a&#39;
// 它被装入`Character`对象ch
Character ch = &#39;a&#39;;

// 这里原始char值&#39;x&#39;，装箱用于方法test，
// 拆箱到char类型值：&#39;c&#39;
char c = test(&#39;x&#39;);
Java
</code></pre>
<h2 id="1-转义序列"><a href="#1-转义序列" class="headerlink" title="1. 转义序列"></a>1. 转义序列</h2><p>以反斜杠(<code>\</code>)开头的字符是转义序列，对编译器具有特殊含义。</p>
<p>在本教程中<code>System.out.println()</code>语句中经常使用换行符(<code>\n</code>)，以便在打印字符串后前进到下一行。</p>
<p>下表中列出了Java转义序列 - </p>
<table>
<thead>
<tr>
<th>编号</th>
<th>转义序列</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>\t</code></td>
<td>表示在文本中插入一个制表符。</td>
</tr>
<tr>
<td>2</td>
<td><code>\b</code></td>
<td>表示在文本中插入退格符。</td>
</tr>
<tr>
<td>3</td>
<td><code>\n</code></td>
<td>表示在文本中插入换行符。</td>
</tr>
<tr>
<td>4</td>
<td><code>\r</code></td>
<td>表示在文本中插入回车符。</td>
</tr>
<tr>
<td>5</td>
<td><code>\f</code></td>
<td>表示在文本中插入换页符。</td>
</tr>
<tr>
<td>6</td>
<td><code>\ &#39;</code></td>
<td>表示在文本中插入单引号字符。</td>
</tr>
<tr>
<td>7</td>
<td><code>\&quot;</code></td>
<td>表示在文本中插入双引号字符。</td>
</tr>
<tr>
<td>8</td>
<td><code>\\</code></td>
<td>表示在文本中插入反斜杠字符。</td>
</tr>
</tbody></table>
<p>当在<code>print</code>语句中遇到转义序列时，编译器会相应地解释它。</p>
<p><strong>示例</strong></p>
<p>如果要在引号内加引号，则必须在内部引号上使用转义序列<code>\&quot;</code> - </p>
<pre><code class="java">public class Test &#123;

   public static void main(String args[]) &#123;
      System.out.println(&quot;She said \&quot;Hello!\&quot; to me.&quot;);
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">She said &quot;Hello!&quot; to me.
Shell
</code></pre>
<h2 id="Character方法"><a href="#Character方法" class="headerlink" title="Character方法"></a>Character方法</h2><p>以下是<code>Character</code>类的所有子类实现的方法列表 - </p>
<table>
<thead>
<tr>
<th>编号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/character_isletter.html">isLetter()方法</a></td>
<td>确定指定的<code>char</code>值是否为字母。</td>
</tr>
<tr>
<td>2</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/character_isdigit.html">isDigit()方法</a></td>
<td>确定指定的<code>char</code>值是否为数字。</td>
</tr>
<tr>
<td>3</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/character_iswhitespace.html">isWhitespace()方法</a></td>
<td>确定指定的<code>char</code>值是否为空格。</td>
</tr>
<tr>
<td>4</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/character_isuppercase.html">isUpperCase()方法</a></td>
<td>确定指定的<code>char</code>值是否为大写字母。</td>
</tr>
<tr>
<td>5</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/character_islowercase.html">isLowerCase()方法</a></td>
<td>确定指定的<code>char</code>值是否为小写字母。</td>
</tr>
<tr>
<td>6</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/character_touppercase.html">toUpperCase()方法</a></td>
<td>返回指定<code>char</code>值的大写形式。</td>
</tr>
<tr>
<td>7</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/character_tolowercase.html">toLowerCase()方法</a></td>
<td>返回指定<code>char</code>值的小写形式。</td>
</tr>
<tr>
<td>8</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/character_tostring.html">toString()方法</a></td>
<td>返回表示指定字符值的<code>String</code>对象，即一个字符的字符串。</td>
</tr>
</tbody></table>
<p>有关方法的完整列表，请参阅<code>java.lang.Character</code> API规范。</p>
<h1 id="Java-String类"><a href="#Java-String类" class="headerlink" title="Java String类"></a>Java String类</h1><p>字符串在Java编程中广泛使用，字符串就是一系列字符(由一个个的字符组成)。 在Java编程语言中，字符串被视为对象。</p>
<p>Java平台提供<code>String</code>类来创建和操作字符串。</p>
<h2 id="1-创建字符串"><a href="#1-创建字符串" class="headerlink" title="1. 创建字符串"></a>1. 创建字符串</h2><p>创建字符串的最直接方法是 - </p>
<pre><code class="java">String str = &quot;Hello world!&quot;;
Java
</code></pre>
<p>每当它在代码中遇到字符串文字时，编译器就会创建一个<code>String</code>对象，在本例中<code>str</code>对象的值为<code>Hello world!</code>。</p>
<p>与其他对象一样，可以使用<code>new</code>关键字和构造函数来创建<code>String</code>对象。<code>String</code>类有<code>11</code>个构造函数，方便使用不同的源(例如：字符数组)提供字符串的初始值。</p>
<p><strong>示例</strong></p>
<pre><code class="java">public class StringDemo &#123;

   public static void main(String args[]) &#123;
      char[] helloArray = &#123; &#39;Y&#39;, &#39;i&#39;, &#39;i&#39;, &#39;b&#39;, &#39;a&#39;, &#39;i&#39; &#125;;
      String helloString = new String(helloArray);  
      System.out.println( helloString );
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到下结果：</p>
<pre><code class="shell">Yiibai
Shell
</code></pre>
<blockquote>
<p>注 -  <code>String</code>类是不可变的，因此一旦创建，就无法更改<code>String</code>对象。 如果想要对字符串进行大量修改，则应使用<a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_buffer.html">StringBuffer和StringBuilder</a>。</p>
</blockquote>
<h2 id="2-字符串长度"><a href="#2-字符串长度" class="headerlink" title="2. 字符串长度"></a>2. 字符串长度</h2><p>用于获取对象信息的方法称为访问器方法。 可以与字符串一起使用来获取字符串长度的一个访问器方法是<code>length()</code>方法，它返回字符串对象中包含的字符数。</p>
<p>以下程序是<code>String</code>类的<code>length()</code>方法的示例。</p>
<pre><code class="java">public class StringDemo &#123;

   public static void main(String args[]) &#123;
      String greeting = &quot;Hi,Welcome to Yiibai.com&quot;;
      int len = greeting.length();
      System.out.println( greeting+&quot; 字符串的长度是: &quot; + len );
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到下结果：</p>
<pre><code class="shell">Hi,Welcome to Yiibai.com 字符串的长度是: 24
Shell
</code></pre>
<h2 id="3-连接字符串"><a href="#3-连接字符串" class="headerlink" title="3. 连接字符串"></a>3. 连接字符串</h2><p><code>String</code>类包含一个用于连接两个字符串的方法 - </p>
<pre><code class="java">string1.concat(string2);
Java
</code></pre>
<p>这将返回一个新字符串：<code>string1</code>，并且<code>string1</code>在结尾处添加了<code>string2</code>。 还可以将<code>concat()</code>方法与字符串文字一起使用，例如 - </p>
<pre><code class="java">&quot;My name is &quot;.concat(&quot;Maxsu&quot;);
Java
</code></pre>
<p>字符串通常使用<code>+</code>运算符连接，如 - </p>
<pre><code class="java">&quot;Hello,&quot; + &quot; world&quot; + &quot;!&quot;
Java
</code></pre>
<p>上面代码执行后得到的结果是：</p>
<pre><code class="shell">&quot;Hello, world!&quot;
Shell
</code></pre>
<p>下面再来看另一个例子 - </p>
<pre><code class="java">public class StringDemo &#123;

   public static void main(String args[]) &#123;
      String string1 = &quot;Bai&quot;;
      System.out.println(&quot;Yii&quot; + string1 + &quot;.com&quot;);
   &#125;
&#125;
Java
</code></pre>
<p>上面代码执行后得到的结果是：</p>
<pre><code class="shell">YiiBai.com
Shell
</code></pre>
<h2 id="3-创建格式化字符串"><a href="#3-创建格式化字符串" class="headerlink" title="3. 创建格式化字符串"></a>3. 创建格式化字符串</h2><p>Java中使用<code>printf()</code>和<code>format()</code>方法来打印带有格式化数字的输出。 <code>String</code>类有一个等效的类方法<code>format()</code>，它返回一个<code>String</code>对象而不是一个<code>PrintStream</code>对象。</p>
<p>使用<code>String</code>的<code>static format()</code>方法可以创建重用的格式化字符串，而不是一次性打印语句。 例如 - </p>
<pre><code class="java">System.out.printf(&quot;The value of the float variable is &quot; +
                  &quot;%f, while the value of the integer &quot; +
                  &quot;variable is %d, and the string &quot; +
                  &quot;is %s&quot;, floatVar, intVar, stringVar);
Java
</code></pre>
<p>上面打印语句可使用格式化写为：</p>
<pre><code class="java">String fs;
fs = String.format(&quot;The value of the float variable is &quot; +
                   &quot;%f, while the value of the integer &quot; +
                   &quot;variable is %d, and the string &quot; +
                   &quot;is %s&quot;, floatVar, intVar, stringVar);
System.out.println(fs);
Java
</code></pre>
<h2 id="4-String类方法"><a href="#4-String类方法" class="headerlink" title="4. String类方法"></a>4. String类方法</h2><p>以下是<code>String</code>类定义的方法列表 - </p>
<table>
<thead>
<tr>
<th>编号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_charat.html">char charAt(int index)</a></td>
<td>返回指定索引处的字符。</td>
</tr>
<tr>
<td>2</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_compareto.html">int compareTo(Object o)</a></td>
<td>将此<code>String</code>对象与另一个对象进行比较。</td>
</tr>
<tr>
<td>3</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_compareto_anotherstring.html">int compareTo(String anotherString)</a></td>
<td>按字典顺序比较两个字符串。</td>
</tr>
<tr>
<td>4</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_comparetoignorecase.html">int compareToIgnoreCase(String str)</a></td>
<td>按字典顺序比较两个字符串，但不区分大小写。</td>
</tr>
<tr>
<td>5</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_concat.html">String concat(String str)</a></td>
<td>将指定的字符串连接到此字符串的末尾。</td>
</tr>
<tr>
<td>6</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_contentequals.html">boolean contentEquals(StringBuffer sb)</a></td>
<td>当且仅当此<code>String</code>表示的字符串与指定的<code>StringBuffer</code>相同的字符序列时，才返回<code>true</code>。</td>
</tr>
<tr>
<td>7</td>
<td>[static String copyValueOf(char<a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_copyvalueof.html">] data)</a></td>
<td>返回表示指定数组中字符序列的<code>String</code>对象形式。</td>
</tr>
<tr>
<td>8</td>
<td>[static String copyValueOf(char<a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_copyvalueof_dataoffsetcount.html">] data, int offset, int count)</a></td>
<td>返回表示指定数组中字符序列的<code>String</code>对象形式。</td>
</tr>
<tr>
<td>9</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_endswith.html">boolean endsWith(String suffix)</a></td>
<td>判断此字符串是否以指定的字符作为后缀结尾。</td>
</tr>
<tr>
<td>10</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_equals.html">boolean equals(Object anObject)</a></td>
<td>将此字符串与指定的对象进行比较。</td>
</tr>
<tr>
<td>11</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_equalsignorecase.html">boolean equalsIgnoreCase(String anotherString)</a></td>
<td>将此<code>String</code>与另一个<code>String</code>进行比较，忽略大小写。</td>
</tr>
<tr>
<td>12</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_getbytes.html">byte getBytes()</a></td>
<td>使用平台的默认字符集将此<code>String</code>编码为字节序列，将结果存储到新的字节数组中。</td>
</tr>
<tr>
<td>13</td>
<td>[byte<a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_getbytes_charsetname.html">] getBytes(String charsetName)</a></td>
<td>使用指定的字符集将此String编码为字节序列，将结果存储到新的字节数组中。</td>
</tr>
<tr>
<td>14</td>
<td>[void getChars(int srcBegin, int srcEnd, char<a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_getchars.html">] dst, int dstBegin)</a></td>
<td>将此字符串中的字符复制到目标字符数组中。</td>
</tr>
<tr>
<td>15</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_hashcode.html">int hashCode()</a></td>
<td>返回此字符串的哈希码。</td>
</tr>
<tr>
<td>16</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_indexof.html">int indexOf(int ch)</a></td>
<td>返回指定字符在此字符串中第一次出现的索引。</td>
</tr>
<tr>
<td>17</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_indexof_fromindex.html">int indexOf(int ch, int fromIndex)</a></td>
<td>返回指定字符在此字符串中第一次出现的索引，它从指定索引处开始搜索。</td>
</tr>
<tr>
<td>18</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_indexof_str.html">int indexOf(String str)</a></td>
<td>返回指定子字符串在此字符串中第一次出现的索引。</td>
</tr>
<tr>
<td>19</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_indexof_strfromindex.html">int indexOf(String str, int fromIndex)</a></td>
<td>从指定的索引处开始，返回指定子字符串在此字符串中第一次出现的索引。</td>
</tr>
<tr>
<td>20</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_intern.html">String intern()</a></td>
<td>返回字符串对象的规范表示。</td>
</tr>
<tr>
<td>21</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_lastindexof.html">int lastIndexOf(int ch)</a></td>
<td>返回指定字符在此字符串中最后一次出现的索引。</td>
</tr>
<tr>
<td>22</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_lastindexof_chfromindex.html">int lastIndexOf(int ch, int fromIndex)</a></td>
<td>返回指定字符在此字符串中最后一次出现的索引，它从指定的索引开始向后搜索。</td>
</tr>
<tr>
<td>23</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_lastindexof_str.html">int lastIndexOf(String str)</a></td>
<td>返回指定子字符串在些字符串中最后出现的索引。</td>
</tr>
<tr>
<td>24</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_lastindexof_fromindex.html">int lastIndexOf(String str, int fromIndex)</a></td>
<td>返回指定子字符串在此字符串中最后一次出现的索引，它从指定索引开始向后搜索。</td>
</tr>
<tr>
<td>25</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_length.html">int length()</a></td>
<td>返回此字符串的长度。</td>
</tr>
<tr>
<td>26</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_matches.html">boolean matches(String regex)</a></td>
<td>判断此字符串是否与给定的正则表达式匹配。</td>
</tr>
<tr>
<td>27</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_regionmatches_ignorecase.html">boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)</a></td>
<td>判断两个字符串区域是否相等。</td>
</tr>
<tr>
<td>28</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_regionmatches.html">boolean regionMatches(int toffset, String other, int ooffset, int len)</a></td>
<td>判断两个字符串区域是否相等。</td>
</tr>
<tr>
<td>29</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_replace.html">String replace(char oldChar, char newChar)</a></td>
<td>返回一个新字符串，该字符串是使用<code>newChar</code>替换此字符串中出现的所有<code>oldChar</code>后的字符串。</td>
</tr>
<tr>
<td>30</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_replaceall.html">String replaceAll(String regex, String replacement)</a></td>
<td>将替换此字符串中匹配给定正则表达式的每个子字符串。</td>
</tr>
<tr>
<td>31</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_replacefirst.html">String replaceFirst(String regex, String replacement)</a></td>
<td>将替换此字符串中第一个匹配给定正则表达式的子字符串。</td>
</tr>
<tr>
<td>32</td>
<td>[String<a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_split.html">] split(String regex)</a></td>
<td>将此字符串拆分为给定正则表达式的匹配项。</td>
</tr>
<tr>
<td>33</td>
<td>[String<a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_split_regexlimit.html">] split(String regex, int limit)</a></td>
<td>将此字符串拆分为给定正则表达式的匹配项。</td>
</tr>
<tr>
<td>34</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_startswith.html">boolean startsWith(String prefix)</a></td>
<td>判断此字符串是否以指定的字符串前缀开头。</td>
</tr>
<tr>
<td>35</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_startswith_prefixtoffset.html">boolean startsWith(String prefix, int toffset)</a></td>
<td>判断此字符串在指定的索引是否以指定的前缀开始。</td>
</tr>
<tr>
<td>36</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_subsequence.html">CharSequence subSequence(int beginIndex, int endIndex)</a></td>
<td>返回一个新的字符序列，它是该序列的子序列。</td>
</tr>
<tr>
<td>37</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_substring.html">String substring(int beginIndex)</a></td>
<td>返回一个新字符串，该字符串是此字符串的子字符串。</td>
</tr>
<tr>
<td>38</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_substring_beginendindex.html">String substring(int beginIndex, int endIndex)</a></td>
<td>返回一个新字符串，该字符串是此字符串的子字符串。</td>
</tr>
<tr>
<td>39</td>
<td>[char<a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_tochararray.html">] toCharArray()</a></td>
<td>将此字符串转换为新的字符数组。</td>
</tr>
<tr>
<td>40</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_tolowercase.html">String toLowerCase()</a></td>
<td>使用默认语言环境的规则将此<code>String</code>中的所有字符转换为小写。</td>
</tr>
<tr>
<td>41</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_tolowercase_locale.html">String toLowerCase(Locale locale)</a></td>
<td>使用给定<code>Locale</code>的规则将此<code>String</code>中的所有字符转换为小写。</td>
</tr>
<tr>
<td>42</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_tostring.html">String toString()</a></td>
<td>将这个对象(已经是一个字符串)本身返回。</td>
</tr>
<tr>
<td>43</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_touppercase.html">String toUpperCase()</a></td>
<td>使用默认语言环境的规则将此<code>String</code>中的所有字符转换为大写。</td>
</tr>
<tr>
<td>44</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_touppercase_locale.html">String toUpperCase(Locale locale)</a></td>
<td>使用给定<code>Locale</code>的规则将此<code>String</code>中的所有字符转换为大写。</td>
</tr>
<tr>
<td>45</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_trim.html">String trim()</a></td>
<td>返回字符串的副本，移除前导和尾随空格。</td>
</tr>
<tr>
<td>46</td>
<td><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_string_valueof.html">static String valueOf(primitive data type x)</a></td>
<td>返回传递的数据类型参数的字符串表示形式。</td>
</tr>
</tbody></table>
<h1 id="Java数组-1"><a href="#Java数组-1" class="headerlink" title="Java数组"></a>Java数组</h1><p>java提供了一种叫作数组的数据结构，它是一种用来存储相同类型元素的固定大小顺序集合。 数组用于存储数据集合，但也可以将数组视为相同类型的变量集合。</p>
<p>声明一个数组变量(如：<code>numbers</code>)并使用<code>numbers[0]</code>，<code>numbers[1]</code>和<code>...</code>，<code>numbers[99]</code>来表示单个变量，例如<code>number0</code>，<code>number1</code>，<code>...</code>和<code>number99</code>，而不是单独地声明各个变量。</p>
<p>本教程介绍如何声明数组变量，创建数组和索引访问数组。</p>
<h2 id="1-声明数组变量"><a href="#1-声明数组变量" class="headerlink" title="1. 声明数组变量"></a>1. 声明数组变量</h2><p>要在程序中使用数组，需要先声明一个变量以引用该数组，并且要指定该变量的数组类型。 以下是声明数组变量的语法 - </p>
<p><strong>语法</strong></p>
<pre><code class="java">dataType[] arrayRefVar;   // 推荐方式。
// 或者
dataType arrayRefVar[];  // 有效，但不是推荐方式。
Java
</code></pre>
<blockquote>
<p>注 - 格式：<code>dataType [] arrayRefVar</code>是推荐方式。 格式：<code>dataType arrayRefVar []</code>来自C/C++语言，可在Java中采用以适应C/C++程序员。</p>
</blockquote>
<p><strong>示例</strong></p>
<p>以下代码片段是此语法的示例 - </p>
<pre><code class="java">double[] myList;   // 推荐方式。
// 或者
double myList[];   // 有效，但不是推荐方式。
Java
</code></pre>
<h2 id="2-创建数组"><a href="#2-创建数组" class="headerlink" title="2. 创建数组"></a>2. 创建数组</h2><p>可以使用<code>new</code>运算符来创建数组，如以下语法 - </p>
<pre><code class="java">// 声明
dataType[] arrayRefVar;   // 推荐方式。
// 创建
arrayRefVar = new dataType[arraySize];
Java
</code></pre>
<p>上面语句做了两件事 - </p>
<ul>
<li>它使用<code>new dataType[arraySize]</code>来创建了一个数组。</li>
<li>它将新创建的数组的引用分配给变量<code>arrayRefVar</code>。</li>
</ul>
<p>声明一个数组变量，创建一个数组，并将该数组的引用分配给变量，可以在一个语句中完成，如下所示 - </p>
<pre><code class="java">dataType[] arrayRefVar = new dataType[arraySize];
Java
</code></pre>
<p>或者，可以按如下方式创建数组 - </p>
<pre><code class="java">dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;;
Java
</code></pre>
<p>通过索引访问数组元素。 数组索引值从<code>0</code>开始; 也就是说，它们从<code>0</code>开始到<code>arrayRefVar.length - 1</code>。</p>
<p><strong>示例</strong></p>
<p>下面语句中声明了一个数组变量<code>myList</code>，它创建了一个包含<code>10</code>个<code>double</code>类型元素的数组，并将数组变量的引用分配给<code>myList</code>  - </p>
<pre><code class="java">double[] myList = new double[10];
Java
</code></pre>
<p>下图表示数组<code>myList</code>。 这里，<code>myList</code>数组中包含十个<code>double</code>值，索引从<code>0</code>到<code>9</code>。<br><img src="https://www.yiibai.com/uploads/article/2019/03/15/111459_59516.jpg" alt="数组存储结构示例"></p>
<h2 id="3-处理数组"><a href="#3-处理数组" class="headerlink" title="3. 处理数组"></a>3. 处理数组</h2><p>处理数组元素时，经常使用<code>for</code>循环或<code>foreach</code>循环，因为数组中的所有元素都是相同的类型，并且数组的大小是已知的。</p>
<p><strong>示例</strong><br>这是一个完整的示例，演示了如何创建，初始化和处理数组 - </p>
<pre><code class="java">import java.util.*;

public class Test &#123;

    public static void main(String[] args) &#123;
        double[] myList = &#123; 10.01, 12.19, 23.44, 43.95, 77.88, 65.00 &#125;;

        // 打印所有元素
        for (int i = 0; i &lt; myList.length; i++) &#123;
            System.out.print(myList[i] + &quot;, &quot;);
        &#125;
        System.out.println(&quot; &quot;);

        // 求和
        double total = 0;
        for (int i = 0; i &lt; myList.length; i++) &#123;
            total += myList[i];
        &#125;
        System.out.println(&quot;总和：&quot; + total);

        // 查找最大值
        double max = myList[0];
        for (int i = 1; i &lt; myList.length; i++) &#123;
            if (myList[i] &gt; max)
                max = myList[i];
        &#125;
        System.out.println(&quot;元素最大值：&quot; + max);
    &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">10.01, 12.19, 23.44, 43.95, 77.88, 65.0,  
总和：232.47
元素最大值：77.88
Shell
</code></pre>
<h4 id="3-1-foreach循环"><a href="#3-1-foreach循环" class="headerlink" title="3.1. foreach循环"></a>3.1. foreach循环</h4><p>JDK 1.5引入了<code>foreach</code>循环或增强<code>for</code>循环，它能够在不使用索引变量的情况下顺序遍历整个数组。</p>
<p><strong>示例</strong></p>
<p>以下代码演示如何遍历数组<code>myList</code>中的所有元素 - </p>
<pre><code class="java">import java.util.*;

public class Test &#123;

    public static void main(String[] args) &#123;
        double[] myList = &#123; 10.01, 12.19, 23.44, 43.95, 77.88, 65.00 &#125;;

        // Print all the array elements
        for (double element : myList) &#123;
            System.out.print(element+&quot;, &quot;);
        &#125;
    &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">10.01, 12.19, 23.44, 43.95, 77.88, 65.0,
Shell
</code></pre>
<h4 id="3-2-将数组传递给方法"><a href="#3-2-将数组传递给方法" class="headerlink" title="3.2. 将数组传递给方法"></a>3.2. 将数组传递给方法</h4><p>就像将原始类型值传递给方法一样，也可以将数组传递给方法。 例如，以下<code>printArray()</code>方法用来打印<code>int</code>数组中的元素 - </p>
<p><strong>示例</strong></p>
<pre><code class="java">import java.util.*;

public class Test &#123;

    public static void main(String[] args) &#123;
        double[] myList = &#123; 10.01, 12.19, 23.44, 43.95, 77.88, 65.00 &#125;;

        // Print all the array elements
        printArray(myList);
    &#125;

    public static void printArray(double[] array) &#123;
        for (int i = 0; i &lt; array.length; i++) &#123;
            System.out.print(array[i] + &quot; &quot;);
        &#125;
    &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">10.01 12.19 23.44 43.95 77.88 65.0
Shell
</code></pre>
<h4 id="3-3-从方法返回数组"><a href="#3-3-从方法返回数组" class="headerlink" title="3.3. 从方法返回数组"></a>3.3. 从方法返回数组</h4><p>方法可以返回数组。 例如，以下方法返回一个与给定参数数组相反的数组 - </p>
<pre><code class="java">import java.util.*;

public class Test &#123;

    public static void main(String[] args) &#123;
        double[] myList = &#123; 10.01, 12.19, 23.44, 43.95, 77.88, 65.00 &#125;;

        // Print all the array elements
        printArray(myList);
        printArray(reverse(myList));
    &#125;

    public static void printArray(double[] array) &#123;
        for (int i = 0; i &lt; array.length; i++) &#123;
            System.out.print(array[i] + &quot; &quot;);
        &#125;
        System.out.println(&quot; &quot;);
    &#125;

    public static double[] reverse(double[] list) &#123;
        double[] result = new double[list.length];

        for (int i = 0, j = result.length - 1; i &lt; list.length; i++, j--) &#123;
            result[j] = list[i];
        &#125;
        return result;
    &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">10.01 12.19 23.44 43.95 77.88 65.0  
65.0 77.88 43.95 23.44 12.19 10.01
Shell
</code></pre>
<h4 id="3-4-Arrays类"><a href="#3-4-Arrays类" class="headerlink" title="3.4. Arrays类"></a>3.4. Arrays类</h4><p><code>java.util.Arrays</code>类包含各种静态方法，用于排序和搜索数组，比较数组和填充数组元素。 对于所有基本类型，这些方法都会重载。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>public static int binarySearch(Object[] a, Object key)</code></td>
<td>使用二进制搜索算法搜索指定的Object(Byte，Int，double等)数组以获取指定值。 必须在进行此调用之前对数组进行排序。 如果搜索关键字包含在列表中，则返回搜索关键字的索引; 否则，它返回( -(插入点 + 1))。</td>
</tr>
<tr>
<td>2</td>
<td><code>public static boolean equals(long[] a, long[] a2)</code></td>
<td>如果两个指定的<code>long</code>数组相等，则返回<code>true</code>。 如果两个数组包含相同数量的元素，则两个数组被认为是相等的，并且两个数组中的所有相应元素对相等。如果两个数组相等，则返回<code>true</code>。 所有其他原始数据类型(Byte，Short，Int等)可以使用相同的方法。</td>
</tr>
<tr>
<td>3</td>
<td><code>public static void fill(int[] a, int val)</code></td>
<td>将指定的<code>int</code>值分配给指定的<code>int</code>数组的每个元素。所有其他原始数据类型(Byte，Short，Int等)可以使用相同的方法。</td>
</tr>
<tr>
<td>4</td>
<td><code>public static void sort(Object[] a)</code></td>
<td>根据元素的自然顺序，将指定的对象数组按升序排序。 所有其他原始数据类型(Byte，Short，Int等)可以使用相同的方法。</td>
</tr>
</tbody></table>
<h1 id="Java日期时间"><a href="#Java日期时间" class="headerlink" title="Java日期时间"></a>Java日期时间</h1><p>Java的<code>java.util</code>包提供了<code>Date</code>类，该类封装了当前的日期和时间。<code>Date</code>类支持两个构造函数，如下表所示。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>构造函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>Date()</code></td>
<td>此构造函数使用当前日期和时间来初始化对象。</td>
</tr>
<tr>
<td>2</td>
<td><code>Date(long millisec)</code></td>
<td>此构造函数接受一个参数，该参数等于自1970年1月1日午夜以来经过的毫秒数。</td>
</tr>
</tbody></table>
<p>以下是<code>Date</code>类的方法列表 - </p>
<table>
<thead>
<tr>
<th>编号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>boolean after(Date date)</code></td>
<td>如果调用<code>Date</code>对象包含的日期晚于<code>date</code>指定的日期，则返回<code>true</code>，否则返回<code>false</code>。</td>
</tr>
<tr>
<td>2</td>
<td><code>boolean before(Date date)</code></td>
<td>如果调用<code>Date</code>对象包含的日期早于<code>date</code>指定的日期，则返回<code>true</code>，否则返回<code>false</code>。</td>
</tr>
<tr>
<td>3</td>
<td><code>Object clone( )</code></td>
<td>复制调用的<code>Date</code>对象。</td>
</tr>
<tr>
<td>4</td>
<td><code>int compareTo(Date date)</code></td>
<td>将调用对象的值与<code>date</code>的值进行比较。 如果值相等则返回<code>0</code>。 如果调用对象早于<code>date</code>，则返回负值。 如果调用对象晚于<code>date</code>，则返回正值。</td>
</tr>
<tr>
<td>5</td>
<td><code>int compareTo(Object obj)</code></td>
<td>如果<code>obj</code>对象是<code>Date</code>类对象，则与<code>compareTo(Date)</code>操作相同。 否则，它会抛出<code>ClassCastException</code>。</td>
</tr>
<tr>
<td>6</td>
<td><code>boolean equals(Object date)</code></td>
<td>如果调用<code>Date</code>对象包含与<code>date</code>指定的时间和日期相同的时间和日期，则返回<code>true</code>，否则返回<code>false</code>。</td>
</tr>
<tr>
<td>7</td>
<td><code>long getTime()</code></td>
<td>返回自1970年1月1日以来经过的毫秒数。</td>
</tr>
<tr>
<td>8</td>
<td><code>int hashCode()</code></td>
<td>返回调用对象的哈希码。</td>
</tr>
<tr>
<td>9</td>
<td><code>void setTime(long time)</code></td>
<td>设置时间指定的时间和日期，表示从1970年1月1日午夜开始的经过时间(以毫秒为单位)。</td>
</tr>
<tr>
<td>10</td>
<td><code>String toString( )</code></td>
<td>将调用<code>Date</code>对象转换为字符串并返回结果。</td>
</tr>
</tbody></table>
<h4 id="1-获取当前日期和时间"><a href="#1-获取当前日期和时间" class="headerlink" title="1. 获取当前日期和时间"></a>1. 获取当前日期和时间</h4><p>这是一种在Java中获取当前日期和时间的简单方法。可以使用<code>Date</code>对象<code>toString()</code>方法来打印当前日期和时间，如下所示 - </p>
<pre><code class="java">import java.util.Date;
public class Test &#123;

   public static void main(String args[]) &#123;
      // 实例化Date对象
      Date date = new Date();

      // display time and date using toString()
      System.out.println(date.toString());
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">Fri Mar 15 13:00:37 CST 2020
Shell
</code></pre>
<h4 id="2-使用SimpleDateFormat设置日期格式"><a href="#2-使用SimpleDateFormat设置日期格式" class="headerlink" title="2. 使用SimpleDateFormat设置日期格式"></a>2. 使用SimpleDateFormat设置日期格式</h4><p><code>SimpleDateFormat</code>是一个具体的类，用于以区域设置的方式格式化和解析日期。 <code>SimpleDateFormat</code>用于从为日期时间格式选择用户定义的模式。</p>
<p><strong>示例</strong></p>
<pre><code class="java">import java.text.SimpleDateFormat;
import java.util.Date;

public class Test &#123;

    public static void main(String args[]) &#123;
        Date dNow = new Date();
        SimpleDateFormat ft = new SimpleDateFormat(&quot;yyyy.MM.dd (E)&#39;at&#39; hh:mm:ss a zzz&quot;);

        System.out.println(&quot;Current Date: &quot; + ft.format(dNow));

        SimpleDateFormat ft2 = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);

        System.out.println(&quot;Current Datetime: &quot; + ft2.format(dNow));

    &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">Current Date: 2019.03.15 (星期五)at 01:04:52 下午 CST
Current Datetime: 2019-03-15 01:04:52
Shell
</code></pre>
<p><strong>DateFormat格式代码</strong></p>
<p>要指定时间格式，请使用时间模式字符串。 在此模式中，所有ASCII字母都保留为模式字母，其定义如下 - </p>
<table>
<thead>
<tr>
<th>编号</th>
<th>字符</th>
<th>描述</th>
<th>示全歼</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>G</td>
<td>时代指示符</td>
<td>AD</td>
</tr>
<tr>
<td>2</td>
<td>y</td>
<td>四位数的年份值</td>
<td>2019</td>
</tr>
<tr>
<td>3</td>
<td>M</td>
<td>月份</td>
<td>July or 07</td>
</tr>
<tr>
<td>4</td>
<td>d</td>
<td>日</td>
<td>10</td>
</tr>
<tr>
<td>5</td>
<td>h</td>
<td>小时 A.M./P.M. (1~12)</td>
<td>12</td>
</tr>
<tr>
<td>6</td>
<td>H</td>
<td>24小时制的小时表示 (0~23)</td>
<td>22</td>
</tr>
<tr>
<td>7</td>
<td>m</td>
<td>分钟</td>
<td>30</td>
</tr>
<tr>
<td>8</td>
<td>s</td>
<td>秒钟</td>
<td>55</td>
</tr>
<tr>
<td>9</td>
<td>S</td>
<td>毫秒</td>
<td>234</td>
</tr>
<tr>
<td>10</td>
<td>E</td>
<td>星期几</td>
<td>Tuesday</td>
</tr>
<tr>
<td>11</td>
<td>D</td>
<td>一年中的第几天</td>
<td>360</td>
</tr>
<tr>
<td>12</td>
<td>F</td>
<td>一个月中的某一天</td>
<td>2 (second Wed. in July)</td>
</tr>
<tr>
<td>13</td>
<td>w</td>
<td>一年中的第几个星期</td>
<td>40</td>
</tr>
<tr>
<td>14</td>
<td>W</td>
<td>一月中的第几个星期</td>
<td>1</td>
</tr>
<tr>
<td>15</td>
<td>a</td>
<td>A.M./P.M. 标记</td>
<td>PM</td>
</tr>
<tr>
<td>16</td>
<td>k</td>
<td>小时 (1~24)</td>
<td>24</td>
</tr>
<tr>
<td>17</td>
<td>K</td>
<td>小时 A.M./P.M. (0~11)</td>
<td>10</td>
</tr>
<tr>
<td>18</td>
<td>z</td>
<td>时区</td>
<td>Eastern Standard Time</td>
</tr>
<tr>
<td>19</td>
<td>‘</td>
<td>转义文本</td>
<td>Delimiter</td>
</tr>
<tr>
<td>20</td>
<td>`</td>
<td>单引号</td>
<td>`</td>
</tr>
</tbody></table>
<h4 id="3-使用printf格式化日期"><a href="#3-使用printf格式化日期" class="headerlink" title="3. 使用printf格式化日期"></a>3. 使用printf格式化日期</h4><p>使用<code>printf</code>方法来完成日期和时间格式化。使用双字母格式，以<code>t</code>开头并以表格的一个字母结尾，如下面的代码所示。</p>
<pre><code class="java">import java.text.SimpleDateFormat;
import java.util.Date;

public class Test &#123;

    public static void main(String args[]) &#123;
        // Instantiate a Date object
        Date date = new Date();

        // display time and date
        String str = String.format(&quot;Current Date/Time : %tc&quot;, date);

        System.out.printf(str);

    &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">Current Date/Time : 星期五 三月 15 13:18:24 CST 2019
Shell
</code></pre>
<p>如果多次提供日期来格式化每个部分，那多少会有点愚蠢。 格式字符串可以指示要格式化的参数的索引。</p>
<p>索引必须紧跟<code>%</code>，并且必须以<code>$</code>结尾。</p>
<p><strong>示例</strong></p>
<pre><code class="java">import java.text.SimpleDateFormat;
import java.util.Date;

public class Test &#123;

    public static void main(String args[]) &#123;
        // Instantiate a Date object
        Date date = new Date();

        // display time and date
        System.out.printf(&quot;%1$s %2$tB %2$td, %2$tY&quot;, &quot;Due date:&quot;, date);
    &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">Due date: 三月 16, 2019
Shell
</code></pre>
<p>或者，可以使用<code>&lt;</code>标志。 它表示再次使用与前面的格式规范相同的参数。</p>
<pre><code class="java">import java.text.SimpleDateFormat;
import java.util.Date;

public class Test &#123;

    public static void main(String args[]) &#123;
        // Instantiate a Date object
        Date date = new Date();

        // display formatted date
        System.out.printf(&quot;%s %tB %&lt;te, %&lt;tY&quot;, &quot;Due date:&quot;, date);
    &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">Due date: 三月 16, 2019
Shell
</code></pre>
<h4 id="4-日期和时间转换字符"><a href="#4-日期和时间转换字符" class="headerlink" title="4. 日期和时间转换字符"></a>4. 日期和时间转换字符</h4><p><strong>示例</strong></p>
<table>
<thead>
<tr>
<th>编号</th>
<th>字符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>c</td>
<td>完全日期和时间</td>
<td>Mon May 04 09:51:52 CDT 2019</td>
</tr>
<tr>
<td>2</td>
<td>F</td>
<td>ISO 8601 date</td>
<td>2004-02-09</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>U.S. formatted date (month/day/year)</td>
<td>02/09/2004</td>
</tr>
<tr>
<td>4</td>
<td>T</td>
<td>24小时时间</td>
<td>18:05:19</td>
</tr>
<tr>
<td>5</td>
<td>r</td>
<td>12小时时间</td>
<td>06:05:19 pm</td>
</tr>
<tr>
<td>6</td>
<td>R</td>
<td>24小时时间, 无秒钟。</td>
<td>18:05</td>
</tr>
<tr>
<td>7</td>
<td>Y</td>
<td>四位数年份(前导零)</td>
<td>2019</td>
</tr>
<tr>
<td>8</td>
<td>y</td>
<td>年份的最后两位数(带前导零)</td>
<td>19</td>
</tr>
<tr>
<td>9</td>
<td>C</td>
<td>年份的前两位数(带前导零)</td>
<td>20</td>
</tr>
<tr>
<td>10</td>
<td>B</td>
<td>月份全名称</td>
<td>February</td>
</tr>
<tr>
<td>11</td>
<td>b</td>
<td>缩写的月份名称</td>
<td>Feb</td>
</tr>
<tr>
<td>12</td>
<td>m</td>
<td>两位数月份(带前导零)</td>
<td>02</td>
</tr>
<tr>
<td>13</td>
<td>d</td>
<td>两位数的日期(带前导零)</td>
<td>03</td>
</tr>
<tr>
<td>14</td>
<td>e</td>
<td>两位数的日期(没有前导零)</td>
<td>9</td>
</tr>
<tr>
<td>15</td>
<td>A</td>
<td>完整的工作日名称</td>
<td>Monday</td>
</tr>
<tr>
<td>16</td>
<td>a</td>
<td>缩写的工作日名称</td>
<td>Mon</td>
</tr>
<tr>
<td>17</td>
<td>j</td>
<td>一年中的三位数日(带前导零)</td>
<td>069</td>
</tr>
<tr>
<td>18</td>
<td>H</td>
<td>两位数小时(前导零)，介于00和23之间</td>
<td>18</td>
</tr>
<tr>
<td>19</td>
<td>k</td>
<td>两位数小时(不带前导零)，介于0和23之间</td>
<td>18</td>
</tr>
<tr>
<td>20</td>
<td>I</td>
<td>两位数小时(前导零)，介于01和12之间</td>
<td>06</td>
</tr>
<tr>
<td>21</td>
<td>l</td>
<td>两位数小时(不带前导零)，介于1和12之间</td>
<td>6</td>
</tr>
<tr>
<td>22</td>
<td>M</td>
<td>两位数分钟(带前导零)</td>
<td>05</td>
</tr>
<tr>
<td>23</td>
<td>S</td>
<td>两位数秒(带前导零)</td>
<td>19</td>
</tr>
<tr>
<td>24</td>
<td>L</td>
<td>三位数毫秒(带前导零)</td>
<td>047</td>
</tr>
<tr>
<td>25</td>
<td>N</td>
<td>九位纳秒(带前导零)</td>
<td>047000000</td>
</tr>
<tr>
<td>26</td>
<td>P</td>
<td>大写上午或下午标记</td>
<td>PM</td>
</tr>
<tr>
<td>27</td>
<td>p</td>
<td>小写上午或下午标记</td>
<td>pm</td>
</tr>
<tr>
<td>28</td>
<td>z</td>
<td>GMT的RFC 822数字偏移量</td>
<td>-0800</td>
</tr>
<tr>
<td>29</td>
<td>Z</td>
<td>时区</td>
<td>PST</td>
</tr>
<tr>
<td>30</td>
<td>s</td>
<td>自1970-01-01 00:00:00 GMT以来的秒数</td>
<td>1078884319</td>
</tr>
<tr>
<td>31</td>
<td>Q</td>
<td>自1970-01-01 00:00:00 GMT以来的毫秒数</td>
<td>1078884319047</td>
</tr>
</tbody></table>
<p>还有其他与日期和时间相关的有用类。 有关更多详细信息，请参阅Java标准文档。</p>
<h4 id="5-将字符串解析为日期"><a href="#5-将字符串解析为日期" class="headerlink" title="5. 将字符串解析为日期"></a>5. 将字符串解析为日期</h4><p><code>SimpleDateFormat</code>类有一些额外的方法，特别是<code>parse()</code>，它用于根据存储在给定的<code>SimpleDateFormat</code>对象中的格式来解析字符串。</p>
<p><strong>示例</strong></p>
<pre><code class="java">import java.util.*;
import java.text.*;

public class Test &#123;

    public static void main(String args[]) &#123;
        SimpleDateFormat ft = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        String input = args.length == 0 ? &quot;2019-11-11&quot; : args[0];

        System.out.print(input + &quot; 解析为：&quot;);
        Date t;
        try &#123;
            t = ft.parse(input);
            System.out.println(t);
        &#125; catch (ParseException e) &#123;
            System.out.println(&quot;Unparseable using &quot; + ft);
        &#125;
    &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">2019-11-11 解析为：Mon Nov 11 00:00:00 CST 2019
Shell
</code></pre>
<h4 id="6-睡眠一段时间"><a href="#6-睡眠一段时间" class="headerlink" title="6. 睡眠一段时间"></a>6. 睡眠一段时间</h4><p>可以在计算机生命周期的任何时间段内睡眠。 例如，以下程序将睡眠<code>3</code>秒钟 - </p>
<pre><code class="java">import java.util.*;
import java.text.*;

public class Test &#123;

    public static void main(String args[]) &#123;
        try &#123;
            System.out.println(new Date());
            Thread.sleep(5 * 60 * 10);
            System.out.println(new Date());
        &#125; catch (Exception e) &#123;
            System.out.println(&quot;Got an exception!&quot;);
        &#125;
    &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">Sat Mar 16 15:51:43 CST 2019
Sat Mar 16 15:51:46 CST 2019
Shell
</code></pre>
<h4 id="7-测量经过的时间"><a href="#7-测量经过的时间" class="headerlink" title="7. 测量经过的时间"></a>7. 测量经过的时间</h4><p>有时，可能需要以毫秒为单位测量时间点。 重写上面的例子 - </p>
<pre><code class="java">import java.util.*;
import java.text.*;

public class Test &#123;

    public static void main(String args[]) &#123;
        try &#123;
            long start = System.currentTimeMillis();
            System.out.println(new Date());

            Thread.sleep(5 * 60 * 10);
            System.out.println(new Date());

            long end = System.currentTimeMillis();
            long diff = end - start;
            System.out.println(&quot;时间差为: &quot; + diff);
        &#125; catch (Exception e) &#123;
            System.out.println(&quot;Got an exception!&quot;);
        &#125;
    &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">Sat Mar 16 15:53:25 CST 2019
Sat Mar 16 15:53:28 CST 2019
Difference is : 3021
</code></pre>
<h1 id="Java正则表达式"><a href="#Java正则表达式" class="headerlink" title="Java正则表达式"></a>Java正则表达式</h1><p>Java提供了<code>java.util.regex</code>包，用于与正则表达式进行模式匹配。 Java正则表达式与Perl编程语言非常相似，非常容易学习。</p>
<p>正则表达式是一种特殊的字符序列，可使用模式中的专用语法来匹配或查找其他字符串或字符串集。 它们可用于搜索，编辑或操作文本和数据。</p>
<p><code>java.util.regex</code>包主要由以下三个类组成 -</p>
<ul>
<li><code>Pattern</code>类 - <code>Pattern</code>对象是正则表达式的编译表示。 <code>Pattern</code>类不提供公共构造函数。 要创建模式，需要首先调用它的公共静态<code>compile()</code>方法，然后返回<code>Pattern</code>对象。 这些方法接受正则表达式作为第一个参数。</li>
<li><code>Matcher</code>类 -  <code>Matcher</code>对象是解释模式并对输入字符串执行匹配操作的引擎。 与<code>Pattern</code>类一样，<code>Matcher</code>没有定义公共构造函数。 通过在<code>Pattern</code>对象上调用<code>matcher()</code>方法获取<code>Matcher</code>对象。</li>
<li><code>PatternSyntaxException</code>  -  <code>PatternSyntaxException</code>对象是未经检查的异常，指示正则表达式模式中的语法错误。</li>
</ul>
<h2 id="1-捕获组"><a href="#1-捕获组" class="headerlink" title="1. 捕获组"></a>1. 捕获组</h2><p>捕获组是将多个字符视为一个单元的一种方法。 它们是通过将要分组的字符放在一组括号中来创建的。 例如，正则表达式(<code>dog</code>)创建包含字母<code>d</code>，<code>o</code>和<code>g</code>的单个组。</p>
<p>捕获组通过从左到右计算它们的左括号来编号。 在表达式<code>((A)(B(C)))</code>中，例如，有四个这样的组 - </p>
<ul>
<li><code>((A)(B(C)))</code></li>
<li><code>(A)</code></li>
<li><code>(B(C))</code></li>
<li><code>(C)</code></li>
</ul>
<p>要查找表达式中存在多少个组，请在<code>Matcher</code>对象上调用<code>groupCount()</code>方法。 <code>groupCount()</code>方法返回一个<code>int</code>类型值，显示<code>Matcher</code>模式中存在的捕获组数。</p>
<p>还有一个特殊组，即组<code>0</code>，它始终代表整个表达式。 该组未包含在<code>groupCount()</code>报告的总数中。</p>
<p><strong>示例</strong></p>
<p>以下示例说明如何从给定的字母数字字符串中查找数字字符串 - </p>
<pre><code class="java">import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexMatches &#123;

   public static void main( String args[] ) &#123;
      // String to be scanned to find the pattern.
      String line = &quot;This order was placed for QT3000! OK?&quot;;
      String pattern = &quot;(.*)(\\d+)(.*)&quot;;

      // Create a Pattern object
      Pattern r = Pattern.compile(pattern);

      // Now create matcher object.
      Matcher m = r.matcher(line);
      if (m.find( )) &#123;
         System.out.println(&quot;Found value: &quot; + m.group(0) );
         System.out.println(&quot;Found value: &quot; + m.group(1) );
         System.out.println(&quot;Found value: &quot; + m.group(2) );
      &#125;else &#123;
         System.out.println(&quot;NO MATCH&quot;);
      &#125;
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">Found value: This order was placed for QT3000! OK?
Found value: This order was placed for QT300
Found value: 0
Shell
</code></pre>
<h2 id="2-正则表达式语法"><a href="#2-正则表达式语法" class="headerlink" title="2. 正则表达式语法"></a>2. 正则表达式语法</h2><p>下面列出了Java中可用的所有正则表达式元字符语法 - </p>
<table>
<thead>
<tr>
<th>编号</th>
<th>子表达式</th>
<th>匹配</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>^</code></td>
<td>匹配行的开头。</td>
</tr>
<tr>
<td>2</td>
<td><code>$</code></td>
<td>匹配行的结尾。</td>
</tr>
<tr>
<td>3</td>
<td><code>.</code></td>
<td>匹配除换行符之外的任何单个字符，使用<code>m</code>选项也可以匹配换行符。</td>
</tr>
<tr>
<td>4</td>
<td><code>[...]</code></td>
<td>匹配括号中的任何单个字符。</td>
</tr>
<tr>
<td>5</td>
<td><code>[^...]</code></td>
<td>匹配括号内的任何单个字符。</td>
</tr>
<tr>
<td>6</td>
<td><code>\A</code></td>
<td>整个字符串的开头。</td>
</tr>
<tr>
<td>7</td>
<td><code>\z</code></td>
<td>整个字符串的结尾。</td>
</tr>
<tr>
<td>8</td>
<td><code>\Z</code></td>
<td>除允许的最终行终止符之外的整个字符串的结尾。</td>
</tr>
<tr>
<td>9</td>
<td><code>re*</code></td>
<td>匹配前面表达式的<code>0</code>次或更多次出现。</td>
</tr>
<tr>
<td>10</td>
<td><code>re+</code></td>
<td>匹配前面表达式的<code>1</code>次或更多次出现。</td>
</tr>
<tr>
<td>11</td>
<td><code>re?</code></td>
<td>匹配前面表达式的<code>0</code>或<code>1</code>次出现。</td>
</tr>
<tr>
<td>12</td>
<td><code>re&#123;n&#125;</code></td>
<td>准确匹配前面表达式的<code>n</code>次出现次数。</td>
</tr>
<tr>
<td>13</td>
<td><code>re&#123;n,&#125;</code></td>
<td>准确匹配前面表达式的<code>n</code>次以上出现次数。</td>
</tr>
<tr>
<td>14</td>
<td>aΙb</td>
<td>匹配<code>a</code>或<code>b</code>。</td>
</tr>
<tr>
<td>15</td>
<td><code>(re)</code></td>
<td>对正则表达式进行分组并记住匹配的文本。</td>
</tr>
<tr>
<td>16</td>
<td><code>(?: re)</code></td>
<td>将正则表达式分组而不记住匹配的文本。</td>
</tr>
<tr>
<td>17</td>
<td><code>(?&gt; re)</code></td>
<td>匹配独立模式而无需回溯。</td>
</tr>
<tr>
<td>18</td>
<td><code>\w</code></td>
<td>匹配单词字符。</td>
</tr>
<tr>
<td>19</td>
<td><code>\W</code></td>
<td>匹配非单词字符。</td>
</tr>
<tr>
<td>20</td>
<td><code>\s</code></td>
<td>匹配空白符，相当于：<code>[\t\n\r\f]</code></td>
</tr>
<tr>
<td>21</td>
<td><code>\S</code></td>
<td>匹配非空白。</td>
</tr>
<tr>
<td>22</td>
<td><code>\d</code></td>
<td>匹配数字，相当于：<code>[0-9]</code>。</td>
</tr>
<tr>
<td>23</td>
<td><code>\D</code></td>
<td>匹配非数字。</td>
</tr>
<tr>
<td>24</td>
<td><code>\A</code></td>
<td>匹配字符串的开头。</td>
</tr>
<tr>
<td>25</td>
<td><code>\Z</code></td>
<td>匹配字符串的结尾。如果存在换行符，则它在换行符之前匹配。</td>
</tr>
<tr>
<td>26</td>
<td><code>\z</code></td>
<td>匹配字符串的结尾。</td>
</tr>
<tr>
<td>27</td>
<td><code>\G</code></td>
<td>匹配最后一个匹配结束的点。</td>
</tr>
<tr>
<td>28</td>
<td><code>\n</code></td>
<td>反向引用以捕获组号：<code>n</code>。</td>
</tr>
<tr>
<td>29</td>
<td><code>\b</code></td>
<td>在括号外部匹配单词边界，在括号内匹配退格(<code>0x08</code>)。</td>
</tr>
<tr>
<td>30</td>
<td><code>\B</code></td>
<td>匹配非字边界。</td>
</tr>
<tr>
<td>31</td>
<td><code>\n</code>,<code>\t</code></td>
<td>匹配换行符，回车符，制表符等。</td>
</tr>
<tr>
<td>32</td>
<td><code>\E</code></td>
<td>转义(引用)所有字符直到<code>\E</code>。</td>
</tr>
<tr>
<td>33</td>
<td><code>\Q</code></td>
<td>结束以<code>\Q</code>开头引用。</td>
</tr>
</tbody></table>
<p> <strong>start()和end()方法</strong></p>
<p>以下是计算字符串中：<code>cat</code>一词的出现次数示例 - </p>
<pre><code class="java">import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexMatches &#123;

   private static final String REGEX = &quot;\\bcat\\b&quot;;
   private static final String INPUT = &quot;cat cat cat cattie cat&quot;;

   public static void main( String args[] ) &#123;
      Pattern p = Pattern.compile(REGEX);
      Matcher m = p.matcher(INPUT);   // get a matcher object
      int count = 0;

      while(m.find()) &#123;
         count++;
         System.out.println(&quot;Match number &quot;+count);
         System.out.println(&quot;start(): &quot;+m.start());
         System.out.println(&quot;end(): &quot;+m.end());
      &#125;
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">Match number 1
start(): 0
end(): 3
Match number 2
start(): 4
end(): 7
Match number 3
start(): 8
end(): 11
Match number 4
start(): 19
end(): 22
Shell
</code></pre>
<p>可以看到此示例使用单词边界来确保字母：<code>c</code>,<code>a</code>,<code>t</code>不仅仅是较长单词中的子字符串。 它还提供了有关输入字符串中匹配发生位置的一些有用信息。</p>
<p><code>start</code>方法返回上一个匹配操作期间给定组捕获的子序列的起始索引，<code>end</code>返回匹配的最后一个字符的索引加<code>1</code>。</p>
<p><strong>matches和lookingAt方法</strong></p>
<p><code>matches()</code>和<code>lookingAt()</code>方法都尝试将输入序列与模式匹配。 然而，不同之处在于匹配需要匹配整个输入序列，而查找则不需要。</p>
<p>两种方法总是从输入字符串的开头开始。 以下是上述方法的示例 - </p>
<pre><code class="java">import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexMatches &#123;

   private static final String REGEX = &quot;foo&quot;;
   private static final String INPUT = &quot;fooooooooooooooooo&quot;;
   private static Pattern pattern;
   private static Matcher matcher;

   public static void main( String args[] ) &#123;
      pattern = Pattern.compile(REGEX);
      matcher = pattern.matcher(INPUT);

      System.out.println(&quot;Current REGEX is: &quot;+REGEX);
      System.out.println(&quot;Current INPUT is: &quot;+INPUT);

      System.out.println(&quot;lookingAt(): &quot;+matcher.lookingAt());
      System.out.println(&quot;matches(): &quot;+matcher.matches());
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">Current REGEX is: foo
Current INPUT is: fooooooooooooooooo
lookingAt(): true
matches(): false
Shell
</code></pre>
<p><strong>replaceFirst和replaceAll方法</strong><br><code>replaceFirst()</code>和<code>replaceAll()</code>方法替换匹配给定正则表达式的文本。 正如其名称所示，<code>replaceFirst()</code>替换第一个匹配项，<code>replaceAll()</code>替换所有匹配项。</p>
<p>以下是上述功能的示例 - </p>
<pre><code class="java">import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexMatches &#123;

   private static String REGEX = &quot;dog&quot;;
   private static String INPUT = &quot;The dog says meow. &quot; + &quot;All dogs say meow.&quot;;
   private static String REPLACE = &quot;cat&quot;;

   public static void main(String[] args) &#123;
      Pattern p = Pattern.compile(REGEX);

      // get a matcher object
      Matcher m = p.matcher(INPUT); 
      INPUT = m.replaceAll(REPLACE);
      System.out.println(INPUT);
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">The cat says meow. All cats say meow.
Shell
</code></pre>
<p><strong>appendReplacement和appendTail方法</strong></p>
<p><code>Matcher</code>类还提供了<code>appendReplacement</code>和<code>appendTail</code>方法来替换文本。</p>
<p>以下是上述方法的示例 - </p>
<pre><code class="java">import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexMatches &#123;

   private static String REGEX = &quot;a*b&quot;;
   private static String INPUT = &quot;aabfooaabfooabfoob&quot;;
   private static String REPLACE = &quot;-&quot;;
   public static void main(String[] args) &#123;

      Pattern p = Pattern.compile(REGEX);

      // get a matcher object
      Matcher m = p.matcher(INPUT);
      StringBuffer sb = new StringBuffer();
      while(m.find()) &#123;
         m.appendReplacement(sb, REPLACE);
      &#125;
      m.appendTail(sb);
      System.out.println(sb.toString());
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">-foo-foo-foo-
</code></pre>
<h1 id="Java方法"><a href="#Java方法" class="headerlink" title="Java方法"></a>Java方法</h1><p>Java中的方法是一组语句，它们组合在一起以执行各种操作。 例如，当调用<code>System.out.println()</code>方法时，系统实际上会执行多个语句，以便在控制台上显示消息。</p>
<p>下面将学习如何使用或不使用返回值创建自己的方法，使用或不使用参数调用方法，以及在程序设计中应用方法抽象。</p>
<h2 id="1-创建方法"><a href="#1-创建方法" class="headerlink" title="1. 创建方法"></a>1. 创建方法</h2><p>下面来看看方法的语法 - </p>
<pre><code class="java">public static int methodName(int a, int b) &#123;
   // body
&#125;
Java
</code></pre>
<p>在上面语法中，</p>
<ul>
<li><code>public static</code> − 修辞符</li>
<li><code>int</code> − 返回值的类型</li>
<li><code>methodName</code> − 方法的名称</li>
<li><code>a, b</code> − 形式参数</li>
<li><code>int a, int b</code> − 参数列表</li>
</ul>
<p>方法定义由方法头和方法体组成。以下语法中显示了相同的内容 - </p>
<pre><code class="java">modifier returnType nameOfMethod (Parameter List) &#123;
   // method body
&#125;
Java
</code></pre>
<p>上面显示的语法包括 - </p>
<ul>
<li><code>modifier</code> - 它定义方法的访问类型，它可能是：<code>public</code>,<code>private</code>,<code>protected</code>或不指定。</li>
<li><code>returnType</code> -  方法可以返回一个值。</li>
<li><code>nameOfMethod</code> - 这是方法名称，方法签名由方法名称和参数列表组成。</li>
<li><code>Parameter List</code> - 参数列表，它是方法的类型，顺序和参数数量。 这些是可选的，方法可能包含零参数。</li>
<li><code>method body</code> - 方法体定义方法对语句的作用。</li>
</ul>
<p><strong>示例</strong></p>
<p>以下代码中定义了<code>min()</code>方法。 这个方法有两个<code>int</code>类型的参数：<code>num1</code>和<code>num2</code>，并返回两者之间的最大值 - </p>
<pre><code class="java">/** 返回两个数字之间的最小值 */
public static int minFunction(int n1, int n2) &#123;
   int min;
   if (n1 &gt; n2)
      min = n2;
   else
      min = n1;

   return min; 
&#125;
Java
</code></pre>
<h2 id="2-方法调用"><a href="#2-方法调用" class="headerlink" title="2. 方法调用"></a>2. 方法调用</h2><p>可通过调用方法来使用方法，调用方法有两种方式，即方法有返回值或无返回任何值。</p>
<p>方法调用的过程很简单。 当程序调用方法时，程序控制将转移到被调用的方法。 这个被调用的方法然后在两个条件下将控制权返回给调用者，即 - </p>
<ul>
<li><code>return</code>语句被执行。</li>
<li>它到达方法的结束，即右大括号(<code>&#125;</code>)。</li>
</ul>
<p>对返回<code>void</code>的方法的调用 - </p>
<pre><code class="java">System.out.println(&quot;This is Yiibai.com!&quot;);
Java
</code></pre>
<p>对有返回值的方法的调用 - </p>
<pre><code class="java">int result = sum(6, 9);
Java
</code></pre>
<p>以下是演示如何定义方法以及如何调用方法的示例 - </p>
<pre><code class="java">public class ExampleMinNumber &#123;

   public static void main(String[] args) &#123;
      int a = 111;
      int b = 125;
      int c = getMin(a, b);
      System.out.println(&quot;最小值 = &quot; + c);
   &#125;

   /** 返回两个 int 数值的最小值 */
   public static int getMin(int n1, int n2) &#123;
      int min;
      if (n1 &gt; n2)
         min = n2;
      else
         min = n1;

      return min; 
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">最小值 = 111
Shell
</code></pre>
<h2 id="3-void关键字"><a href="#3-void关键字" class="headerlink" title="3. void关键字"></a>3. void关键字</h2><p><code>void</code>关键字允许创建不返回值的方法。在下面的例子中有一个返回值是<code>void</code>的方法<code>methodRankPoints</code>，它不返回任何值。 调用<code>void</code>方法必须是一个语句，即<code>methodRankPoints(245.67);</code>. 它是一个以分号结尾的Java语句，如以下示例所示 -</p>
<pre><code class="java">public class ExampleVoid &#123;

   public static void main(String[] args) &#123;
      methodRankPoints(245.67);
   &#125;

   public static void methodRankPoints(double points) &#123;
      if (points &gt;= 202.5) &#123;
         System.out.println(&quot;Rank:A1&quot;);
      &#125;else if (points &gt;= 122.4) &#123;
         System.out.println(&quot;Rank:A2&quot;);
      &#125;else &#123;
         System.out.println(&quot;Rank:A3&quot;);
      &#125;
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">Rank:A1
Shell
</code></pre>
<h2 id="4-按值传递参数"><a href="#4-按值传递参数" class="headerlink" title="4. 按值传递参数"></a>4. 按值传递参数</h2><p>在按值传递参数时需要传递参数。它们的顺序应与方法规范中的参数顺序相同。参数可以通过值或引用传递。</p>
<p>通过值传递参数是使用参数调用方法。 通过这样将参数值将传递给参数。</p>
<p><strong>示例</strong></p>
<p>以下程序显示了按值传递参数的示例。 即使在方法调用之后，参数的值仍保持不变。</p>
<pre><code class="java">public class swappingExample &#123;

   public static void main(String[] args) &#123;
      int a = 30;
      int b = 45;
      System.out.println(&quot;Before swapping, a = &quot; + a + &quot; and b = &quot; + b);

      // 调用交换方法
      swapFunction(a, b);
      System.out.println(&quot;Now, Before and After swapping values will be same here:&quot;);
      System.out.println(&quot;After swapping, a = &quot; + a + &quot; and b is &quot; + b);
   &#125;

   public static void swapFunction(int a, int b) &#123;
      System.out.println(&quot;Before swapping(Inside), a = &quot; + a + &quot; b = &quot; + b);
      // 交换 n1 和 n2
      int c = a;
      a = b;
      b = c;
      System.out.println(&quot;After swapping(Inside), a = &quot; + a + &quot; b = &quot; + b);
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">Before swapping, a = 30 and b = 45
Before swapping(Inside), a = 30 b = 45
After swapping(Inside), a = 45 b = 30
Now, Before and After swapping values will be same here:
After swapping, a = 30 and b is 45
Shell
</code></pre>
<h2 id="5-方法重载"><a href="#5-方法重载" class="headerlink" title="5. 方法重载"></a>5. 方法重载</h2><p>当一个类有两个或多个同名但方法不同参数的方法时，称为方法重载。 它与重写不同。 在重写中，方法具有相同的方法名称，类型，参数数量等。</p>
<p>在前面讨论的用于查找最小整数类型数的示例中，假设想要查找两个<code>double</code>类型的最小数值。 可引入重载的概念以创建具有相同名称但不同参数的两个或更多方法。</p>
<p>参考以下示例代码 - </p>
<pre><code class="java">public class ExampleOverloading &#123;

   public static void main(String[] args) &#123;
      int a = 11;
      int b = 6;
      double c = 7.3;
      double d = 9.4;
      int result1 = getMin(a, b);

      // 具有相同函数名称，但数字不同参数
      double result2 = getMin(c, d);
      System.out.println(&quot;Minimum Value = &quot; + result1);
      System.out.println(&quot;Minimum Value = &quot; + result2);
   &#125;

   // 处理 int 类型的数值(方法重载)
   public static int getMin(int n1, int n2) &#123;
      int min;
      if (n1 &gt; n2)
         min = n2;
      else
         min = n1;

      return min; 
   &#125;

   //  处理 double 类型的数值(方法重载)
   public static double getMin(double n1, double n2) &#123;
     double min;
      if (n1 &gt; n2)
         min = n2;
      else
         min = n1;

      return min; 
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">Minimum Value = 6
Minimum Value = 7.3
Shell
</code></pre>
<p>重载方法使程序可读。这里，两个方法由相同的名称给出但具有不同的参数类型。结果是求<code>int</code>类型和<code>double</code>类型的最小数。</p>
<h2 id="6-使用命令行参数"><a href="#6-使用命令行参数" class="headerlink" title="6. 使用命令行参数"></a>6. 使用命令行参数</h2><p>有时希望在运行程序时将一些信息传递给程序。它是通过将命令行参数传递给<code>main()</code>来实现的。</p>
<p>命令行参数是执行时在命令行上直接跟随程序名称的信息。 要访问Java程序中的命令行参数非常简单。 它们作为字符串存储在传递给<code>main()</code>的<code>String</code>类型数组中。</p>
<p><strong>示例</strong></p>
<p>以下程序显示传递给程序的所有命令行参数 - </p>
<pre><code class="java">public class CommandLine &#123;

   public static void main(String args[]) &#123; 
      for(int i = 0; i&lt;args.length; i++) &#123;
         System.out.println(&quot;args[&quot; + i + &quot;]: &quot; +  args[i]);
      &#125;
   &#125;
&#125;
Java
</code></pre>
<p>使用以下方式执行此程序 - </p>
<pre><code class="shell">C:/&gt; java CommandLine this is a command line 200 -100
Shell
</code></pre>
<p>那么将得到以下结果：</p>
<pre><code class="shell">args[0]: this
args[1]: is
args[2]: a
args[3]: command
args[4]: line
args[5]: 200
args[6]: -100
Shell
</code></pre>
<h2 id="7-this-关键字"><a href="#7-this-关键字" class="headerlink" title="7. this 关键字"></a>7. this 关键字</h2><p><code>this</code>是Java中的一个关键字，用作对当前类对象的引用，在实例方法或构造函数中。 使用它可以引用类的成员，例如：构造函数，变量和方法。</p>
<blockquote>
<p>注 - <code>this</code>关键字仅在实例方法或构造函数中使用。</p>
</blockquote>
<p>通常，<code>this</code>关键字用于 - </p>
<ul>
<li><p>如果实例变量在构造函数或方法中具有相同的名称，则将它们与局部变量区分开来。</p>
<pre><code class="java">class Student &#123;
 private int age;   
 Student(int age) &#123;
    this.age = age;
 &#125;
&#125;
Java
</code></pre>
</li>
<li><p>从类中的其他方法调用一种类型的构造函数(参数化构造函数或默认值)，称为显式构造函数调用。</p>
<pre><code class="java">class Student &#123;
 int age
 Student() &#123;
    this(20);
 &#125;

 Student(int age) &#123;
    this.age = age;    
 &#125;
&#125;
Java
</code></pre>
</li>
</ul>
<p>以下是使用<code>this</code>关键字访问类成员的示例 - </p>
<pre><code class="java">public class ThisExample &#123;
   // 实例变量：num
   int num = 10;
   ThisExample() &#123;
      System.out.println(&quot;This is an example program on keyword this&quot;);    
   &#125;

   ThisExample(int num) &#123;
      // 调用默认构造方法
      this();

      // 将局部变量 num 分配给实例变量 num 
      this.num = num;
   &#125;

   public void greet() &#123;
      System.out.println(&quot;Hi Welcome to Yiibai&quot;);
   &#125;

   public void print() &#123;
      // 局部变量：num
      int num = 20;

      // 打印局部变量
      System.out.println(&quot;value of local variable num is : &quot;+num);

      // 打印实例变量
      System.out.println(&quot;value of instance variable num is : &quot;+this.num);

      // 调用类方法 
      this.greet();     
   &#125;

   public static void main(String[] args) &#123;
      // 实例化该类
      ThisExample obj1 = new ThisExample();

      // 调用 print 方法
      obj1.print();

      //通过参数化构造函数将新值传递给 num 变量
      ThisExample obj2 = new ThisExample(30);

      // 再次调用 print 方法
      obj2.print(); 
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果 - </p>
<pre><code class="shell">This is an example program on keyword this 
value of local variable num is : 20
value of instance variable num is : 10
Hi Welcome to Yiibai
This is an example program on keyword this 
value of local variable num is : 20
value of instance variable num is : 30
Hi Welcome to Yiibai
Shell
</code></pre>
<h2 id="8-变量参数-var-args"><a href="#8-变量参数-var-args" class="headerlink" title="8. 变量参数(var-args)"></a>8. 变量参数(var-args)</h2><p>JDK 1.5允许将可变数量的相同类型的参数传递给方法。方法中的参数声明如下 - </p>
<pre><code class="java">typeName... parameterName
Java
</code></pre>
<p>在方法声明中，指定类型后跟省略号(<code>...</code>)。 在方法中只能指定一个可变长度参数，并且此参数必须是最后一个参数。</p>
<pre><code class="java">public class VarargsDemo &#123;

   public static void main(String args[]) &#123;
       // 使用变量参数调用方法
       printMax(314, 321, 213, 212, 356.5);
       printMax(new double[]&#123;1, 2, 3&#125;);
   &#125;

   public static void printMax( double... numbers) &#123;
      if (numbers.length == 0) &#123;
         System.out.println(&quot;No argument passed&quot;);
         return;
      &#125;

      double result = numbers[0];

      for (int i = 1; i &lt;  numbers.length; i++)
      if (numbers[i] &gt;  result)
      result = numbers[i];
      System.out.println(&quot;参数列表中的最大值是：&quot; + result);
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果 - </p>
<pre><code class="shell">参数列表中的最大值是：356.5
参数列表中的最大值是：3.0
Shell
</code></pre>
<h2 id="9-finalize-方法"><a href="#9-finalize-方法" class="headerlink" title="9. finalize()方法"></a>9. finalize()方法</h2><p>finalize()方法在垃圾收集器对象最终销毁之前调用，它可用于确保对象完全终止。例如，可以使用<code>finalize()</code>来确保该对象拥有的打开文件已关闭。</p>
<p>要将终结器添加到类中，只需定义<code>finalize()</code>方法即可。只要Java方法要回收该类的对象，它就会调用该方法。</p>
<p>在<code>finalize()</code>方法中，将指定在销毁对象之前必须执行的操作。<code>finalize()</code>方法有这种一般形式 - </p>
<pre><code class="java">protected void finalize( ) &#123;
   // finalization code here
&#125;
Java
</code></pre>
<p>这里，关键字<code>protected</code>是一个修辞符，它阻止通过类外部定义的代码访问<code>finalize()</code>。<br>我们无法知道Java何时或甚至是否将执行<code>finalize()</code>方法。如果程序在垃圾收集发生之前结束，则<code>finalize()</code>将不会执行。</p>
<h1 id="Java文件和输入和输出（I-O）"><a href="#Java文件和输入和输出（I-O）" class="headerlink" title="Java文件和输入和输出（I/O）"></a>Java文件和输入和输出（I/O）</h1><p><code>java.io</code>包几乎包含了在Java中执行输入和输出(I/O)所需的所有类。 所有这些流代表输入源和输出目的地。 <code>java.io</code>包中的流支持许多数据，如：原始，对象，本地化字符等。</p>
<h2 id="1-流-Streams"><a href="#1-流-Streams" class="headerlink" title="1. 流(Streams)"></a>1. 流(Streams)</h2><p>流(<code>Streams</code>)可以定义为数据序列，它有两种 - </p>
<ul>
<li><code>InPutStream</code>  -  它用于从源读取数据。</li>
<li><code>OutPutStream</code>  -  它用于将数据写入目标。</li>
</ul>
<p><img src="https://www.yiibai.com/uploads/article/2019/03/18/165922_71746.png" alt="Java流"></p>
<p>Java为与文件和网络相关的I/O提供强大而灵活的支持，但本教程只涵盖了流和I/O相关的非常基本的功能。下面将看到一些最常用的例子 - </p>
<p><strong>1.1. 字节流</strong><br>Java字节流用于执行<code>8</code>位字节的输入和输出。尽管有许多与字节流相关的类，但最常用的类是<code>FileInputStream</code>和<code>FileOutputStream</code>。以下示例使用这两个类将输入文件的内容复制到输出文件中 - </p>
<pre><code class="java">import java.io.*;
public class CopyFile &#123;

   public static void main(String args[]) throws IOException &#123;  
      FileInputStream in = null;
      FileOutputStream out = null;

      try &#123;
         in = new FileInputStream(&quot;D:\\input.txt&quot;);
         out = new FileOutputStream(&quot;D:\\output.txt&quot;);
         int c;
         while ((c = in.read()) != -1) &#123;
            out.write(c);
         &#125;
      &#125;finally &#123;
         if (in != null) &#123;
            in.close();
         &#125;
         if (out != null) &#123;
            out.close();
         &#125;
      &#125;
   &#125;
&#125;
Java
</code></pre>
<p>假设在D盘下有一个文件：<code>input.txt</code>，它的内容如下 - </p>
<pre><code class="txt">This is test for copy file.
power by yiibai.com
Txt
</code></pre>
<p>下一步，编译上面的程序并执行它，它将创建一个：<code>D:/output.txt</code>文件，内容与<code>D:/input.txt</code>中的相同。</p>
<p><strong>1.2. 字符流</strong></p>
<p>Java字节流用于执行<code>8</code>位字节的输入和输出，而Java字符流用于执行<code>16</code>位unicode的输入和输出。 尽管有许多与字符流相关的类，但最常用的类是<code>FileReader</code>和<code>FileWriter</code>。 虽然<code>FileReader</code>内部使用<code>FileInputStream</code>类，而<code>FileWriter</code>内部使用<code>FileOutputStream</code>类，但主要区别在于<code>FileReader</code>一次读取两个字节，而<code>FileWriter</code>一次写入两个字节。</p>
<p>可以重新编写上面的例子，它使用这两个类将输入文件(具有unicode字符)复制到输出文件中 - </p>
<pre><code class="java">import java.io.*;
public class CopyFile &#123;

   public static void main(String args[]) throws IOException &#123;
      FileReader in = null;
      FileWriter out = null;

      try &#123;
         in = new FileReader(&quot;D:/input.txt&quot;);
         out = new FileWriter(&quot;D:/output.txt&quot;);

         int c;
         while ((c = in.read()) != -1) &#123;
            out.write(c);
         &#125;
      &#125;finally &#123;
         if (in != null) &#123;
            in.close();
         &#125;
         if (out != null) &#123;
            out.close();
         &#125;
      &#125;
   &#125;
&#125;
Java
</code></pre>
<p>假设在D盘下有一个文件：<code>input.txt</code>，它的内容如下 - </p>
<pre><code class="txt">This is test for copy file.
power by yiibai.com
Txt
</code></pre>
<p>下一步，编译上面的程序并执行它，它将创建一个：<code>D:/output.txt</code>文件，内容与<code>D:/input.txt</code>中的相同。</p>
<h2 id="2-标准流"><a href="#2-标准流" class="headerlink" title="2. 标准流"></a>2. 标准流</h2><p>所有编程语言都支持标准I/O，用户的程序可以从键盘输入，然后在计算机屏幕上产生输出。 如果您了解C或C++编程语言，那么应该了解三个标准流：<code>STDIN</code>，<code>STDOUT</code>和<code>STDERR</code>。 同样，Java提供以下三个标准流 - </p>
<ul>
<li><strong>标准输入</strong> - 用于将数据提供给用户程序，通常键盘用作标准输入流并表示为<code>System.in</code>。</li>
<li><strong>标准输出</strong> - 用于输出用户程序生成的数据，通常计算机屏幕用于标准输出流并表示为<code>System.out</code>。</li>
<li><strong>标准错误</strong> - 用于输出用户程序生成的错误数据，通常计算机屏幕用于标准错误流并表示为<code>System.err</code>。</li>
</ul>
<p>以下是一个简单的程序，它使用<code>InputStreamReader</code>来读取标准输入流，直到用户键入：<code>q</code> - </p>
<pre><code class="java">import java.io.*;
public class ReadConsole &#123;

   public static void main(String args[]) throws IOException &#123;
      InputStreamReader cin = null;

      try &#123;
         cin = new InputStreamReader(System.in);
         System.out.println(&quot;Enter characters, &#39;q&#39; to quit&gt;&quot;);
         char c;
         do &#123;
            c = (char) cin.read();
            System.out.print(c);
         &#125; while(c != &#39;q&#39;);
      &#125;finally &#123;
         if (cin != null) &#123;
            cin.close();
         &#125;
      &#125;
   &#125;
&#125;
Java
</code></pre>
<p>将上面的代码保存在<code>ReadConsole.java</code>文件中，并尝试编译并执行它，如下面的程序所示。 程序继续读取并输出用户输入的字符，直到按<code>q</code>退出 - </p>
<pre><code class="java">$javac ReadConsole.java
$java ReadConsole
Enter characters, &#39;q&#39; to quit&gt;
1
1
a
a
C
C
Java
</code></pre>
<h2 id="3-读写文件"><a href="#3-读写文件" class="headerlink" title="3. 读写文件"></a>3. 读写文件</h2><p>如前所述，流可以定义为数据序列。 <code>InputStream</code>用于从源读取数据，<code>OutputStream</code>用于将数据写入目标。</p>
<p>以下是处理输入和输出流的类层次结构。</p>
<p><img src="https://www.yiibai.com/uploads/article/2019/03/19/090254_53502.jpg" alt="输入和输出流"></p>
<p>两个重要的流是：<code>FileInputStream</code>和<code>FileOutputStream</code>，将在本教程中讨论。</p>
<p><strong>3.1. FileInputStream</strong></p>
<p>此流用于从文件中读取数据。 可以使用关键字<code>new</code>创建对象，并且有几种类型的构造函数可用。</p>
<p>以下构造函数将文件名作为字符串来创建输入流对象以读取文件 - </p>
<pre><code class="java">InputStream f = new FileInputStream(&quot;D:/java/hello.txt&quot;);
Java
</code></pre>
<p>以下构造函数采用文件对象来创建输入流对象以读取文件。 首先，使用<code>File()</code>方法创建一个文件对象，如下所示 - </p>
<pre><code class="java">File f = new File(&quot;D:/java/hello.txt&quot;);
InputStream f = new FileInputStream(f);
Java
</code></pre>
<p>当创建了<code>InputStream</code>对象，就可以使用一些辅助方法来读取流或在流上执行其他操作。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>public void close() throws IOException&#123;&#125;</code></td>
<td>此方法关闭文件输出流。 释放与该文件关联的所有系统资源，抛出<code>IOException</code>。</td>
</tr>
<tr>
<td>2</td>
<td><code>protected void finalize()throws IOException &#123;&#125;</code></td>
<td>此方法清除与文件的连接。 确保在没有对此流的引用时调用此文件输出流的<code>close()</code>方法，抛出<code>IOException</code>。</td>
</tr>
<tr>
<td>3</td>
<td><code>public int read(int r)throws IOException&#123;&#125;</code></td>
<td>此方法从<code>InputStream</code>读取指定的数据字节，并返回一个<code>int</code>值。 返回数据的下一个字节，如果它是文件的末尾，则返回<code>-1</code>。</td>
</tr>
<tr>
<td>4</td>
<td><code>public int read(byte[] r) throws IOException&#123;&#125;</code></td>
<td>此方法将输入流中的<code>r.length</code>个字节读入数组。返回读取的总字节数。 如果它到达文件的结尾，则返回<code>-1</code>。</td>
</tr>
<tr>
<td>5</td>
<td><code>public int available() throws IOException&#123;&#125;</code></td>
<td>给出可以从此文件输入流中读取的字节数。 返回一个<code>int</code>值。</td>
</tr>
</tbody></table>
<p>还有其他重要的输入流可用，有关更多详细信息，请参阅以下链接 - </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_bytearrayinputstream.html">ByteArrayInputStream</a></li>
<li><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_datainputstream.html">DataInputStream</a></li>
</ul>
<p><strong>3.2. FileOutputStream</strong></p>
<p><code>FileOutputStream</code>用于创建文件并将数据写入文件。 如果文件尚不存在，则会在打开文件以进行输出之前创建该文件。</p>
<p>这里有两个构造函数，可用于创建<code>FileOutputStream</code>对象。</p>
<p>以下构造函数将文件名作为字符串来创建输入流对象以写入文件 - </p>
<pre><code class="java">OutputStream f = new FileOutputStream(&quot;D:/java/hello.txt&quot;)
Java
</code></pre>
<p>下面的构造函数接受一个文件对象来创建一个输出流对象来写入该文件。 首先，使用<code>File()</code>方法创建一个文件对象，如下所示 - </p>
<pre><code class="java">File f = new File(&quot;D:/java/hello.txt&quot;);
OutputStream f = new FileOutputStream(f);
Java
</code></pre>
<p>当创建了<code>OutputStream</code>对象，就使用它的一些辅助方法来写入流或在流上执行其他操作。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>public void close() throws IOException&#123;&#125;</code></td>
<td>此方法关闭文件输出流，释放与该文件关联的所有系统资源。抛出<code>IOException</code>。</td>
</tr>
<tr>
<td>2</td>
<td><code>protected void finalize()throws IOException &#123;&#125;</code></td>
<td>此方法清除与文件的连接，确保在没有对此流的引用时调用此文件输出流的<code>close()</code>方法。抛出<code>IOException</code>。</td>
</tr>
<tr>
<td>3</td>
<td><code>public void write(int w)throws IOException&#123;&#125;</code></td>
<td>此方法将指定的字节写入输出流。</td>
</tr>
<tr>
<td>4</td>
<td><code>public void write(byte[] w)</code></td>
<td>将长度为<code>w.length</code>的字节从字节数组写入<code>OutputStream</code>。</td>
</tr>
</tbody></table>
<p>还有其他重要的输出流，有关更多详细信息，请参阅以下链接 - </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_bytearrayoutputstream.html">ByteArrayOutputStream</a></li>
<li><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_dataoutputstream.html">DataOutputStream</a></li>
</ul>
<p><strong>示例</strong></p>
<p>以下是演示如何使用<code>InputStream</code>和<code>OutputStream</code>类对象的示例 - </p>
<pre><code class="java">import java.io.*;
public class fileStreamTest &#123;

   public static void main(String args[]) &#123;

      try &#123;
         byte bWrite [] = &#123;11,21,3,40,5&#125;;
         OutputStream os = new FileOutputStream(&quot;D:/test.txt&quot;);
         for(int x = 0; x &lt; bWrite.length ; x++) &#123;
            os.write( bWrite[x] );   // writes the bytes
         &#125;
         os.close();

         InputStream is = new FileInputStream(&quot;D:/test.txt&quot;);
         int size = is.available();

         for(int i = 0; i &lt; size; i++) &#123;
            System.out.print((char)is.read() + &quot;  &quot;);
         &#125;
         is.close();
      &#125; catch (IOException e) &#123;
         System.out.print(&quot;Exception&quot;);
      &#125;    
   &#125;
&#125;
Java
</code></pre>
<p>上面的代码将创建文件<code>test.txt</code>并将以二进制格式写入给定的数字数据，同样也会在屏幕上输出。</p>
<h2 id="4-文件导航和I-O"><a href="#4-文件导航和I-O" class="headerlink" title="4. 文件导航和I/O"></a>4. 文件导航和I/O</h2><p>可通过其他几个类来了解文件导航和I/O的基础知识。如下 - </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_file_class.html">File类</a></li>
<li><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_filereader_class.html">FileReader类</a></li>
<li><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_filewriter_class.html">FileWriter类</a></li>
</ul>
<h4 id="4-1-目录操作"><a href="#4-1-目录操作" class="headerlink" title="4.1. 目录操作"></a>4.1. 目录操作</h4><p>目录是一个文件，它可以包含其他文件和目录的列表。 使用<code>File</code>对象创建目录，列出目录中可用的文件。 有关完整的详细信息，请查看在File对象上调用的所有方法的列表以及与目录相关的内容。</p>
<p><strong>4.1.1. 创建目录</strong></p>
<p>有两种<code>File</code>类的方法，可用于创建目录 - </p>
<ul>
<li><code>mkdir()</code>方法创建一个目录，创建成功时返回<code>true</code>，失败时返回<code>false</code>。 失败表示<code>File</code>对象中指定的路径已存在，或者由于整个路径尚不存在或权限问题而无法创建目录。</li>
<li><code>mkdirs()</code>方法创建目录和目录的所有上级目录。</li>
</ul>
<p>以下示例创建一个目录：<em>D:/tmp/user/java/bin</em> - </p>
<p><strong>示例</strong></p>
<pre><code class="java">import java.io.File;
public class CreateDir &#123;

   public static void main(String args[]) &#123;
      String dirname = &quot;D:/tmp/user/java/bin&quot;;
      File d = new File(dirname);

      // 创建目录及父级目录
      d.mkdirs();
   &#125;
&#125;
Java
</code></pre>
<p>编译并执行上面的代码来创建目录：<em>D:/tmp/user/java/bin</em>。</p>
<blockquote>
<p>注 -  Java会根据约定自动处理UNIX和Windows上的路径分隔符。如果在Windows版本的Java上使用正斜杠(/)，则路径仍将正确解析。</p>
</blockquote>
<p><strong>4.1.2. 列出目录</strong></p>
<p>可以使用<code>File</code>对象的<code>list()</code>方法列出目录中可用的所有文件和目录，如下所示 - </p>
<pre><code class="java">import java.io.File;
public class ReadDir &#123;

   public static void main(String[] args) &#123;
      File file = null;
      String[] paths;

      try &#123;      
         // 创建一个File对象
         file = new File(&quot;D:/software&quot;);

         // 文件和目录的数组
         paths = file.list();

         // 对于路径数组中的名称
         for(String path:paths) &#123;
            // 打印文件名和目录名
            System.out.println(path);
         &#125;
      &#125; catch (Exception e) &#123;
         // if any error occurs
         e.printStackTrace();
      &#125;
   &#125;
&#125;
Java
</code></pre>
<p>执行上面代码，它将根据<code>D:/software</code>目录中目录和文件产生以下结果 - </p>
<pre><code class="shell">apache-maven-3.5.4
apache-tomcat-9.0.14
Aptana_Studio
eclipse
EditPlusPortable
javajars
kafka_2.11-2.0.0
mysql-5.7.23-winx64
Navicat Premium 11
php-cs-fixer.phar
spring-2.0.5.RELEASE
... ...
</code></pre>
<h1 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h1><p>异常(或异常事件)是在执行程序期间出现的问题。 当发生异常时，程序的正常流程被中断并且程序/应用程序异常终止，这是对于用户来说是非常不友好的。因此，要合理地处理这些异常。</p>
<p>发生异常有许多不同的原因，以下是发生异常的一些情况。</p>
<ul>
<li>用户输入了无效数据。</li>
<li>找不到需要打开的文件。</li>
<li>在通信过程中丢失了网络连接，或者JVM内存不足。</li>
</ul>
<p>有一些异常是由用户错误引起的，也有一些异常是由程序员错误引起的，或者是由以某种物理资源引起的。</p>
<p>基于这三类异常，您需要了解它们以了解在Java中异常处理工作原理。</p>
<ul>
<li><strong>已检查异常</strong> - 已检查异常是编译器在编译时检查(通知)的异常，这些异常也称为编译时异常。这些异常不能简单地忽略，程序员应该编写代码来处理这些异常。<br>例如，如果在程序中使用<code>FileReader</code>类从文件中读取数据，如果其构造函数中指定的文件不存在，则会发生<code>FileNotFoundException</code>异常，并且编译器会提示程序员处理异常。示例代码 -</li>
</ul>
<pre><code class="java">import java.io.File;
import java.io.FileReader;

public class FilenotFound_Demo &#123;

   public static void main(String args[]) &#123;        
      File file = new File(&quot;E://file.txt&quot;);
      FileReader fr = new FileReader(file); 
   &#125;
&#125;
Java
</code></pre>
<p>如果编译上述程序，则会出现以下异常。</p>
<pre><code class="shell">C:\&gt;javac FilenotFound_Demo.java
FilenotFound_Demo.java:8: error: unreported exception FileNotFoundException; must be caught or declared to be thrown
      FileReader fr = new FileReader(file);
                      ^
1 error
Shell
</code></pre>
<blockquote>
<p>注 - 由于<code>FileReader</code>类的<code>read()</code>和<code>close()</code>方法抛出<code>IOException</code>，可以看到到编译器通知要求处理<code>IOException</code>以及<code>FileNotFoundException</code>这两个异常。</p>
</blockquote>
<ul>
<li><p><strong>未检查异常</strong> - 未检查的异常是在执行时发生的异常。这些也称为运行时异常。 这些包括编程错误，例如逻辑错误或API的不当使用，编译时忽略运行时异常。<br>例如，如果在程序中声明了一个大小为<code>5</code>的数组，但是却要访问数组的第<code>6</code>个元素，则会发生<code>ArrayIndexOutOfBoundsExceptionexception</code>异常。</p>
<pre><code class="java">public class Unchecked_Demo &#123;

 public static void main(String args[]) &#123;
    int num[] = &#123;1, 2, 3, 4&#125;;
    System.out.println(num[5]);// 访问第6个元素
 &#125;
&#125;
Java
</code></pre>
<p>如果编译并执行上述程序，则会出现以下异常。</p>
<pre><code class="shell">Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 5
  at Exceptions.Unchecked_Demo.main(Unchecked_Demo.java:8)
Shell
</code></pre>
</li>
<li><p><strong>错误</strong> - 这个严格来说不是异常，它是超出用户或程序员控制的问题。 代码中通常会忽略错误，因为很少对错误做任何事情。 例如，如果发生堆栈溢出，则会出现错误。 它们在编译时也被忽略。</p>
</li>
</ul>
<h2 id="1-异常层次结构"><a href="#1-异常层次结构" class="headerlink" title="1. 异常层次结构"></a>1. 异常层次结构</h2><p>所有异常类都是<code>java.lang.Exception</code>类的子类型。 <code>Exception</code>类是<code>Throwable</code>类的子类。 除了<code>Exception</code>类之外，还有另一个名称为<code>Error</code>的子类，它派生自<code>Throwable</code>类。</p>
<p>错误是在严重故障的情况下发生的异常情况，Java程序不处理这些情况。 生成错误以指示运行时环境生成的错误。例如：JVM内存不足。 通常，程序无法从错误中恢复。</p>
<p><code>Exception</code>类有两个主要的子类：<code>IOException</code>类和<code>RuntimeException</code>类。</p>
<p><img src="https://www.yiibai.com/uploads/article/2019/03/19/121433_14520.jpg" alt="Java异常层次结构"></p>
<p>以下是最常见的已检查和未检查的<a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_builtin_exceptions.html">Java内置异常类</a>列表。</p>
<h2 id="2-异常方法"><a href="#2-异常方法" class="headerlink" title="2. 异常方法"></a>2. 异常方法</h2><p>以下是<code>Throwable</code>类中可用的方法列表。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>方法</th>
<th>异常</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>public String getMessage()</code></td>
<td>返回有关已发生的异常的详细消息，此消息在<code>Throwable</code>构造函数中初始化。</td>
</tr>
<tr>
<td>2</td>
<td><code>public Throwable getCause()</code></td>
<td>返回由<code>Throwable</code>对象表示的异常的原因。</td>
</tr>
<tr>
<td>3</td>
<td><code>public String toString()</code></td>
<td>返回与<code>getMessage()</code>结果连接的类名称。</td>
</tr>
<tr>
<td>4</td>
<td><code>public void printStackTrace()</code></td>
<td>将<code>toString()</code>的结果与堆栈跟踪一起打印到<code>System.err</code>(错误输出流)。</td>
</tr>
<tr>
<td>5</td>
<td><code>public StackTraceElement [] getStackTrace()</code></td>
<td>返回包含堆栈跟踪上每个元素的数组。 索引<code>0</code>处的元素表示调用堆栈的顶部，而数组中的最后一个元素表示调用堆栈底部的方法。</td>
</tr>
<tr>
<td>6</td>
<td><code>public Throwable fillInStackTrace()</code></td>
<td>使用当前堆栈跟踪填充此<code>Throwable</code>对象的堆栈跟踪，添加堆栈跟踪中的任何先前信息。</td>
</tr>
</tbody></table>
<h2 id="3-捕捉异常"><a href="#3-捕捉异常" class="headerlink" title="3. 捕捉异常"></a>3. 捕捉异常</h2><p>在方法中可使用<code>try</code>和<code>catch</code>关键字的组合捕获异常。<code>try/catch</code>块放在可能生成异常的代码周围。<code>try/catch</code>块中的代码称为受保护代码，使用<code>try/catch</code>的语法如下所示 - </p>
<p><strong>语法</strong></p>
<pre><code class="java">try &#123;
   // Protected code
&#125; catch (ExceptionName e1) &#123;
   // Catch block
&#125;
Java
</code></pre>
<p>将容易出现异常的代码放在<code>try</code>块中。 发生异常时，异常由与其关联的<code>catch</code>块处理。 每个<code>try</code>块都应该紧跟一个<code>catch</code>块或者一个块<code>finally</code>。</p>
<p><code>catch</code>语句涉及声明尝试捕获的异常类型。 如果受保护代码中发生异常，则会检查<code>try</code>之后的<code>catch</code>块(或多个块)。如果发生的异常类型列在<code>catch</code>块中，则异常将传递给<code>catch</code>块，就像将参数传递给方法参数一样。</p>
<p><strong>示例</strong></p>
<p>以下是使用<code>2</code>个元素声明的数组，然后尝试访问引发异常的数组的第<code>3</code>个元素。</p>
<pre><code class="java">// 文件 : ExcepTest.java
import java.io.*;

public class ExcepTest &#123;

   public static void main(String args[]) &#123;
      try &#123;
         int a[] = new int[2];
         System.out.println(&quot;Access element three :&quot; + a[3]);
      &#125; catch (ArrayIndexOutOfBoundsException e) &#123;
         System.out.println(&quot;Exception thrown  :&quot; + e);
      &#125;
      System.out.println(&quot;Out of the block&quot;);
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果：</p>
<pre><code class="shell">Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3
Out of the block
Shell
</code></pre>
<h2 id="4-多个try块"><a href="#4-多个try块" class="headerlink" title="4. 多个try块"></a>4. 多个try块</h2><p><code>try</code>块后面可以跟多个<code>catch</code>块，多个<code>catch</code>块的语法如下所示 - </p>
<p><strong>语法</strong></p>
<pre><code class="java">try &#123;
   // Protected code
&#125; catch (ExceptionType1 e1) &#123;
   // Catch block
&#125; catch (ExceptionType2 e2) &#123;
   // Catch block
&#125; catch (ExceptionType3 e3) &#123;
   // Catch block
&#125;
Java
</code></pre>
<p>上面的语句中放置了三个<code>catch</code>块，但只需一次尝试即可获得任意数量的块。 如果受保护代码中发生异常，则会将异常抛出到列表中的第一个<code>catch</code>块。 如果抛出的异常的数据类型与<code>ExceptionType1</code>匹配，则会在那里捕获它。 如果不是，则异常传递给第二个<code>catch</code>语句。 这种情况一直持续到异常被捕获，在这种情况下，当前方法停止执行，异常将被抛到调用堆栈上的前一个方法。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>以下是显示如何使用多个<code>try/catch</code>语句的代码段。</p>
<pre><code class="java">try &#123;
   file = new FileInputStream(fileName);
   x = (byte) file.read();
&#125; catch (IOException i) &#123;
   i.printStackTrace();
   return -1;
&#125; catch (FileNotFoundException f) // Not valid! &#123;
   f.printStackTrace();
   return -1;
&#125;
Java
</code></pre>
<p><strong>捕获多种类型的例外</strong><br>从Java 7开始，可以使用单个<code>catch</code>块处理多个异常，此功能简化了代码。 下面是应用示例 - </p>
<pre><code class="java">catch (IOException|FileNotFoundException ex) &#123;
   logger.log(ex);
   throw ex;
Java
</code></pre>
<h2 id="5-throws-throw关键字"><a href="#5-throws-throw关键字" class="headerlink" title="5. throws/throw关键字"></a>5. throws/throw关键字</h2><p>如果方法不处理已检查的异常，则该方法必须使用<code>throws</code>关键字声明它。 <code>throws</code>关键字应放置在方法签名的末尾。</p>
<p>可以使用<code>throw</code>关键字抛出异常，可以是新实例化的异常，也可以是刚捕获的异常。</p>
<p><code>throws</code>和<code>throw</code>关键字之间的区别是，<code>throws</code>用于推迟对已检查异常的处理，<code>throw</code>用于显式调用异常。</p>
<p>以下方法声明它抛出<code>RemoteException</code>  - </p>
<pre><code class="java">import java.io.*;
public class className &#123;

   public void deposit(double amount) throws RemoteException &#123;
      // Method implementation
      throw new RemoteException();
   &#125;
   // Remainder of class definition
&#125;
Java
</code></pre>
<p>可以将方法声明为抛出多个异常，在这种情况下，异常在以逗号分隔的列表中声明。 例如，以下方法声明它抛出<code>RemoteException</code>和<code>InsufficientFundsException</code>异常  - </p>
<pre><code class="java">import java.io.*;
public class className &#123;

   public void withdraw(double amount) throws RemoteException, 
      InsufficientFundsException &#123;
      // Method implementation
   &#125;
   // Remainder of class definition
&#125;
Java
</code></pre>
<h2 id="6-finally块"><a href="#6-finally块" class="headerlink" title="6. finally块"></a>6. finally块</h2><p><code>finally</code>块在<code>try</code>块或<code>catch</code>块之后。无论受保护的代码块是否发生异常，最终都会执行<code>finally</code>块中的代码。</p>
<p>使用<code>finally</code>块运行要执行的任何清理类型语句，无论受保护代码中发生什么。</p>
<p><code>finally</code>块放置在<code>catch</code>块的末尾，它的语法语法如下 - </p>
<pre><code class="java">try &#123;
   // Protected code
&#125; catch (ExceptionType1 e1) &#123;
   // Catch block
&#125; catch (ExceptionType2 e2) &#123;
   // Catch block
&#125; catch (ExceptionType3 e3) &#123;
   // Catch block
&#125;finally &#123;
   // The finally block always executes.
&#125;
Java
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="java">public class ExcepTest &#123;

   public static void main(String args[]) &#123;
      int a[] = new int[2];
      try &#123;
         System.out.println(&quot;Access element three :&quot; + a[3]);
      &#125; catch (ArrayIndexOutOfBoundsException e) &#123;
         System.out.println(&quot;Exception thrown  :&quot; + e);
      &#125;finally &#123;
         a[0] = 6;
         System.out.println(&quot;First element value: &quot; + a[0]);
         System.out.println(&quot;The finally statement is executed&quot;);
      &#125;
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果 - </p>
<pre><code class="shell">Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3
First element value: 6
The finally statement is executed
Shell
</code></pre>
<p>使用<code>finally</code>时，需要注意以下规则 - </p>
<ul>
<li>没有<code>try</code>语句就不能存在<code>catch</code>子句。</li>
<li>只要存在<code>try/catch</code>块，<code>finally</code>子句就不是必须的。</li>
<li>如果没有<code>catch</code>子句或<code>finally</code>子句，则<code>try</code>块不能出现。</li>
<li><code>try</code>，<code>catch</code>，<code>finally</code>块之间不能出现任何代码。</li>
</ul>
<h2 id="7-try-with-resources"><a href="#7-try-with-resources" class="headerlink" title="7.  try-with-resources"></a>7.  try-with-resources</h2><p>通常，当使用流，连接等任何资源时，要使用<code>finally</code>块显式关闭它们。 在下面的程序中使用<code>FileReader</code>从文件中读取数据，然后使用<code>finally</code>块关闭它。</p>
<pre><code class="java">import java.io.File;
import java.io.FileReader;
import java.io.IOException;

public class ReadData_Demo &#123;

   public static void main(String args[]) &#123;
      FileReader fr = null;        
      try &#123;
         File file = new File(&quot;file.txt&quot;);
         fr = new FileReader(file); char [] a = new char[50];
         fr.read(a);   // reads the content to the array
         for(char c : a)
         System.out.print(c);   // prints the characters one by one
      &#125; catch (IOException e) &#123;
         e.printStackTrace();
      &#125;finally &#123;
         try &#123;
            fr.close();
         &#125; catch (IOException ex) &#123;        
            ex.printStackTrace();
         &#125;
      &#125;
   &#125;
&#125;
Java
</code></pre>
<p><code>try-with-resources</code>，也称为自动资源管理，是Java 7中引入的一种新的异常处理机制，它自动关闭<code>try/catch</code>块中使用的资源。</p>
<p>要使用此语句，只需在括号内声明所需的资源，创建的资源将在块结束时自动关闭。 以下是<code>try-with-resources</code>语句的语法。</p>
<p><strong>语法</strong></p>
<pre><code class="java">try(FileReader fr = new FileReader(&quot;file path&quot;)) &#123;
   // use the resource
   &#125; catch () &#123;
      // body of catch 
   &#125;
&#125;
Java
</code></pre>
<p>以下是使用<code>try-with-resources</code>语句读取文件中数据的程序。</p>
<pre><code class="java">import java.io.FileReader;
import java.io.IOException;

public class Try_withDemo &#123;

   public static void main(String args[]) &#123;
      try(FileReader fr = new FileReader(&quot;E://file.txt&quot;)) &#123;
         char [] a = new char[50];
         fr.read(a);   // reads the contentto the array
         for(char c : a)
         System.out.print(c);   // prints the characters one by one
      &#125; catch (IOException e) &#123;
         e.printStackTrace();
      &#125;
   &#125;
&#125;
Java
</code></pre>
<p>在使用<code>try-with-resources</code>语句时，请牢记以下几点。</p>
<ul>
<li>要使用带有<code>try-with-resources</code>语句的类，它应该实现<code>AutoCloseable</code>接口，并且它的<code>close()</code>方法在运行时自动调用。</li>
<li>可以在<code>try-with-resources</code>语句中声明多个类。</li>
<li>当在<code>try-with-resources</code>语句的<code>try</code>块中声明多个类时，这些类将以相反的顺序关闭。</li>
<li>除括号内的资源声明外，其它都与<code>try</code>块的普通<code>try/catch</code>块相同。</li>
<li><code>try</code>中声明的资源在<code>try-block</code>开始之前实例化。</li>
<li>在<code>try</code>块声明的资源被隐式声明为<code>final</code>。</li>
</ul>
<h2 id="8-用户定义的异常"><a href="#8-用户定义的异常" class="headerlink" title="8. 用户定义的异常"></a>8. 用户定义的异常</h2><p>可以在Java中创建自己的异常。 在编写自己的异常类时，请注意以下几点 - </p>
<ul>
<li>所有异常必须是<code>Throwable</code>的子类。</li>
<li>如果要编写由处理或声明规则自动强制执行的已检查异常，则需要扩展<code>Exception</code>类。</li>
<li>如果要编写运行时异常，则需要扩展<code>RuntimeException</code>类。</li>
</ul>
<p>可以定义自己的<code>Exception</code>类，如下所示 - </p>
<pre><code class="java">class MyException extends Exception &#123;
&#125;
Java
</code></pre>
<p>只需要扩展预定义的<code>Exception</code>类来创建自己的<code>Exception</code>类。 这些都是经过检查的异常。 以下<code>InsufficientFundsException</code>类是一个用户定义的异常，它扩展了<code>Exception</code>类，使其成为一个已检查的异常。异常类与任何其他类一样，包含有用的字段和方法。</p>
<p><strong>示例</strong></p>
<pre><code class="java">// 文件：InsufficientFundsException.java
import java.io.*;

public class InsufficientFundsException extends Exception &#123;
   private double amount;

   public InsufficientFundsException(double amount) &#123;
      this.amount = amount;
   &#125;

   public double getAmount() &#123;
      return amount;
   &#125;
&#125;
Java
</code></pre>
<p>为了演示如何使用用户定义的异常，以下<code>CheckingAccount</code>类的<code>withdraw()</code>方法中包含抛出<code>InsufficientFundsException</code>。</p>
<pre><code class="java">// 文件名称：CheckingAccount.java
import java.io.*;

public class CheckingAccount &#123;
   private double balance;
   private int number;

   public CheckingAccount(int number) &#123;
      this.number = number;
   &#125;

   public void deposit(double amount) &#123;
      balance += amount;
   &#125;

   public void withdraw(double amount) throws InsufficientFundsException &#123;
      if(amount &lt;= balance) &#123;
         balance -= amount;
      &#125;else &#123;
         double needs = amount - balance;
         throw new InsufficientFundsException(needs);
      &#125;
   &#125;

   public double getBalance() &#123;
      return balance;
   &#125;

   public int getNumber() &#123;
      return number;
   &#125;
&#125;
Java
</code></pre>
<p>以下<code>BankDemo</code>程序演示了如何调用<code>CheckingAccount</code>类的<code>deposit()</code>和<code>withdraw()</code>方法。</p>
<pre><code class="java">// 文件： BankDemo.java
public class BankDemo &#123;

   public static void main(String [] args) &#123;
      CheckingAccount c = new CheckingAccount(101);
      System.out.println(&quot;Depositing $500...&quot;);
      c.deposit(500.00);

      try &#123;
         System.out.println(&quot;\nWithdrawing $100...&quot;);
         c.withdraw(100.00);
         System.out.println(&quot;\nWithdrawing $600...&quot;);
         c.withdraw(600.00);
      &#125; catch (InsufficientFundsException e) &#123;
         System.out.println(&quot;Sorry, but you are short $&quot; + e.getAmount());
         e.printStackTrace();
      &#125;
   &#125;
&#125;
Java
</code></pre>
<p>执行上面示例代码，得到以下结果 - </p>
<pre><code class="shell">Depositing $500...

Withdrawing $100...

Withdrawing $600...
Sorry, but you are short $200.0
InsufficientFundsException
         at CheckingAccount.withdraw(CheckingAccount.java:25)
         at BankDemo.main(BankDemo.java:13)
Shell
</code></pre>
<p><strong>常见异常</strong></p>
<p>在Java中，可以定义两个分类:异常和错误。</p>
<ul>
<li><strong>JVM异常</strong> - 这些是JVM独占或逻辑抛出的异常/错误。 示例：<code>NullPointerException</code>，<code>ArrayIndexOutOfBoundsException</code>，<code>ClassCastException</code>。</li>
<li><strong>程序化异常</strong> - 应用程序或API程序员明确抛出这些异常。 示例：<code>IllegalArgumentException</code>，<code>IllegalStateException</code>。</li>
</ul>
<p>//原文出自【易百教程】</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。 </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
